/**
 * Cesium - https://github.com/AnalyticalGraphicsInc/cesium
 *
 * Copyright 2011-2015 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md for full licensing details.
 */
{
  "version": 3,
  "file": "/home/ltgal/mf-geoadmin3/.build-artefacts/ol3-cesium/cesium/Build/combineOutput/Workers/createRectangleGeometry.js",
  "sources": [
    "Core/defined.js",
    "Core/freezeObject.js",
    "Core/defaultValue.js",
    "Core/DeveloperError.js",
    "ThirdParty/mersenne-twister.js",
    "Core/Math.js",
    "Core/Cartesian3.js",
    "Core/Cartographic.js",
    "Core/defineProperties.js",
    "Core/Ellipsoid.js",
    "Core/Rectangle.js",
    "Core/deprecationWarning.js",
    "Core/GeographicProjection.js",
    "Core/Intersect.js",
    "Core/Interval.js",
    "Core/Cartesian4.js",
    "Core/Matrix3.js",
    "Core/RuntimeError.js",
    "Core/Matrix4.js",
    "Core/Plane.js",
    "Core/BoundingSphere.js",
    "Core/Cartesian2.js",
    "Renderer/WebGLConstants.js",
    "Core/Fullscreen.js",
    "Core/FeatureDetection.js",
    "Core/ComponentDatatype.js",
    "Core/GeometryType.js",
    "Core/PrimitiveType.js",
    "Core/Geometry.js",
    "Core/GeometryAttribute.js",
    "Core/GeometryAttributes.js",
    "Core/GeometryInstance.js",
    "Core/AttributeCompression.js",
    "Core/barycentricCoordinates.js",
    "Core/EncodedCartesian3.js",
    "Core/IndexDatatype.js",
    "Core/QuadraticRealPolynomial.js",
    "Core/CubicRealPolynomial.js",
    "Core/QuarticRealPolynomial.js",
    "Core/Ray.js",
    "Core/IntersectionTests.js",
    "Core/Tipsify.js",
    "Core/GeometryPipeline.js",
    "Core/Matrix2.js",
    "Core/AxisAlignedBoundingBox.js",
    "ThirdParty/when.js",
    "Core/binarySearch.js",
    "Core/EarthOrientationParametersSample.js",
    "ThirdParty/sprintf.js",
    "Core/GregorianDate.js",
    "Core/isLeapYear.js",
    "Core/LeapSecond.js",
    "Core/TimeConstants.js",
    "Core/TimeStandard.js",
    "Core/JulianDate.js",
    "Core/clone.js",
    "Core/parseResponseHeaders.js",
    "Core/RequestErrorEvent.js",
    "Core/loadWithXhr.js",
    "Core/loadText.js",
    "Core/loadJson.js",
    "Core/EarthOrientationParameters.js",
    "ThirdParty/Uri.js",
    "Core/buildModuleUrl.js",
    "Core/Iau2006XysSample.js",
    "Core/Iau2006XysData.js",
    "Core/Quaternion.js",
    "Core/Transforms.js",
    "Core/EllipsoidTangentPlane.js",
    "Core/pointInsideTriangle.js",
    "Core/EllipsoidGeodesic.js",
    "Core/isArray.js",
    "Core/PolylinePipeline.js",
    "Core/Queue.js",
    "Core/WindingOrder.js",
    "Core/PolygonPipeline.js",
    "Core/RectangleGeometryLibrary.js",
    "Core/VertexFormat.js",
    "Core/RectangleGeometry.js",
    "Workers/createRectangleGeometry.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA,ADyBA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA,ADmCA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1MA,AD2MA;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChxBA,ADixBA;AChxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5iCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA,ADkCA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChEA,ADiEA;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA,ADiCA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxgDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA,ADmEA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtsFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChLA,ADiLA;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnUA,ADoUA;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9PA,AD+PA;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjNA,ADkNA;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA,AD6FA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA,ADiIA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA,ADqFA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA,AD4IA;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA,AD4EA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC33BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA,AD8SA;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC93EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC17BA,AD27BA;AC17BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3uBA,AD4uBA;AC3uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA,ADmFA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9TA,AD+TA;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA,AD+BA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA,ADmCA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA,AD4CA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrLA,ADsLA;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA,AD2CA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA,ADoEA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrRA,ADsRA;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA,ADuGA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA,ADsCA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3nCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtzBA,ADuzBA;ACtzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA,ADsCA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA,ADuBA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA,AD2CA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACphCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClTA,ADmTA;AClTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/*global define*/\ndefine('Core/defined',[],function() {\n    \"use strict\";\n\n    /**\n     * @exports defined\n     *\n     * @param {Object} value The object.\n     * @returns {Boolean} Returns true if the object is defined, returns false otherwise.\n     *\n     * @example\n     * if (Cesium.defined(positions)) {\n     *      doSomething();\n     * } else {\n     *      doSomethingElse();\n     * }\n     */\n    var defined = function(value) {\n        return value !== undefined;\n    };\n\n    return defined;\n});\n",
    "\n/*global define*/\ndefine('Core/freezeObject',[\n        './defined'\n    ], function(\n        defined) {\n    \"use strict\";\n\n    /**\n     * Freezes an object, using Object.freeze if available, otherwise returns\n     * the object unchanged.  This function should be used in setup code to prevent\n     * errors from completely halting JavaScript execution in legacy browsers.\n     *\n     * @private\n     *\n     * @exports freezeObject\n     */\n    var freezeObject = Object.freeze;\n    if (!defined(freezeObject)) {\n        freezeObject = function(o) {\n            return o;\n        };\n    }\n\n    return freezeObject;\n});",
    "\n/*global define*/\ndefine('Core/defaultValue',[\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * Returns the first parameter if not undefined, otherwise the second parameter.\n     * Useful for setting a default value for a parameter.\n     *\n     * @exports defaultValue\n     *\n     * @param {*} a\n     * @param {*} b\n     * @returns {*} Returns the first parameter if not undefined, otherwise the second parameter.\n     *\n     * @example\n     * param = Cesium.defaultValue(param, 'default');\n     */\n    var defaultValue = function(a, b) {\n        if (a !== undefined) {\n            return a;\n        }\n        return b;\n    };\n\n    /**\n     * A frozen empty object that can be used as the default value for options passed as\n     * an object literal.\n     */\n    defaultValue.EMPTY_OBJECT = freezeObject({});\n\n    return defaultValue;\n});",
    "\n/*global define*/\ndefine('Core/DeveloperError',[\n        './defined'\n    ], function(\n        defined) {\n    \"use strict\";\n\n    /**\n     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,\n     * argument out of range, etc.  This exception should only be thrown during development;\n     * it usually indicates a bug in the calling code.  This exception should never be\n     * caught; instead the calling code should strive not to generate it.\n     * <br /><br />\n     * On the other hand, a {@link RuntimeError} indicates an exception that may\n     * be thrown at runtime, e.g., out of memory, that the calling code should be prepared\n     * to catch.\n     *\n     * @alias DeveloperError\n     * @constructor\n     *\n     * @param {String} [message] The error message for this exception.\n     *\n     * @see RuntimeError\n     */\n    var DeveloperError = function(message) {\n        /**\n         * 'DeveloperError' indicating that this exception was thrown due to a developer error.\n         * @type {String}\n         * @readonly\n         */\n        this.name = 'DeveloperError';\n\n        /**\n         * The explanation for why this exception was thrown.\n         * @type {String}\n         * @readonly\n         */\n        this.message = message;\n\n        //Browsers such as IE don't have a stack property until you actually throw the error.\n        var stack;\n        try {\n            throw new Error();\n        } catch (e) {\n            stack = e.stack;\n        }\n\n        /**\n         * The stack trace of this exception, if available.\n         * @type {String}\n         * @readonly\n         */\n        this.stack = stack;\n    };\n\n    DeveloperError.prototype.toString = function() {\n        var str = this.name + ': ' + this.message;\n\n        if (defined(this.stack)) {\n            str += '\\n' + this.stack.toString();\n        }\n\n        return str;\n    };\n\n    /**\n     * @private\n     */\n    DeveloperError.throwInstantiationError = function() {\n        throw new DeveloperError('This function defines an interface and should not be called directly.');\n    };\n\n    return DeveloperError;\n});\n",
    "\n/*\n  I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n  so it's better encapsulated. Now you can have multiple random number generators\n  and they won't stomp all over eachother's state.\n\n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n\n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n\n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n*/\n/**\n@license\nmersenne-twister.js - https://gist.github.com/banksean/300494\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\ndefine('ThirdParty/mersenne-twister',[],function() {\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  }\n  /* Period parameters */\n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n\n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n}\n\n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n}\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\n//MersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n//  var i, j, k;\n//  this.init_genrand(19650218);\n//  i=1; j=0;\n//  k = (this.N>key_length ? this.N : key_length);\n//  for (; k; k--) {\n//    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n//    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n//      + init_key[j] + j; /* non linear */\n//    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n//    i++; j++;\n//    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n//    if (j>=key_length) j=0;\n//  }\n//  for (k=this.N-1; k; k--) {\n//    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n//    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n//      - i; /* non linear */\n//    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n//    i++;\n//    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n//  }\n//\n//  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n//}\n\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n}\n\n/* generates a random number on [0,0x7fffffff]-interval */\n//MersenneTwister.prototype.genrand_int31 = function() {\n//  return (this.genrand_int32()>>>1);\n//}\n\n/* generates a random number on [0,1]-real-interval */\n//MersenneTwister.prototype.genrand_real1 = function() {\n//  return this.genrand_int32()*(1.0/4294967295.0);\n//  /* divided by 2^32-1 */\n//}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0);\n  /* divided by 2^32 */\n}\n\n/* generates a random number on (0,1)-real-interval */\n//MersenneTwister.prototype.genrand_real3 = function() {\n//  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);\n//  /* divided by 2^32 */\n//}\n\n/* generates a random number on [0,1) with 53-bit resolution*/\n//MersenneTwister.prototype.genrand_res53 = function() {\n//  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;\n//  return(a*67108864.0+b)*(1.0/9007199254740992.0);\n//}\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nreturn MersenneTwister;\n});",
    "\n/*global define*/\ndefine('Core/Math',[\n        '../ThirdParty/mersenne-twister',\n        './defaultValue',\n        './defined',\n        './DeveloperError'\n    ], function(\n        MersenneTwister,\n        defaultValue,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Math functions.\n     *\n     * @namespace\n     * @alias CesiumMath\n     */\n    var CesiumMath = {};\n\n    /**\n     * 0.1\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON1 = 0.1;\n\n    /**\n     * 0.01\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON2 = 0.01;\n\n    /**\n     * 0.001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON3 = 0.001;\n\n    /**\n     * 0.0001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON4 = 0.0001;\n\n    /**\n     * 0.00001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON5 = 0.00001;\n\n    /**\n     * 0.000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON6 = 0.000001;\n\n    /**\n     * 0.0000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON7 = 0.0000001;\n\n    /**\n     * 0.00000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON8 = 0.00000001;\n\n    /**\n     * 0.000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON9 = 0.000000001;\n\n    /**\n     * 0.0000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON10 = 0.0000000001;\n\n    /**\n     * 0.00000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON11 = 0.00000000001;\n\n    /**\n     * 0.000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON12 = 0.000000000001;\n\n    /**\n     * 0.0000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON13 = 0.0000000000001;\n\n    /**\n     * 0.00000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON14 = 0.00000000000001;\n\n    /**\n     * 0.000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON15 = 0.000000000000001;\n\n    /**\n     * 0.0000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON16 = 0.0000000000000001;\n\n    /**\n     * 0.00000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON17 = 0.00000000000000001;\n\n    /**\n     * 0.000000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON18 = 0.000000000000000001;\n\n    /**\n     * 0.0000000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON19 = 0.0000000000000000001;\n\n    /**\n     * 0.00000000000000000001\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.EPSILON20 = 0.00000000000000000001;\n\n    /**\n     * 3.986004418e14\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n    /**\n     * Radius of the sun in meters: 6.955e8\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.SOLAR_RADIUS = 6.955e8;\n\n    /**\n     * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n     * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n     * Celestial Mechanics 82: 83-110, 2002.\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.LUNAR_RADIUS = 1737400.0;\n\n    /**\n     * 64 * 1024\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n    /**\n     * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n     * negative, or 0 if the value is 0.\n     *\n     * @param {Number} value The value to return the sign of.\n     * @returns {Number} The sign of value.\n     */\n    CesiumMath.sign = function(value) {\n        if (value > 0) {\n            return 1;\n        }\n        if (value < 0) {\n            return -1;\n        }\n\n        return 0;\n    };\n\n    /**\n     * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n     * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n     * 0.0 when the input value is 0.0.\n     * @param {Number} value The value to return the sign of.\n     * @returns {Number} The sign of value.\n     */\n    CesiumMath.signNotZero = function(value) {\n        return value < 0.0 ? -1.0 : 1.0;\n    };\n\n    /**\n     * Converts a scalar value in the range [-1.0, 1.0] to a 8-bit 2's complement number.\n     * @param {Number} value The scalar value in the range [-1.0, 1.0]\n     * @returns {Number} The 8-bit 2's complement number, where 0 maps to -1.0 and 255 maps to 1.0.\n     *\n     * @see CesiumMath.fromSNorm\n     */\n    CesiumMath.toSNorm = function(value) {\n        return Math.round((CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * 255.0);\n    };\n\n    /**\n     * Converts a SNORM value in the range [0, 255] to a scalar in the range [-1.0, 1.0].\n     * @param {Number} value SNORM value in the range [0, 255]\n     * @returns {Number} Scalar in the range [-1.0, 1.0].\n     *\n     * @see CesiumMath.toSNorm\n     */\n    CesiumMath.fromSNorm = function(value) {\n        return CesiumMath.clamp(value, 0.0, 255.0) / 255.0 * 2.0 - 1.0;\n    };\n\n    /**\n     * Returns the hyperbolic sine of a number.\n     * The hyperbolic sine of <em>value</em> is defined to be\n     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n     * where <i>e</i> is Euler's number, approximately 2.71828183.\n     *\n     * <p>Special cases:\n     *   <ul>\n     *     <li>If the argument is NaN, then the result is NaN.</li>\n     *\n     *     <li>If the argument is infinite, then the result is an infinity\n     *     with the same sign as the argument.</li>\n     *\n     *     <li>If the argument is zero, then the result is a zero with the\n     *     same sign as the argument.</li>\n     *   </ul>\n     *</p>\n     *\n     * @param {Number} value The number whose hyperbolic sine is to be returned.\n     * @returns {Number} The hyperbolic sine of <code>value</code>.\n     */\n    CesiumMath.sinh = function(value) {\n        var part1 = Math.pow(Math.E, value);\n        var part2 = Math.pow(Math.E, -1.0 * value);\n\n        return (part1 - part2) * 0.5;\n    };\n\n    /**\n     * Returns the hyperbolic cosine of a number.\n     * The hyperbolic cosine of <strong>value</strong> is defined to be\n     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n     * where <i>e</i> is Euler's number, approximately 2.71828183.\n     *\n     * <p>Special cases:\n     *   <ul>\n     *     <li>If the argument is NaN, then the result is NaN.</li>\n     *\n     *     <li>If the argument is infinite, then the result is positive infinity.</li>\n     *\n     *     <li>If the argument is zero, then the result is 1.0.</li>\n     *   </ul>\n     *</p>\n     *\n     * @param {Number} value The number whose hyperbolic cosine is to be returned.\n     * @returns {Number} The hyperbolic cosine of <code>value</code>.\n     */\n    CesiumMath.cosh = function(value) {\n        var part1 = Math.pow(Math.E, value);\n        var part2 = Math.pow(Math.E, -1.0 * value);\n\n        return (part1 + part2) * 0.5;\n    };\n\n    /**\n     * Computes the linear interpolation of two values.\n     *\n     * @param {Number} p The start value to interpolate.\n     * @param {Number} q The end value to interpolate.\n     * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n     * @returns {Number} The linearly interpolated value.\n     *\n     * @example\n     * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n     */\n    CesiumMath.lerp = function(p, q, time) {\n        return ((1.0 - time) * p) + (time * q);\n    };\n\n    /**\n     * pi\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.PI = Math.PI;\n\n    /**\n     * 1/pi\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n    /**\n     * pi/2\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;\n\n    /**\n     * pi/3\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n    /**\n     * pi/4\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n    /**\n     * pi/6\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n    /**\n     * 3pi/2\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;\n\n    /**\n     * 2pi\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.TWO_PI = 2.0 * Math.PI;\n\n    /**\n     * 1/2pi\n     *\n     * @type {Number}\n     * @constant\n     */\n    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n    /**\n     * The number of radians in a degree.\n     *\n     * @type {Number}\n     * @constant\n     * @default Math.PI / 180.0\n     */\n    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n    /**\n     * The number of degrees in a radian.\n     *\n     * @type {Number}\n     * @constant\n     * @default 180.0 / Math.PI\n     */\n    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n    /**\n     * The number of radians in an arc second.\n     *\n     * @type {Number}\n     * @constant\n     * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0\n     */\n    CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n    /**\n     * Converts degrees to radians.\n     * @param {Number} degrees The angle to convert in degrees.\n     * @returns {Number} The corresponding angle in radians.\n     */\n    CesiumMath.toRadians = function(degrees) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(degrees)) {\n            throw new DeveloperError('degrees is required.');\n        }\n        //>>includeEnd('debug');\n        return degrees * CesiumMath.RADIANS_PER_DEGREE;\n    };\n\n    /**\n     * Converts radians to degrees.\n     * @param {Number} radians The angle to convert in radians.\n     * @returns {Number} The corresponding angle in degrees.\n     */\n    CesiumMath.toDegrees = function(radians) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(radians)) {\n            throw new DeveloperError('radians is required.');\n        }\n        //>>includeEnd('debug');\n        return radians * CesiumMath.DEGREES_PER_RADIAN;\n    };\n\n    /**\n     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n     *\n     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n     * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n     *\n     * @example\n     * // Convert 270 degrees to -90 degrees longitude\n     * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n     */\n    CesiumMath.convertLongitudeRange = function(angle) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        //>>includeEnd('debug');\n        var twoPi = CesiumMath.TWO_PI;\n\n        var simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n        if (simplified < -Math.PI) {\n            return simplified + twoPi;\n        }\n        if (simplified >= Math.PI) {\n            return simplified - twoPi;\n        }\n\n        return simplified;\n    };\n\n    /**\n     * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n     *\n     * @param {Number} angle in radians\n     * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n     */\n    CesiumMath.negativePiToPi = function(x) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(x)) {\n            throw new DeveloperError('x is required.');\n        }\n        //>>includeEnd('debug');\n        return CesiumMath.zeroToTwoPi(x + CesiumMath.PI) - CesiumMath.PI;\n    };\n\n    /**\n     * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n     *\n     * @param {Number} angle in radians\n     * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n     */\n    CesiumMath.zeroToTwoPi = function(x) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(x)) {\n            throw new DeveloperError('x is required.');\n        }\n        //>>includeEnd('debug');\n        var mod = CesiumMath.mod(x, CesiumMath.TWO_PI);\n        if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(x) > CesiumMath.EPSILON14) {\n            return CesiumMath.TWO_PI;\n        }\n        return mod;\n    };\n\n    /**\n     * The modulo operation that also works for negative dividends.\n     *\n     * @param {Number} m The dividend.\n     * @param {Number} n The divisor.\n     * @returns {Number} The remainder.\n     */\n    CesiumMath.mod = function(m, n) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(m)) {\n            throw new DeveloperError('m is required.');\n        }\n        if (!defined(n)) {\n            throw new DeveloperError('n is required.');\n        }\n        //>>includeEnd('debug');\n        return ((m % n) + n) % n;\n    };\n\n    /**\n     * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n     * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n     * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n     * Use this test if you are unsure of the magnitudes of left and right.\n     *\n     * @param {Number} left The first value to compare.\n     * @param {Number} right The other value to compare.\n     * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n     * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n     *\n     * @example\n     * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n     * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n     * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n     * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n     */\n    CesiumMath.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        if (!defined(relativeEpsilon)) {\n            throw new DeveloperError('relativeEpsilon is required.');\n        }\n        //>>includeEnd('debug');\n        absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n        var absDiff = Math.abs(left - right);\n        return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));\n    };\n\n    var factorials = [1];\n\n    /**\n     * Computes the factorial of the provided number.\n     *\n     * @param {Number} n The number whose factorial is to be computed.\n     * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.\n     *\n     * @exception {DeveloperError} A number greater than or equal to 0 is required.\n     *\n     * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n     *\n     * @example\n     * //Compute 7!, which is equal to 5040\n     * var computedFactorial = Cesium.Math.factorial(7);\n     */\n    CesiumMath.factorial = function(n) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof n !== 'number' || n < 0) {\n            throw new DeveloperError('A number greater than or equal to 0 is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = factorials.length;\n        if (n >= length) {\n            var sum = factorials[length - 1];\n            for (var i = length; i <= n; i++) {\n                factorials.push(sum * i);\n            }\n        }\n        return factorials[n];\n    };\n\n    /**\n     * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n     *\n     * @param {Number} [n] The number to be incremented.\n     * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n     * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n     * @returns {Number} The incremented number.\n     *\n     * @exception {DeveloperError} Maximum value must be greater than minimum value.\n     *\n     * @example\n     * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n     * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n     */\n    CesiumMath.incrementWrap = function(n, maximumValue, minimumValue) {\n        minimumValue = defaultValue(minimumValue, 0.0);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(n)) {\n            throw new DeveloperError('n is required.');\n        }\n        if (maximumValue <= minimumValue) {\n            throw new DeveloperError('maximumValue must be greater than minimumValue.');\n        }\n        //>>includeEnd('debug');\n\n        ++n;\n        if (n > maximumValue) {\n            n = minimumValue;\n        }\n        return n;\n    };\n\n    /**\n     * Determines if a positive integer is a power of two.\n     *\n     * @param {Number} n The positive integer to test.\n     * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n     *\n     * @exception {DeveloperError} A number greater than or equal to 0 is required.\n     *\n     * @example\n     * var t = Cesium.Math.isPowerOfTwo(16); // true\n     * var f = Cesium.Math.isPowerOfTwo(20); // false\n     */\n    CesiumMath.isPowerOfTwo = function(n) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof n !== 'number' || n < 0) {\n            throw new DeveloperError('A number greater than or equal to 0 is required.');\n        }\n        //>>includeEnd('debug');\n\n        return (n !== 0) && ((n & (n - 1)) === 0);\n    };\n\n    /**\n     * Computes the next power-of-two integer greater than or equal to the provided positive integer.\n     *\n     * @param {Number} n The positive integer to test.\n     * @returns {Number} The next power-of-two integer.\n     *\n     * @exception {DeveloperError} A number greater than or equal to 0 is required.\n     *\n     * @example\n     * var n = Cesium.Math.nextPowerOfTwo(29); // 32\n     * var m = Cesium.Math.nextPowerOfTwo(32); // 32\n     */\n    CesiumMath.nextPowerOfTwo = function(n) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof n !== 'number' || n < 0) {\n            throw new DeveloperError('A number greater than or equal to 0 is required.');\n        }\n        //>>includeEnd('debug');\n\n        // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n        --n;\n        n |= n >> 1;\n        n |= n >> 2;\n        n |= n >> 4;\n        n |= n >> 8;\n        n |= n >> 16;\n        ++n;\n\n        return n;\n    };\n\n    /**\n     * Constraint a value to lie between two values.\n     *\n     * @param {Number} value The value to constrain.\n     * @param {Number} min The minimum value.\n     * @param {Number} max The maximum value.\n     * @returns {Number} The value clamped so that min <= value <= max.\n     */\n    CesiumMath.clamp = function(value, min, max) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        if (!defined(min)) {\n            throw new DeveloperError('min is required.');\n        }\n        if (!defined(max)) {\n            throw new DeveloperError('max is required.');\n        }\n        //>>includeEnd('debug');\n        return value < min ? min : value > max ? max : value;\n    };\n\n    var randomNumberGenerator = new MersenneTwister();\n\n    /**\n     * Sets the seed used by the random number generator\n     * in {@link CesiumMath#nextRandomNumber}.\n     *\n     * @param {Number} seed An integer used as the seed.\n     */\n    CesiumMath.setRandomNumberSeed = function(seed) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(seed)) {\n            throw new DeveloperError('seed is required.');\n        }\n        //>>includeEnd('debug');\n\n        randomNumberGenerator = new MersenneTwister(seed);\n    };\n\n    /**\n     * Generates a random number in the range of [0.0, 1.0)\n     * using a Mersenne twister.\n     *\n     * @returns {Number} A random number in the range of [0.0, 1.0).\n     *\n     * @see CesiumMath.setRandomNumberSeed\n     * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n     */\n    CesiumMath.nextRandomNumber = function() {\n        return randomNumberGenerator.random();\n    };\n\n    /**\n     * Computes <code>Math.acos(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n     * so that the function will never return NaN.\n     *\n     * @param {Number} value The value for which to compute acos.\n     * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n     *          whichever is closer, if the value is outside the range.\n     */\n    CesiumMath.acosClamped = function(value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required.');\n        }\n        //>>includeEnd('debug');\n        return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n    };\n\n    /**\n     * Computes <code>Math.asin(value)</acode>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n     * so that the function will never return NaN.\n     *\n     * @param {Number} value The value for which to compute asin.\n     * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n     *          whichever is closer, if the value is outside the range.\n     */\n    CesiumMath.asinClamped = function(value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required.');\n        }\n        //>>includeEnd('debug');\n        return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n    };\n\n    /**\n     * Finds the chord length between two points given the circle's radius and the angle between the points.\n     *\n     * @param {Number} angle The angle between the two points.\n     * @param {Number} radius The radius of the circle.\n     * @returns {Number} The chord length.\n     */\n    CesiumMath.chordLength = function(angle, radius) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        if (!defined(radius)) {\n            throw new DeveloperError('radius is required.');\n        }\n        //>>includeEnd('debug');\n        return 2.0 * radius * Math.sin(angle * 0.5);\n    };\n\n    return CesiumMath;\n});\n",
    "\n/*global define*/\ndefine('Core/Cartesian3',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A 3D Cartesian point.\n     * @alias Cartesian3\n     * @constructor\n     *\n     * @param {Number} [x=0.0] The X component.\n     * @param {Number} [y=0.0] The Y component.\n     * @param {Number} [z=0.0] The Z component.\n     *\n     * @see Cartesian2\n     * @see Cartesian4\n     * @see Packable\n     */\n    var Cartesian3 = function(x, y, z) {\n        /**\n         * The X component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.x = defaultValue(x, 0.0);\n\n        /**\n         * The Y component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.y = defaultValue(y, 0.0);\n\n        /**\n         * The Z component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.z = defaultValue(z, 0.0);\n    };\n\n    /**\n     * Converts the provided Spherical into Cartesian3 coordinates.\n     *\n     * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     */\n    Cartesian3.fromSpherical = function(spherical, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(spherical)) {\n            throw new DeveloperError('spherical is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var clock = spherical.clock;\n        var cone = spherical.cone;\n        var magnitude = defaultValue(spherical.magnitude, 1.0);\n        var radial = magnitude * Math.sin(cone);\n        result.x = radial * Math.cos(clock);\n        result.y = radial * Math.sin(clock);\n        result.z = magnitude * Math.cos(cone);\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian3 instance from x, y and z coordinates.\n     *\n     * @param {Number} x The x coordinate.\n     * @param {Number} y The y coordinate.\n     * @param {Number} z The z coordinate.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     */\n    Cartesian3.fromElements = function(x, y, z, result) {\n        if (!defined(result)) {\n            return new Cartesian3(x, y, z);\n        }\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Duplicates a Cartesian3 instance.\n     *\n     * @param {Cartesian3} cartesian The Cartesian to duplicate.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n     */\n    Cartesian3.clone = function(cartesian, result) {\n        if (!defined(cartesian)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n        }\n\n        result.x = cartesian.x;\n        result.y = cartesian.y;\n        result.z = cartesian.z;\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n     * x, y, and z properties of the Cartesian4 and drops w.\n     * @function\n     *\n     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     */\n    Cartesian3.fromCartesian4 = Cartesian3.clone;\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Cartesian3.packedLength = 3;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Cartesian3} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Cartesian3.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.x;\n        array[startingIndex++] = value.y;\n        array[startingIndex] = value.z;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Cartesian3} [result] The object into which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     */\n    Cartesian3.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n        result.x = array[startingIndex++];\n        result.y = array[startingIndex++];\n        result.z = array[startingIndex];\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian3 from three consecutive elements in an array.\n     * @function\n     *\n     * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     *\n     * @example\n     * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n     * var v = [1.0, 2.0, 3.0];\n     * var p = Cesium.Cartesian3.fromArray(v);\n     *\n     * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n     * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n     */\n    Cartesian3.fromArray = Cartesian3.unpack;\n\n    /**\n     * Computes the value of the maximum component for the supplied Cartesian.\n     *\n     * @param {Cartesian3} cartesian The cartesian to use.\n     * @returns {Number} The value of the maximum component.\n     */\n    Cartesian3.maximumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.max(cartesian.x, cartesian.y, cartesian.z);\n    };\n\n    /**\n     * Computes the value of the minimum component for the supplied Cartesian.\n     *\n     * @param {Cartesian3} cartesian The cartesian to use.\n     * @returns {Number} The value of the minimum component.\n     */\n    Cartesian3.minimumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.min(cartesian.x, cartesian.y, cartesian.z);\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n     *\n     * @param {Cartesian3} first A cartesian to compare.\n     * @param {Cartesian3} second A cartesian to compare.\n     * @param {Cartesian3} result The object into which to store the result.\n     * @returns {Cartesian3} A cartesian with the minimum components.\n     */\n    Cartesian3.minimumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.min(first.x, second.x);\n        result.y = Math.min(first.y, second.y);\n        result.z = Math.min(first.z, second.z);\n\n        return result;\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n     *\n     * @param {Cartesian3} first A cartesian to compare.\n     * @param {Cartesian3} second A cartesian to compare.\n     * @param {Cartesian3} result The object into which to store the result.\n     * @returns {Cartesian3} A cartesian with the maximum components.\n     */\n    Cartesian3.maximumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.max(first.x, second.x);\n        result.y = Math.max(first.y, second.y);\n        result.z = Math.max(first.z, second.z);\n        return result;\n    };\n\n    /**\n     * Computes the provided Cartesian's squared magnitude.\n     *\n     * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n     * @returns {Number} The squared magnitude.\n     */\n    Cartesian3.magnitudeSquared = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;\n    };\n\n    /**\n     * Computes the Cartesian's magnitude (length).\n     *\n     * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n     * @returns {Number} The magnitude.\n     */\n    Cartesian3.magnitude = function(cartesian) {\n        return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n    };\n\n    var distanceScratch = new Cartesian3();\n\n    /**\n     * Computes the distance between two points.\n     *\n     * @param {Cartesian3} left The first point to compute the distance from.\n     * @param {Cartesian3} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 1.0\n     * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n     */\n    Cartesian3.distance = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian3.subtract(left, right, distanceScratch);\n        return Cartesian3.magnitude(distanceScratch);\n    };\n\n    /**\n     * Computes the squared distance between two points.  Comparing squared distances\n     * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n     *\n     * @param {Cartesian3} left The first point to compute the distance from.\n     * @param {Cartesian3} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 4.0, not 2.0\n     * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n     */\n    Cartesian3.distanceSquared = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian3.subtract(left, right, distanceScratch);\n        return Cartesian3.magnitudeSquared(distanceScratch);\n    };\n\n    /**\n     * Computes the normalized form of the supplied Cartesian.\n     *\n     * @param {Cartesian3} cartesian The Cartesian to be normalized.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.normalize = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var magnitude = Cartesian3.magnitude(cartesian);\n\n        result.x = cartesian.x / magnitude;\n        result.y = cartesian.y / magnitude;\n        result.z = cartesian.z / magnitude;\n        return result;\n    };\n\n    /**\n     * Computes the dot (scalar) product of two Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @returns {Number} The dot product.\n     */\n    Cartesian3.dot = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        return left.x * right.x + left.y * right.y + left.z * right.z;\n    };\n\n    /**\n     * Computes the componentwise product of two Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.multiplyComponents = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x * right.x;\n        result.y = left.y * right.y;\n        result.z = left.z * right.z;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise sum of two Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x + right.x;\n        result.y = left.y + right.y;\n        result.z = left.z + right.z;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise difference of two Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x - right.x;\n        result.y = left.y - right.y;\n        result.z = left.z - right.z;\n        return result;\n    };\n\n    /**\n     * Multiplies the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian3} cartesian The Cartesian to be scaled.\n     * @param {Number} scalar The scalar to multiply with.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x * scalar;\n        result.y = cartesian.y * scalar;\n        result.z = cartesian.z * scalar;\n        return result;\n    };\n\n    /**\n     * Divides the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian3} cartesian The Cartesian to be divided.\n     * @param {Number} scalar The scalar to divide by.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.divideByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x / scalar;\n        result.y = cartesian.y / scalar;\n        result.z = cartesian.z / scalar;\n        return result;\n    };\n\n    /**\n     * Negates the provided Cartesian.\n     *\n     * @param {Cartesian3} cartesian The Cartesian to be negated.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.negate = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = -cartesian.x;\n        result.y = -cartesian.y;\n        result.z = -cartesian.z;\n        return result;\n    };\n\n    /**\n     * Computes the absolute value of the provided Cartesian.\n     *\n     * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.abs = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.abs(cartesian.x);\n        result.y = Math.abs(cartesian.y);\n        result.z = Math.abs(cartesian.z);\n        return result;\n    };\n\n    var lerpScratch = new Cartesian3();\n    /**\n     * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n     *\n     * @param {Cartesian3} start The value corresponding to t at 0.0.\n     * @param {Cartesian3} end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Cartesian3.lerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian3.multiplyByScalar(end, t, lerpScratch);\n        result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n        return Cartesian3.add(lerpScratch, result, result);\n    };\n\n    var angleBetweenScratch = new Cartesian3();\n    var angleBetweenScratch2 = new Cartesian3();\n    /**\n     * Returns the angle, in radians, between the provided Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @returns {Number} The angle between the Cartesians.\n     */\n    Cartesian3.angleBetween = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian3.normalize(left, angleBetweenScratch);\n        Cartesian3.normalize(right, angleBetweenScratch2);\n        var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n        var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));\n        return Math.atan2(sine, cosine);\n    };\n\n    var mostOrthogonalAxisScratch = new Cartesian3();\n    /**\n     * Returns the axis that is most orthogonal to the provided Cartesian.\n     *\n     * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The most orthogonal axis.\n     */\n    Cartesian3.mostOrthogonalAxis = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n        Cartesian3.abs(f, f);\n\n        if (f.x <= f.y) {\n            if (f.x <= f.z) {\n                result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n            } else {\n                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n            }\n        } else {\n            if (f.y <= f.z) {\n                result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n            } else {\n                result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian3} [left] The first Cartesian.\n     * @param {Cartesian3} [right] The second Cartesian.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Cartesian3.equals = function(left, right) {\n            return (left === right) ||\n              ((defined(left)) &&\n               (defined(right)) &&\n               (left.x === right.x) &&\n               (left.y === right.y) &&\n               (left.z === right.z));\n    };\n\n    /**\n     * @private\n     */\n    Cartesian3.equalsArray = function(cartesian, array, offset) {\n        return cartesian.x === array[offset] &&\n               cartesian.y === array[offset + 1] &&\n               cartesian.z === array[offset + 2];\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian3} [left] The first Cartesian.\n     * @param {Cartesian3} [right] The second Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian3.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon));\n    };\n\n    /**\n     * Computes the cross (outer) product of two Cartesians.\n     *\n     * @param {Cartesian3} left The first Cartesian.\n     * @param {Cartesian3} right The second Cartesian.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The cross product.\n     */\n    Cartesian3.cross = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var leftX = left.x;\n        var leftY = left.y;\n        var leftZ = left.z;\n        var rightX = right.x;\n        var rightY = right.y;\n        var rightZ = right.z;\n\n        var x = leftY * rightZ - leftZ * rightY;\n        var y = leftZ * rightX - leftX * rightZ;\n        var z = leftX * rightY - leftY * rightX;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n     *\n     * @param {Number} longitude The longitude, in degrees\n     * @param {Number} latitude The latitude, in degrees\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The position\n     *\n     * @example\n     * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n     */\n    Cartesian3.fromDegrees = function(longitude, latitude, height, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(longitude)) {\n            throw new DeveloperError('longitude is required');\n        }\n        if (!defined(latitude)) {\n            throw new DeveloperError('latitude is required');\n        }\n        //>>includeEnd('debug');\n\n        var lon = CesiumMath.toRadians(longitude);\n        var lat = CesiumMath.toRadians(latitude);\n        return Cartesian3.fromRadians(lon, lat, height, ellipsoid, result);\n    };\n\n    var scratchN = new Cartesian3();\n    var scratchK = new Cartesian3();\n    var wgs84RadiiSquared = new Cartesian3(6378137.0 * 6378137.0, 6378137.0 * 6378137.0, 6356752.3142451793 * 6356752.3142451793);\n\n    /**\n     * Returns a Cartesian3 position from longitude and latitude values given in radians.\n     *\n     * @param {Number} longitude The longitude, in radians\n     * @param {Number} latitude The latitude, in radians\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The position\n     *\n     * @example\n     * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n     */\n    Cartesian3.fromRadians = function(longitude, latitude, height, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(longitude)) {\n            throw new DeveloperError('longitude is required');\n        }\n        if (!defined(latitude)) {\n            throw new DeveloperError('latitude is required');\n        }\n        //>>includeEnd('debug');\n\n        height = defaultValue(height, 0.0);\n        var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;\n\n        var cosLatitude = Math.cos(latitude);\n        scratchN.x = cosLatitude * Math.cos(longitude);\n        scratchN.y = cosLatitude * Math.sin(longitude);\n        scratchN.z = Math.sin(latitude);\n        scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n        Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n        var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n        scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n        scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n        return Cartesian3.add(scratchK, scratchN, result);\n    };\n\n    /**\n     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n     *\n     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n     * @returns {Cartesian3[]} The array of positions.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n     */\n    Cartesian3.fromDegreesArray = function(coordinates, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(coordinates)) {\n            throw new DeveloperError('positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var pos = new Array(coordinates.length);\n        for (var i = 0; i < coordinates.length; i++) {\n            pos[i] = CesiumMath.toRadians(coordinates[i]);\n        }\n\n        return Cartesian3.fromRadiansArray(pos, ellipsoid, result);\n    };\n\n    /**\n     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n     *\n     * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n     * @returns {Cartesian3[]} The array of positions.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n     */\n    Cartesian3.fromRadiansArray = function(coordinates, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(coordinates)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (coordinates.length < 2) {\n            throw new DeveloperError('positions length cannot be less than 2.');\n        }\n        if (coordinates.length % 2 !== 0) {\n            throw new DeveloperError('positions length must be a multiple of 2.');\n        }\n        //>>includeEnd('debug');\n\n        var length = coordinates.length;\n        if (!defined(result)) {\n            result = new Array(length/2);\n        } else {\n            result.length = length/2;\n        }\n\n        for ( var i = 0; i < length; i+=2) {\n            var lon = coordinates[i];\n            var lat = coordinates[i+1];\n            result[i/2] = Cartesian3.fromRadians(lon, lat, 0, ellipsoid, result[i/2]);\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n     *\n     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n     * @returns {Cartesian3[]} The array of positions.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n     */\n    Cartesian3.fromDegreesArrayHeights = function(coordinates, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(coordinates)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (coordinates.length < 3) {\n            throw new DeveloperError('positions length cannot be less than 3.');\n        }\n        if (coordinates.length % 3 !== 0) {\n            throw new DeveloperError('positions length must be a multiple of 3.');\n        }\n        //>>includeEnd('debug');\n\n        var pos = new Array(coordinates.length);\n        for (var i = 0; i < coordinates.length; i+=3) {\n            pos[i] = CesiumMath.toRadians(coordinates[i]);\n            pos[i+1] = CesiumMath.toRadians(coordinates[i+1]);\n            pos[i+2] = coordinates[i+2];\n        }\n\n        return Cartesian3.fromRadiansArrayHeights(pos, ellipsoid, result);\n    };\n\n    /**\n     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n     *\n     * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height,, longitude, latitude, height...].\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n     * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n     * @returns {Cartesian3[]} The array of positions.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n     */\n    Cartesian3.fromRadiansArrayHeights = function(coordinates, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(coordinates)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (coordinates.length < 3) {\n            throw new DeveloperError('positions length cannot be less than 3.');\n        }\n        if (coordinates.length % 3 !== 0) {\n            throw new DeveloperError('positions length must be a multiple of 3.');\n        }\n        //>>includeEnd('debug');\n\n        var length = coordinates.length;\n        if (!defined(result)) {\n            result = new Array(length/3);\n        } else {\n            result.length = length/3;\n        }\n\n        for ( var i = 0; i < length; i+=3) {\n            var lon = coordinates[i];\n            var lat = coordinates[i+1];\n            var alt = coordinates[i+2];\n            result[i/3] = Cartesian3.fromRadians(lon, lat, alt, ellipsoid, result[i/3]);\n        }\n\n        return result;\n    };\n\n    /**\n     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n     *\n     * @type {Cartesian3}\n     * @constant\n     */\n    Cartesian3.ZERO = freezeObject(new Cartesian3(0.0, 0.0, 0.0));\n\n    /**\n     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n     *\n     * @type {Cartesian3}\n     * @constant\n     */\n    Cartesian3.UNIT_X = freezeObject(new Cartesian3(1.0, 0.0, 0.0));\n\n    /**\n     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n     *\n     * @type {Cartesian3}\n     * @constant\n     */\n    Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0.0, 1.0, 0.0));\n\n    /**\n     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n     *\n     * @type {Cartesian3}\n     * @constant\n     */\n    Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0.0, 0.0, 1.0));\n\n    /**\n     * Duplicates this Cartesian3 instance.\n     *\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     */\n    Cartesian3.prototype.clone = function(result) {\n        return Cartesian3.clone(this, result);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian3} [right] The right hand side Cartesian.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Cartesian3.prototype.equals = function(right) {\n        return Cartesian3.equals(this, right);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian3} [right] The right hand side Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian3.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\n        return Cartesian3.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n    };\n\n    /**\n     * Creates a string representing this Cartesian in the format '(x, y, z)'.\n     *\n     * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.\n     */\n    Cartesian3.prototype.toString = function() {\n        return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';\n    };\n\n    return Cartesian3;\n});\n",
    "\n/*global define*/\ndefine('Core/Cartographic',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A position defined by longitude, latitude, and height.\n     * @alias Cartographic\n     * @constructor\n     *\n     * @param {Number} [longitude=0.0] The longitude, in radians.\n     * @param {Number} [latitude=0.0] The latitude, in radians.\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n     *\n     * @see Ellipsoid\n     */\n    var Cartographic = function(longitude, latitude, height) {\n        /**\n         * The longitude, in radians.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.longitude = defaultValue(longitude, 0.0);\n\n        /**\n         * The latitude, in radians.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.latitude = defaultValue(latitude, 0.0);\n\n        /**\n         * The height, in meters, above the ellipsoid.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.height = defaultValue(height, 0.0);\n    };\n\n    /**\n     * Creates a new Cartographic instance from longitude and latitude\n     * specified in radians.\n     *\n     * @param {Number} longitude The longitude, in radians.\n     * @param {Number} latitude The latitude, in radians.\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n     */\n    Cartographic.fromRadians = function(longitude, latitude, height, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(longitude)) {\n            throw new DeveloperError('longitude is required.');\n        }\n        if (!defined(latitude)) {\n            throw new DeveloperError('latitude is required.');\n        }\n        //>>includeEnd('debug');\n\n        height = defaultValue(height, 0.0);\n\n        if (!defined(result)) {\n            return new Cartographic(longitude, latitude, height);\n        }\n\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = height;\n        return result;\n    };\n\n    /**\n     * Creates a new Cartographic instance from longitude and latitude\n     * specified in degrees.  The values in the resulting object will\n     * be in radians.\n     *\n     * @param {Number} longitude The longitude, in degrees.\n     * @param {Number} latitude The latitude, in degrees.\n     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n     */\n    Cartographic.fromDegrees = function(longitude, latitude, height, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(longitude)) {\n            throw new DeveloperError('longitude is required.');\n        }\n        if (!defined(latitude)) {\n            throw new DeveloperError('latitude is required.');\n        }\n        //>>includeEnd('debug');\n        longitude = CesiumMath.toRadians(longitude);\n        latitude = CesiumMath.toRadians(latitude);\n\n        return Cartographic.fromRadians(longitude, latitude, height, result);\n    };\n\n    /**\n     * Duplicates a Cartographic instance.\n     *\n     * @param {Cartographic} cartographic The cartographic to duplicate.\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n     */\n    Cartographic.clone = function(cartographic, result) {\n        if (!defined(cartographic)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);\n        }\n        result.longitude = cartographic.longitude;\n        result.latitude = cartographic.latitude;\n        result.height = cartographic.height;\n        return result;\n    };\n\n    /**\n     * Compares the provided cartographics componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartographic} [left] The first cartographic.\n     * @param {Cartographic} [right] The second cartographic.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Cartographic.equals = function(left, right) {\n        return (left === right) ||\n                ((defined(left)) &&\n                 (defined(right)) &&\n                 (left.longitude === right.longitude) &&\n                 (left.latitude === right.latitude) &&\n                 (left.height === right.height));\n    };\n\n    /**\n     * Compares the provided cartographics componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartographic} [left] The first cartographic.\n     * @param {Cartographic} [right] The second cartographic.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartographic.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon is required and must be a number.');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (Math.abs(left.longitude - right.longitude) <= epsilon) &&\n                (Math.abs(left.latitude - right.latitude) <= epsilon) &&\n                (Math.abs(left.height - right.height) <= epsilon));\n    };\n\n    /**\n     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n     *\n     * @type {Cartographic}\n     * @constant\n     */\n    Cartographic.ZERO = freezeObject(new Cartographic(0.0, 0.0, 0.0));\n\n    /**\n     * Duplicates this instance.\n     *\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n     */\n    Cartographic.prototype.clone = function(result) {\n        return Cartographic.clone(this, result);\n    };\n\n    /**\n     * Compares the provided against this cartographic componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartographic} [right] The second cartographic.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Cartographic.prototype.equals = function(right) {\n        return Cartographic.equals(this, right);\n    };\n\n    /**\n     * Compares the provided against this cartographic componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartographic} [right] The second cartographic.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {\n        return Cartographic.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.\n     *\n     * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.\n     */\n    Cartographic.prototype.toString = function() {\n        return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';\n    };\n\n    return Cartographic;\n});\n",
    "\n/*global define*/\ndefine('Core/defineProperties',[\n        './defined'\n    ], function(\n        defined) {\n    \"use strict\";\n\n    var definePropertyWorks = (function() {\n        try {\n            return 'x' in Object.defineProperty({}, 'x', {});\n        } catch (e) {\n            return false;\n        }\n    })();\n\n    /**\n     * Defines properties on an object, using Object.defineProperties if available,\n     * otherwise returns the object unchanged.  This function should be used in\n     * setup code to prevent errors from completely halting JavaScript execution\n     * in legacy browsers.\n     *\n     * @private\n     *\n     * @exports defineProperties\n     */\n    var defineProperties = Object.defineProperties;\n    if (!definePropertyWorks || !defined(defineProperties)) {\n        defineProperties = function(o) {\n            return o;\n        };\n    }\n\n    return defineProperties;\n});",
    "\n/*global define*/\ndefine('Core/Ellipsoid',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    function initialize(ellipsoid, x, y, z) {\n        x = defaultValue(x, 0.0);\n        y = defaultValue(y, 0.0);\n        z = defaultValue(z, 0.0);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (x < 0.0 || y < 0.0 || z < 0.0) {\n            throw new DeveloperError('All radii components must be greater than or equal to zero.');\n        }\n        //>>includeEnd('debug');\n\n        ellipsoid._radii = new Cartesian3(x, y, z);\n\n        ellipsoid._radiiSquared = new Cartesian3(x * x,\n                                            y * y,\n                                            z * z);\n\n        ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x,\n                                                y * y * y * y,\n                                                z * z * z * z);\n\n        ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x,\n                                            y === 0.0 ? 0.0 : 1.0 / y,\n                                            z === 0.0 ? 0.0 : 1.0 / z);\n\n        ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x),\n                                                   y === 0.0 ? 0.0 : 1.0 / (y * y),\n                                                   z === 0.0 ? 0.0 : 1.0 / (z * z));\n\n        ellipsoid._minimumRadius = Math.min(x, y, z);\n\n        ellipsoid._maximumRadius = Math.max(x, y, z);\n\n        ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n    }\n\n    /**\n     * A quadratic surface defined in Cartesian coordinates by the equation\n     * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n     * by Cesium to represent the shape of planetary bodies.\n     *\n     * Rather than constructing this object directly, one of the provided\n     * constants is normally used.\n     * @alias Ellipsoid\n     * @constructor\n     *\n     * @param {Number} [x=0] The radius in the x direction.\n     * @param {Number} [y=0] The radius in the y direction.\n     * @param {Number} [z=0] The radius in the z direction.\n     *\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n     *\n     * @see Ellipsoid.fromCartesian3\n     * @see Ellipsoid.WGS84\n     * @see Ellipsoid.UNIT_SPHERE\n     */\n    var Ellipsoid = function(x, y, z) {\n        this._radii = undefined;\n        this._radiiSquared = undefined;\n        this._radiiToTheFourth = undefined;\n        this._oneOverRadii = undefined;\n        this._oneOverRadiiSquared = undefined;\n        this._minimumRadius = undefined;\n        this._maximumRadius = undefined;\n        this._centerToleranceSquared = undefined;\n\n        initialize(this, x, y, z);\n    };\n\n    defineProperties(Ellipsoid.prototype, {\n        /**\n         * Gets the radii of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Cartesian3}\n         * @readonly\n         */\n        radii : {\n            get: function() {\n                return this._radii;\n            }\n        },\n        /**\n         * Gets the squared radii of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Cartesian3}\n         * @readonly\n         */\n        radiiSquared : {\n            get : function() {\n                return this._radiiSquared;\n            }\n        },\n        /**\n         * Gets the radii of the ellipsoid raise to the fourth power.\n         * @memberof Ellipsoid.prototype\n         * @type {Cartesian3}\n         * @readonly\n         */\n        radiiToTheFourth : {\n            get : function() {\n                return this._radiiToTheFourth;\n            }\n        },\n        /**\n         * Gets one over the radii of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Cartesian3}\n         * @readonly\n         */\n        oneOverRadii : {\n            get : function() {\n                return this._oneOverRadii;\n            }\n        },\n        /**\n         * Gets one over the squared radii of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Cartesian3}\n         * @readonly\n         */\n        oneOverRadiiSquared : {\n            get : function() {\n                return this._oneOverRadiiSquared;\n            }\n        },\n        /**\n         * Gets the minimum radius of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Number}\n         * @readonly\n         */\n        minimumRadius : {\n            get : function() {\n                return this._minimumRadius;\n            }\n        },\n        /**\n         * Gets the maximum radius of the ellipsoid.\n         * @memberof Ellipsoid.prototype\n         * @type {Number}\n         * @readonly\n         */\n        maximumRadius : {\n            get : function() {\n                return this._maximumRadius;\n            }\n        }\n    });\n\n    /**\n     * Duplicates an Ellipsoid instance.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n     *                    instance should be created.\n     * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n     */\n    Ellipsoid.clone = function(ellipsoid, result) {\n        if (!defined(ellipsoid)) {\n            return undefined;\n        }\n        var radii = ellipsoid._radii;\n\n        if (!defined(result)) {\n            return new Ellipsoid(radii.x, radii.y, radii.z);\n        }\n\n        Cartesian3.clone(radii, result._radii);\n        Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n        Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n        Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n        Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n        result._minimumRadius = ellipsoid._minimumRadius;\n        result._maximumRadius = ellipsoid._maximumRadius;\n        result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n        return result;\n    };\n\n    /**\n     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n     *\n     * @param {Cartesian3} [radii=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n     * @returns {Ellipsoid} A new Ellipsoid instance.\n     *\n     * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n     *\n     * @see Ellipsoid.WGS84\n     * @see Ellipsoid.UNIT_SPHERE\n     */\n    Ellipsoid.fromCartesian3 = function(cartesian, result) {\n        if (!defined(result)) {\n            result = new Ellipsoid();\n        }\n\n        if (!defined(cartesian)) {\n            return result;\n        }\n\n        initialize(result, cartesian.x, cartesian.y, cartesian.z);\n        return result;\n    };\n\n    /**\n     * An Ellipsoid instance initialized to the WGS84 standard.\n     *\n     * @type {Ellipsoid}\n     * @constant\n     */\n    Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\n\n    /**\n     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n     *\n     * @type {Ellipsoid}\n     * @constant\n     */\n    Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1.0, 1.0, 1.0));\n\n    /**\n     * An Ellipsoid instance initialized to a sphere with the lunar radius.\n     *\n     * @type {Ellipsoid}\n     * @constant\n     */\n    Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\n\n    /**\n     * Duplicates an Ellipsoid instance.\n     *\n     * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n     *                    instance should be created.\n     * @returns {Ellipsoid} The cloned Ellipsoid.\n     */\n    Ellipsoid.prototype.clone = function(result) {\n        return Ellipsoid.clone(this, result);\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Ellipsoid.packedLength = Cartesian3.packedLength;\n\n    /**\n     * Stores the provided instance into the provided array.\n     * @function\n     *\n     * @param {Ellipsoid} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Ellipsoid.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._radii, array, startingIndex);\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Ellipsoid} [result] The object into which to store the result.\n     * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n     */\n    Ellipsoid.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var radii = Cartesian3.unpack(array, startingIndex);\n        return Ellipsoid.fromCartesian3(radii, result);\n    };\n\n    /**\n     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n     * @function\n     *\n     * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     */\n    Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n    /**\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n     *\n     * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     */\n    Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function(cartographic, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartographic)) {\n            throw new DeveloperError('cartographic is required.');\n        }\n        //>>includeEnd('debug');\n\n        var longitude = cartographic.longitude;\n        var latitude = cartographic.latitude;\n        var cosLatitude = Math.cos(latitude);\n\n        var x = cosLatitude * Math.cos(longitude);\n        var y = cosLatitude * Math.sin(longitude);\n        var z = Math.sin(latitude);\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return Cartesian3.normalize(result, result);\n    };\n\n    /**\n     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     */\n    Ellipsoid.prototype.geodeticSurfaceNormal = function(cartesian, result) {\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n        result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\n        return Cartesian3.normalize(result, result);\n    };\n\n    var cartographicToCartesianNormal = new Cartesian3();\n    var cartographicToCartesianK = new Cartesian3();\n\n    /**\n     * Converts the provided cartographic to Cartesian representation.\n     *\n     * @param {Cartographic} cartographic The cartographic position.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     *\n     * @example\n     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n     * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n     * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n     */\n    Ellipsoid.prototype.cartographicToCartesian = function(cartographic, result) {\n        //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n        var n = cartographicToCartesianNormal;\n        var k = cartographicToCartesianK;\n        this.geodeticSurfaceNormalCartographic(cartographic, n);\n        Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n        var gamma = Math.sqrt(Cartesian3.dot(n, k));\n        Cartesian3.divideByScalar(k, gamma, k);\n        Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n        return Cartesian3.add(k, n, result);\n    };\n\n    /**\n     * Converts the provided array of cartographics to an array of Cartesians.\n     *\n     * @param {Cartographic[]} cartographics An array of cartographic positions.\n     * @param {Cartesian3[]} [result] The object onto which to store the result.\n     * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n     *\n     * @example\n     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n     * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n     * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n     */\n    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(cartographics, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartographics)) {\n            throw new DeveloperError('cartographics is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = cartographics.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        } else {\n            result.length = length;\n        }\n        for ( var i = 0; i < length; i++) {\n            result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n        }\n        return result;\n    };\n\n    var cartesianToCartographicN = new Cartesian3();\n    var cartesianToCartographicP = new Cartesian3();\n    var cartesianToCartographicH = new Cartesian3();\n\n    /**\n     * Converts the provided cartesian to cartographic representation.\n     * The cartesian is undefined at the center of the ellipsoid.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n     *\n     * @example\n     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n     * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n     * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n     */\n    Ellipsoid.prototype.cartesianToCartographic = function(cartesian, result) {\n        //`cartesian is required.` is thrown from scaleToGeodeticSurface\n        var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n        if (!defined(p)) {\n            return undefined;\n        }\n\n        var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n        var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n        var longitude = Math.atan2(n.y, n.x);\n        var latitude = Math.asin(n.z);\n        var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n        if (!defined(result)) {\n            return new Cartographic(longitude, latitude, height);\n        }\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = height;\n        return result;\n    };\n\n    /**\n     * Converts the provided array of cartesians to an array of cartographics.\n     *\n     * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n     * @param {Cartographic[]} [result] The object onto which to store the result.\n     * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n     *\n     * @example\n     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n     * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n     * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n     */\n    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesians)) {\n            throw new DeveloperError('cartesians is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = cartesians.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        } else {\n            result.length = length;\n        }\n        for ( var i = 0; i < length; ++i) {\n            result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n        }\n        return result;\n    };\n\n    var scaleToGeodeticSurfaceIntersection = new Cartesian3();\n    var scaleToGeodeticSurfaceGradient = new Cartesian3();\n\n    /**\n     * Scales the provided Cartesian position along the geodetic surface normal\n     * so that it is on the surface of this ellipsoid.  If the position is\n     * at the center of the ellipsoid, this function returns undefined.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n     */\n    Ellipsoid.prototype.scaleToGeodeticSurface = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        //>>includeEnd('debug');\n\n        var positionX = cartesian.x;\n        var positionY = cartesian.y;\n        var positionZ = cartesian.z;\n\n        var oneOverRadii = this._oneOverRadii;\n        var oneOverRadiiX = oneOverRadii.x;\n        var oneOverRadiiY = oneOverRadii.y;\n        var oneOverRadiiZ = oneOverRadii.z;\n\n        var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n        var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n        var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n        // Compute the squared ellipsoid norm.\n        var squaredNorm = x2 + y2 + z2;\n        var ratio = Math.sqrt(1.0 / squaredNorm);\n\n        // As an initial approximation, assume that the radial intersection is the projection point.\n        var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);\n\n        //* If the position is near the center, the iteration will not converge.\n        if (squaredNorm < this._centerToleranceSquared) {\n            return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);\n        }\n\n        var oneOverRadiiSquared = this._oneOverRadiiSquared;\n        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n        // Use the gradient at the intersection point in place of the true unit normal.\n        // The difference in magnitude will be absorbed in the multiplier.\n        var gradient = scaleToGeodeticSurfaceGradient;\n        gradient.x = intersection.x * oneOverRadiiSquaredX * 2.0;\n        gradient.y = intersection.y * oneOverRadiiSquaredY * 2.0;\n        gradient.z = intersection.z * oneOverRadiiSquaredZ * 2.0;\n\n        // Compute the initial guess at the normal vector multiplier, lambda.\n        var lambda = (1.0 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));\n        var correction = 0.0;\n\n        var func;\n        var denominator;\n        var xMultiplier;\n        var yMultiplier;\n        var zMultiplier;\n        var xMultiplier2;\n        var yMultiplier2;\n        var zMultiplier2;\n        var xMultiplier3;\n        var yMultiplier3;\n        var zMultiplier3;\n\n        do {\n            lambda -= correction;\n\n            xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n            yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n            zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n            xMultiplier2 = xMultiplier * xMultiplier;\n            yMultiplier2 = yMultiplier * yMultiplier;\n            zMultiplier2 = zMultiplier * zMultiplier;\n\n            xMultiplier3 = xMultiplier2 * xMultiplier;\n            yMultiplier3 = yMultiplier2 * yMultiplier;\n            zMultiplier3 = zMultiplier2 * zMultiplier;\n\n            func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n            // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n            // computations in the sections to follow.\n            denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n            var derivative = -2.0 * denominator;\n\n            correction = func / derivative;\n        } while (Math.abs(func) > CesiumMath.EPSILON12);\n\n        if (!defined(result)) {\n            return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\n        }\n        result.x = positionX * xMultiplier;\n        result.y = positionY * yMultiplier;\n        result.z = positionZ * zMultiplier;\n        return result;\n    };\n\n    /**\n     * Scales the provided Cartesian position along the geocentric surface normal\n     * so that it is on the surface of this ellipsoid.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position to scale.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n     */\n    Ellipsoid.prototype.scaleToGeocentricSurface = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var positionX = cartesian.x;\n        var positionY = cartesian.y;\n        var positionZ = cartesian.z;\n        var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n        var beta = 1.0 / Math.sqrt((positionX * positionX) * oneOverRadiiSquared.x +\n                                   (positionY * positionY) * oneOverRadiiSquared.y +\n                                   (positionZ * positionZ) * oneOverRadiiSquared.z);\n\n        return Cartesian3.multiplyByScalar(cartesian, beta, result);\n    };\n\n    /**\n     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n     * its components by the result of {@link Ellipsoid#oneOverRadii}.\n     *\n     * @param {Cartesian3} position The position to transform.\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n     *        return a new instance.\n     * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n     */\n    Ellipsoid.prototype.transformPositionToScaledSpace = function(position, result) {\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n    };\n\n    /**\n     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n     * its components by the result of {@link Ellipsoid#radii}.\n     *\n     * @param {Cartesian3} position The position to transform.\n     * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n     *        return a new instance.\n     * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n     *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n     */\n    Ellipsoid.prototype.transformPositionFromScaledSpace = function(position, result) {\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        return Cartesian3.multiplyComponents(position, this._radii, result);\n    };\n\n    /**\n     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Ellipsoid} [right] The other Ellipsoid.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Ellipsoid.prototype.equals = function(right) {\n        return (this === right) ||\n               (defined(right) &&\n                Cartesian3.equals(this._radii, right._radii));\n    };\n\n    /**\n     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n     *\n     * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n     */\n    Ellipsoid.prototype.toString = function() {\n        return this._radii.toString();\n    };\n\n    return Ellipsoid;\n});\n",
    "\n/*global define*/\ndefine('Core/Rectangle',[\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './Ellipsoid',\n        './freezeObject',\n        './Math'\n    ], function(\n        Cartographic,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A two dimensional region specified as longitude and latitude coordinates.\n     *\n     * @alias Rectangle\n     * @constructor\n     *\n     * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].\n     * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n     * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].\n     * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].\n     *\n     * @see Packable\n     */\n    var Rectangle = function(west, south, east, north) {\n        /**\n         * The westernmost longitude in radians in the range [-Pi, Pi].\n         *\n         * @type {Number}\n         * @default 0.0\n         */\n        this.west = defaultValue(west, 0.0);\n\n        /**\n         * The southernmost latitude in radians in the range [-Pi/2, Pi/2].\n         *\n         * @type {Number}\n         * @default 0.0\n         */\n        this.south = defaultValue(south, 0.0);\n\n        /**\n         * The easternmost longitude in radians in the range [-Pi, Pi].\n         *\n         * @type {Number}\n         * @default 0.0\n         */\n        this.east = defaultValue(east, 0.0);\n\n        /**\n         * The northernmost latitude in radians in the range [-Pi/2, Pi/2].\n         *\n         * @type {Number}\n         * @default 0.0\n         */\n        this.north = defaultValue(north, 0.0);\n    };\n\n    defineProperties(Rectangle.prototype, {\n        /**\n         * Gets the width of the rectangle in radians.\n         * @memberof Rectangle.prototype\n         * @type {Number}\n         */\n        width : {\n            get : function() {\n                return Rectangle.computeWidth(this);\n            }\n        },\n\n        /**\n         * Gets the height of the rectangle in radians.\n         * @memberof Rectangle.prototype\n         * @type {Number}\n         */\n        height : {\n            get : function() {\n                return Rectangle.computeHeight(this);\n            }\n        }\n    });\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Rectangle.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Rectangle} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Rectangle.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.west;\n        array[startingIndex++] = value.south;\n        array[startingIndex++] = value.east;\n        array[startingIndex] = value.north;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Rectangle} [result] The object into which to store the result.\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.\n     */\n    Rectangle.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Rectangle();\n        }\n\n        result.west = array[startingIndex++];\n        result.south = array[startingIndex++];\n        result.east = array[startingIndex++];\n        result.north = array[startingIndex];\n        return result;\n    };\n\n    /**\n     * Computes the width of a rectangle in radians.\n     * @param {Rectangle} rectangle The rectangle to compute the width of.\n     * @returns {Number} The width.\n     */\n    Rectangle.computeWidth = function(rectangle) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required.');\n        }\n        //>>includeEnd('debug');\n        var east = rectangle.east;\n        var west = rectangle.west;\n        if (east < west) {\n            east += CesiumMath.TWO_PI;\n        }\n        return east - west;\n    };\n\n    /**\n     * Computes the height of a rectangle in radians.\n     * @param {Rectangle} rectangle The rectangle to compute the height of.\n     * @returns {Number} The height.\n     */\n    Rectangle.computeHeight = function(rectangle) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required.');\n        }\n        //>>includeEnd('debug');\n        return rectangle.north - rectangle.south;\n    };\n\n    /**\n     * Creates an rectangle given the boundary longitude and latitude in degrees.\n     *\n     * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].\n     * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].\n     * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].\n     * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n     *\n     * @example\n     * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);\n     */\n    Rectangle.fromDegrees = function(west, south, east, north, result) {\n        west = CesiumMath.toRadians(defaultValue(west, 0.0));\n        south = CesiumMath.toRadians(defaultValue(south, 0.0));\n        east = CesiumMath.toRadians(defaultValue(east, 0.0));\n        north = CesiumMath.toRadians(defaultValue(north, 0.0));\n\n        if (!defined(result)) {\n            return new Rectangle(west, south, east, north);\n        }\n\n        result.west = west;\n        result.south = south;\n        result.east = east;\n        result.north = north;\n\n        return result;\n    };\n\n    /**\n     * Creates the smallest possible Rectangle that encloses all positions in the provided array.\n     *\n     * @param {Cartographic[]} cartographics The list of Cartographic instances.\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n     */\n    Rectangle.fromCartographicArray = function(cartographics, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartographics)) {\n            throw new DeveloperError('cartographics is required.');\n        }\n        //>>includeEnd('debug');\n\n        var minLon = Number.MAX_VALUE;\n        var maxLon = -Number.MAX_VALUE;\n        var minLat = Number.MAX_VALUE;\n        var maxLat = -Number.MAX_VALUE;\n\n        for ( var i = 0, len = cartographics.length; i < len; i++) {\n            var position = cartographics[i];\n            minLon = Math.min(minLon, position.longitude);\n            maxLon = Math.max(maxLon, position.longitude);\n            minLat = Math.min(minLat, position.latitude);\n            maxLat = Math.max(maxLat, position.latitude);\n        }\n\n        if (!defined(result)) {\n            return new Rectangle(minLon, minLat, maxLon, maxLat);\n        }\n\n        result.west = minLon;\n        result.south = minLat;\n        result.east = maxLon;\n        result.north = maxLat;\n        return result;\n    };\n\n    /**\n     * Duplicates an Rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle to clone.\n     * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)\n     */\n    Rectangle.clone = function(rectangle, result) {\n        if (!defined(rectangle)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);\n        }\n\n        result.west = rectangle.west;\n        result.south = rectangle.south;\n        result.east = rectangle.east;\n        result.north = rectangle.north;\n        return result;\n    };\n\n    /**\n     * Duplicates this Rectangle.\n     *\n     * @param {Rectangle} [result] The object onto which to store the result.\n     * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.\n     */\n    Rectangle.prototype.clone = function(result) {\n        return Rectangle.clone(this, result);\n    };\n\n    /**\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Rectangle} [other] The Rectangle to compare.\n     * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.\n     */\n    Rectangle.prototype.equals = function(other) {\n        return Rectangle.equals(this, other);\n    };\n\n    /**\n     * Compares the provided rectangles and returns <code>true</code> if they are equal,\n     * <code>false</code> otherwise.\n     *\n     * @param {Rectangle} [left] The first Rectangle.\n     * @param {Rectangle} [right] The second Rectangle.\n     * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n     */\n    Rectangle.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (left.west === right.west) &&\n                (left.south === right.south) &&\n                (left.east === right.east) &&\n                (left.north === right.north));\n    };\n\n    /**\n     * Compares the provided Rectangle with this Rectangle componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Rectangle} [other] The Rectangle to compare.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon is required and must be a number.');\n        }\n        //>>includeEnd('debug');\n\n        return defined(other) &&\n               (Math.abs(this.west - other.west) <= epsilon) &&\n               (Math.abs(this.south - other.south) <= epsilon) &&\n               (Math.abs(this.east - other.east) <= epsilon) &&\n               (Math.abs(this.north - other.north) <= epsilon);\n    };\n\n    /**\n     * Checks an Rectangle's properties and throws if they are not in valid ranges.\n     *\n     * @param {Rectangle} rectangle The rectangle to validate\n     *\n     * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     */\n    Rectangle.validate = function(rectangle) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n\n        var north = rectangle.north;\n        if (typeof north !== 'number') {\n            throw new DeveloperError('north is required to be a number.');\n        }\n\n        if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO) {\n            throw new DeveloperError('north must be in the interval [-Pi/2, Pi/2].');\n        }\n\n        var south = rectangle.south;\n        if (typeof south !== 'number') {\n            throw new DeveloperError('south is required to be a number.');\n        }\n\n        if (south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {\n            throw new DeveloperError('south must be in the interval [-Pi/2, Pi/2].');\n        }\n\n        var west = rectangle.west;\n        if (typeof west !== 'number') {\n            throw new DeveloperError('west is required to be a number.');\n        }\n\n        if (west < -Math.PI || west > Math.PI) {\n            throw new DeveloperError('west must be in the interval [-Pi, Pi].');\n        }\n\n        var east = rectangle.east;\n        if (typeof east !== 'number') {\n            throw new DeveloperError('east is required to be a number.');\n        }\n\n        if (east < -Math.PI || east > Math.PI) {\n            throw new DeveloperError('east must be in the interval [-Pi, Pi].');\n        }\n        //>>includeEnd('debug');\n    };\n\n    /**\n     * Computes the southwest corner of an rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n     */\n    Rectangle.southwest = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Cartographic(rectangle.west, rectangle.south);\n        }\n        result.longitude = rectangle.west;\n        result.latitude = rectangle.south;\n        result.height = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes the northwest corner of an rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n     */\n    Rectangle.northwest = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Cartographic(rectangle.west, rectangle.north);\n        }\n        result.longitude = rectangle.west;\n        result.latitude = rectangle.north;\n        result.height = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes the northeast corner of an rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n     */\n    Rectangle.northeast = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Cartographic(rectangle.east, rectangle.north);\n        }\n        result.longitude = rectangle.east;\n        result.latitude = rectangle.north;\n        result.height = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes the southeast corner of an rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to find the corner\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n     */\n    Rectangle.southeast = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Cartographic(rectangle.east, rectangle.south);\n        }\n        result.longitude = rectangle.east;\n        result.latitude = rectangle.south;\n        result.height = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes the center of an rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle for which to find the center\n     * @param {Cartographic} [result] The object onto which to store the result.\n     * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.\n     */\n    Rectangle.center = function(rectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        var east = rectangle.east;\n        var west = rectangle.west;\n\n        if (east < west) {\n            east += CesiumMath.TWO_PI;\n        }\n\n        var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);\n        var latitude = (rectangle.south + rectangle.north) * 0.5;\n\n        if (!defined(result)) {\n            return new Cartographic(longitude, latitude);\n        }\n\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes the intersection of two rectangles\n     *\n     * @param {Rectangle} rectangle On rectangle to find an intersection\n     * @param {Rectangle} otherRectangle Another rectangle to find an intersection\n     * @param {Rectangle} [result] The object onto which to store the result.\n     * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.\n     */\n    Rectangle.intersection = function(rectangle, otherRectangle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        if (!defined(otherRectangle)) {\n            throw new DeveloperError('otherRectangle is required.');\n        }\n        //>>includeEnd('debug');\n\n        var rectangleEast = rectangle.east;\n        var rectangleWest = rectangle.west;\n\n        var otherRectangleEast = otherRectangle.east;\n        var otherRectangleWest = otherRectangle.west;\n\n        if (rectangleEast < rectangleWest && otherRectangleEast > 0.0) {\n            rectangleEast += CesiumMath.TWO_PI;\n        } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0.0) {\n            otherRectangleEast += CesiumMath.TWO_PI;\n        }\n\n        if (rectangleEast < rectangleWest && otherRectangleWest < 0.0) {\n            otherRectangleWest += CesiumMath.TWO_PI;\n        } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0.0) {\n            rectangleWest += CesiumMath.TWO_PI;\n        }\n\n        var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));\n        var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));\n\n        if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {\n            return undefined;\n        }\n\n        var south = Math.max(rectangle.south, otherRectangle.south);\n        var north = Math.min(rectangle.north, otherRectangle.north);\n\n        if (south >= north) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new Rectangle(west, south, east, north);\n        }\n        result.west = west;\n        result.south = south;\n        result.east = east;\n        result.north = north;\n        return result;\n    };\n\n    /**\n     * Returns true if the cartographic is on or inside the rectangle, false otherwise.\n     *\n     * @param {Rectangle} rectangle The rectangle\n     * @param {Cartographic} cartographic The cartographic to test.\n     * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.\n     */\n    Rectangle.contains = function(rectangle, cartographic) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        if (!defined(cartographic)) {\n            throw new DeveloperError('cartographic is required.');\n        }\n        //>>includeEnd('debug');\n\n        var longitude = cartographic.longitude;\n        var latitude = cartographic.latitude;\n\n        var west = rectangle.west;\n        var east = rectangle.east;\n\n        if (east < west) {\n            east += CesiumMath.TWO_PI;\n            if (longitude < 0.0) {\n                longitude += CesiumMath.TWO_PI;\n            }\n        }\n        return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) &&\n               (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) &&\n               latitude >= rectangle.south &&\n               latitude <= rectangle.north;\n    };\n\n    var subsampleLlaScratch = new Cartographic();\n    /**\n     * Samples an rectangle so that it includes a list of Cartesian points suitable for passing to\n     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account\n     * for rectangles that cover the poles or cross the equator.\n     *\n     * @param {Rectangle} rectangle The rectangle to subsample.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n     * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.\n     * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.\n     * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.\n     */\n    Rectangle.subsample = function(rectangle, ellipsoid, surfaceHeight, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required');\n        }\n        //>>includeEnd('debug');\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n        if (!defined(result)) {\n            result = [];\n        }\n        var length = 0;\n\n        var north = rectangle.north;\n        var south = rectangle.south;\n        var east = rectangle.east;\n        var west = rectangle.west;\n\n        var lla = subsampleLlaScratch;\n        lla.height = surfaceHeight;\n\n        lla.longitude = west;\n        lla.latitude = north;\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n        length++;\n\n        lla.longitude = east;\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n        length++;\n\n        lla.latitude = south;\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n        length++;\n\n        lla.longitude = west;\n        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n        length++;\n\n        if (north < 0.0) {\n            lla.latitude = north;\n        } else if (south > 0.0) {\n            lla.latitude = south;\n        } else {\n            lla.latitude = 0.0;\n        }\n\n        for ( var i = 1; i < 8; ++i) {\n            lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;\n            if (Rectangle.contains(rectangle, lla)) {\n                result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n                length++;\n            }\n        }\n\n        if (lla.latitude === 0.0) {\n            lla.longitude = west;\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n            length++;\n            lla.longitude = east;\n            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);\n            length++;\n        }\n        result.length = length;\n        return result;\n    };\n\n    /**\n     * The largest possible rectangle.\n     *\n     * @type {Rectangle}\n     * @constant\n    */\n    Rectangle.MAX_VALUE = freezeObject(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));\n\n    return Rectangle;\n});\n",
    "\n/*global define,console*/\ndefine('Core/deprecationWarning',[\n        './defined',\n        './DeveloperError'\n    ], function(\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    var warnings = {};\n\n    /**\n     * Logs a deprecation message to the console.  Use this function instead of\n     * <code>console.log</code> directly since this does not log duplicate messages\n     * unless it is called from multiple workers.\n     *\n     * @exports deprecationWarning\n     *\n     * @param {String} identifier The unique identifier for this deprecated API.\n     * @param {String} message The message to log to the console.\n     *\n     * @example\n     * // Deprecated function or class\n     * var Foo = function() {\n     *    deprecationWarning('Foo', 'Foo was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use newFoo instead.');\n     *    // ...\n     * }\n     *\n     * // Deprecated function\n     * Bar.prototype.func = function() {\n     *    deprecationWarning('Bar.func', 'Bar.func() was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newFunc() instead.');\n     *    // ...\n     * };\n     *\n     * // Deprecated property\n     * defineProperties(Bar.prototype, {\n     *     prop : {\n     *         get : function() {\n     *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n     *             // ...\n     *         },\n     *         set : function(value) {\n     *             deprecationWarning('Bar.prop', 'Bar.prop was deprecated in Cesium 1.01.  It will be removed in 1.03.  Use Bar.newProp instead.');\n     *             // ...\n     *         }\n     *     }\n     * });\n     *\n     * @private\n     */\n    var deprecationWarning = function(identifier, message) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(identifier) || !defined(message)) {\n            throw new DeveloperError('identifier and message are required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(warnings[identifier])) {\n            warnings[identifier] = true;\n            console.log(message);\n        }\n    };\n\n    return deprecationWarning;\n});",
    "\n/*global define*/\ndefine('Core/GeographicProjection',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './Ellipsoid'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid) {\n    \"use strict\";\n\n    /**\n     * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\n     * them by the {@link Ellipsoid#maximumRadius}.  This projection\n     * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It\n     * is also known as EPSG:4326.\n     *\n     * @alias GeographicProjection\n     * @constructor\n     *\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n     *\n     * @see WebMercatorProjection\n     */\n    var GeographicProjection = function(ellipsoid) {\n        this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        this._semimajorAxis = this._ellipsoid.maximumRadius;\n        this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n    };\n\n    defineProperties(GeographicProjection.prototype, {\n        /**\n         * Gets the {@link Ellipsoid}.\n         *\n         * @memberof GeographicProjection.prototype\n         *\n         * @type {Ellipsoid}\n         * @readonly\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        }\n    });\n\n    /**\n     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\n     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\n     * ellipsoid.  Z is the unmodified height.\n     *\n     * @param {Cartographic} cartographic The coordinates to project.\n     * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n     *        undefined, a new instance is created and returned.\n     * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n     *          created and returned.\n     */\n    GeographicProjection.prototype.project = function(cartographic, result) {\n        // Actually this is the special case of equidistant cylindrical called the plate carree\n        var semimajorAxis = this._semimajorAxis;\n        var x = cartographic.longitude * semimajorAxis;\n        var y = cartographic.latitude * semimajorAxis;\n        var z = cartographic.height;\n\n        if (!defined(result)) {\n            return new Cartesian3(x, y, z);\n        }\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\n     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\n     *\n     * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n     * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n     *        undefined, a new instance is created and returned.\n     * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n     *          created and returned.\n     */\n    GeographicProjection.prototype.unproject = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n        var longitude = cartesian.x * oneOverEarthSemimajorAxis;\n        var latitude = cartesian.y * oneOverEarthSemimajorAxis;\n        var height = cartesian.z;\n\n        if (!defined(result)) {\n            return new Cartographic(longitude, latitude, height);\n        }\n\n        result.longitude = longitude;\n        result.latitude = latitude;\n        result.height = height;\n        return result;\n    };\n\n    return GeographicProjection;\n});\n",
    "\n/*global define*/\ndefine('Core/Intersect',[\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * This enumerated type is used in determining where, relative to the frustum, an\n     * object is located. The object can either be fully contained within the frustum (INSIDE),\n     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely\n     * outside of the frustum's 6 planes (OUTSIDE).\n     *\n     * @namespace\n     * @alias Intersect\n     */\n    var Intersect = {\n        /**\n         * Represents that an object is not contained within the frustum.\n         *\n         * @type {Number}\n         * @constant\n         */\n        OUTSIDE : -1,\n\n        /**\n         * Represents that an object intersects one of the frustum's planes.\n         *\n         * @type {Number}\n         * @constant\n         */\n        INTERSECTING : 0,\n\n        /**\n         * Represents that an object is fully within the frustum.\n         *\n         * @type {Number}\n         * @constant\n         */\n        INSIDE : 1\n    };\n\n    return freezeObject(Intersect);\n});",
    "\n/*global define*/\ndefine('Core/Interval',[\n        './defaultValue'\n    ], function(\n        defaultValue) {\n    \"use strict\";\n\n    /**\n     * Represents the closed interval [start, stop].\n     * @alias Interval\n     * @constructor\n     *\n     * @param {Number} [start=0.0] The beginning of the interval.\n     * @param {Number} [stop=0.0] The end of the interval.\n     */\n    var Interval = function(start, stop) {\n        /**\n         * The beginning of the interval.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.start = defaultValue(start, 0.0);\n        /**\n         * The end of the interval.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.stop = defaultValue(stop, 0.0);\n    };\n\n    return Interval;\n});\n",
    "\n/*global define*/\ndefine('Core/Cartesian4',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A 4D Cartesian point.\n     * @alias Cartesian4\n     * @constructor\n     *\n     * @param {Number} [x=0.0] The X component.\n     * @param {Number} [y=0.0] The Y component.\n     * @param {Number} [z=0.0] The Z component.\n     * @param {Number} [w=0.0] The W component.\n     *\n     * @see Cartesian2\n     * @see Cartesian3\n     * @see Packable\n     */\n    var Cartesian4 = function(x, y, z, w) {\n        /**\n         * The X component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.x = defaultValue(x, 0.0);\n\n        /**\n         * The Y component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.y = defaultValue(y, 0.0);\n\n        /**\n         * The Z component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.z = defaultValue(z, 0.0);\n\n        /**\n         * The W component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.w = defaultValue(w, 0.0);\n    };\n\n    /**\n     * Creates a Cartesian4 instance from x, y, z and w coordinates.\n     *\n     * @param {Number} x The x coordinate.\n     * @param {Number} y The y coordinate.\n     * @param {Number} z The z coordinate.\n     * @param {Number} w The w coordinate.\n     * @param {Cartesian4} [result] The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n     */\n    Cartesian4.fromElements = function(x, y, z, w, result) {\n        if (!defined(result)) {\n            return new Cartesian4(x, y, z, w);\n        }\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n     * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n     *\n     * @param {Color} color The source color.\n     * @param {Cartesian4} [result] The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n     */\n    Cartesian4.fromColor = function(color, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(color)) {\n            throw new DeveloperError('color is required');\n        }\n        //>>includeEnd('debug');\n        if (!defined(result)) {\n            return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n        }\n\n        result.x = color.red;\n        result.y = color.green;\n        result.z = color.blue;\n        result.w = color.alpha;\n        return result;\n    };\n\n    /**\n     * Duplicates a Cartesian4 instance.\n     *\n     * @param {Cartesian4} cartesian The Cartesian to duplicate.\n     * @param {Cartesian4} [result] The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n     */\n    Cartesian4.clone = function(cartesian, result) {\n        if (!defined(cartesian)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n        }\n\n        result.x = cartesian.x;\n        result.y = cartesian.y;\n        result.z = cartesian.z;\n        result.w = cartesian.w;\n        return result;\n    };\n\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Cartesian4.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Cartesian4} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Cartesian4.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.x;\n        array[startingIndex++] = value.y;\n        array[startingIndex++] = value.z;\n        array[startingIndex] = value.w;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Cartesian4} [result] The object into which to store the result.\n     * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n     */\n    Cartesian4.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Cartesian4();\n        }\n        result.x = array[startingIndex++];\n        result.y = array[startingIndex++];\n        result.z = array[startingIndex++];\n        result.w = array[startingIndex];\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian4 from four consecutive elements in an array.\n     * @function\n     *\n     * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n     * @param {Cartesian4} [result] The object onto which to store the result.\n     * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n     *\n     * @example\n     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n     * var v = [1.0, 2.0, 3.0, 4.0];\n     * var p = Cesium.Cartesian4.fromArray(v);\n     *\n     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n     * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n     */\n    Cartesian4.fromArray = Cartesian4.unpack;\n\n    /**\n     * Computes the value of the maximum component for the supplied Cartesian.\n     *\n     * @param {Cartesian4} cartesian The cartesian to use.\n     * @returns {Number} The value of the maximum component.\n     */\n    Cartesian4.maximumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n    };\n\n    /**\n     * Computes the value of the minimum component for the supplied Cartesian.\n     *\n     * @param {Cartesian4} cartesian The cartesian to use.\n     * @returns {Number} The value of the minimum component.\n     */\n    Cartesian4.minimumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n     *\n     * @param {Cartesian4} first A cartesian to compare.\n     * @param {Cartesian4} second A cartesian to compare.\n     * @param {Cartesian4} result The object into which to store the result.\n     * @returns {Cartesian4} A cartesian with the minimum components.\n     */\n    Cartesian4.minimumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.min(first.x, second.x);\n        result.y = Math.min(first.y, second.y);\n        result.z = Math.min(first.z, second.z);\n        result.w = Math.min(first.w, second.w);\n\n        return result;\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n     *\n     * @param {Cartesian4} first A cartesian to compare.\n     * @param {Cartesian4} second A cartesian to compare.\n     * @param {Cartesian4} result The object into which to store the result.\n     * @returns {Cartesian4} A cartesian with the maximum components.\n     */\n    Cartesian4.maximumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.max(first.x, second.x);\n        result.y = Math.max(first.y, second.y);\n        result.z = Math.max(first.z, second.z);\n        result.w = Math.max(first.w, second.w);\n\n        return result;\n    };\n\n    /**\n     * Computes the provided Cartesian's squared magnitude.\n     *\n     * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n     * @returns {Number} The squared magnitude.\n     */\n    Cartesian4.magnitudeSquared = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;\n    };\n\n    /**\n     * Computes the Cartesian's magnitude (length).\n     *\n     * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n     * @returns {Number} The magnitude.\n     */\n    Cartesian4.magnitude = function(cartesian) {\n        return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n    };\n\n    var distanceScratch = new Cartesian4();\n\n    /**\n     * Computes the 4-space distance between two points.\n     *\n     * @param {Cartesian4} left The first point to compute the distance from.\n     * @param {Cartesian4} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 1.0\n     * var d = Cesium.Cartesian4.distance(\n     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n     *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n     */\n    Cartesian4.distance = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian4.subtract(left, right, distanceScratch);\n        return Cartesian4.magnitude(distanceScratch);\n    };\n\n    /**\n     * Computes the squared distance between two points.  Comparing squared distances\n     * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n     *\n     * @param {Cartesian4} left The first point to compute the distance from.\n     * @param {Cartesian4} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 4.0, not 2.0\n     * var d = Cesium.Cartesian4.distance(\n     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n     *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n     */\n    Cartesian4.distanceSquared = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian4.subtract(left, right, distanceScratch);\n        return Cartesian4.magnitudeSquared(distanceScratch);\n    };\n\n    /**\n     * Computes the normalized form of the supplied Cartesian.\n     *\n     * @param {Cartesian4} cartesian The Cartesian to be normalized.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.normalize = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var magnitude = Cartesian4.magnitude(cartesian);\n\n        result.x = cartesian.x / magnitude;\n        result.y = cartesian.y / magnitude;\n        result.z = cartesian.z / magnitude;\n        result.w = cartesian.w / magnitude;\n        return result;\n    };\n\n    /**\n     * Computes the dot (scalar) product of two Cartesians.\n     *\n     * @param {Cartesian4} left The first Cartesian.\n     * @param {Cartesian4} right The second Cartesian.\n     * @returns {Number} The dot product.\n     */\n    Cartesian4.dot = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n    };\n\n    /**\n     * Computes the componentwise product of two Cartesians.\n     *\n     * @param {Cartesian4} left The first Cartesian.\n     * @param {Cartesian4} right The second Cartesian.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.multiplyComponents = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x * right.x;\n        result.y = left.y * right.y;\n        result.z = left.z * right.z;\n        result.w = left.w * right.w;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise sum of two Cartesians.\n     *\n     * @param {Cartesian4} left The first Cartesian.\n     * @param {Cartesian4} right The second Cartesian.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x + right.x;\n        result.y = left.y + right.y;\n        result.z = left.z + right.z;\n        result.w = left.w + right.w;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise difference of two Cartesians.\n     *\n     * @param {Cartesian4} left The first Cartesian.\n     * @param {Cartesian4} right The second Cartesian.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x - right.x;\n        result.y = left.y - right.y;\n        result.z = left.z - right.z;\n        result.w = left.w - right.w;\n        return result;\n    };\n\n    /**\n     * Multiplies the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian4} cartesian The Cartesian to be scaled.\n     * @param {Number} scalar The scalar to multiply with.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x * scalar;\n        result.y = cartesian.y * scalar;\n        result.z = cartesian.z * scalar;\n        result.w = cartesian.w * scalar;\n        return result;\n    };\n\n    /**\n     * Divides the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian4} cartesian The Cartesian to be divided.\n     * @param {Number} scalar The scalar to divide by.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.divideByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x / scalar;\n        result.y = cartesian.y / scalar;\n        result.z = cartesian.z / scalar;\n        result.w = cartesian.w / scalar;\n        return result;\n    };\n\n    /**\n     * Negates the provided Cartesian.\n     *\n     * @param {Cartesian4} cartesian The Cartesian to be negated.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.negate = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = -cartesian.x;\n        result.y = -cartesian.y;\n        result.z = -cartesian.z;\n        result.w = -cartesian.w;\n        return result;\n    };\n\n    /**\n     * Computes the absolute value of the provided Cartesian.\n     *\n     * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.abs = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.abs(cartesian.x);\n        result.y = Math.abs(cartesian.y);\n        result.z = Math.abs(cartesian.z);\n        result.w = Math.abs(cartesian.w);\n        return result;\n    };\n\n    var lerpScratch = new Cartesian4();\n    /**\n     * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n     *\n     * @param {Cartesian4} start The value corresponding to t at 0.0.\n     * @param {Cartesian4}end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Cartesian4.lerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian4.multiplyByScalar(end, t, lerpScratch);\n        result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n        return Cartesian4.add(lerpScratch, result, result);\n    };\n\n    var mostOrthogonalAxisScratch = new Cartesian4();\n    /**\n     * Returns the axis that is most orthogonal to the provided Cartesian.\n     *\n     * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The most orthogonal axis.\n     */\n    Cartesian4.mostOrthogonalAxis = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n        Cartesian4.abs(f, f);\n\n        if (f.x <= f.y) {\n            if (f.x <= f.z) {\n                if (f.x <= f.w) {\n                    result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n                } else {\n                    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n                }\n            } else if (f.z <= f.w) {\n                result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n            } else {\n                result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n            }\n        } else if (f.y <= f.z) {\n            if (f.y <= f.w) {\n                result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n            } else {\n                result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n            }\n        } else if (f.z <= f.w) {\n            result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n        } else {\n            result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n        }\n\n        return result;\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian4} [left] The first Cartesian.\n     * @param {Cartesian4} [right] The second Cartesian.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Cartesian4.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (left.x === right.x) &&\n                (left.y === right.y) &&\n                (left.z === right.z) &&\n                (left.w === right.w));\n    };\n\n    /**\n     * @private\n     */\n    Cartesian4.equalsArray = function(cartesian, array, offset) {\n        return cartesian.x === array[offset] &&\n               cartesian.y === array[offset + 1] &&\n               cartesian.z === array[offset + 2] &&\n               cartesian.w === array[offset + 3];\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian4} [left] The first Cartesian.\n     * @param {Cartesian4} [right] The second Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian4.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon));\n    };\n\n    /**\n     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n     *\n     * @type {Cartesian4}\n     * @constant\n     */\n    Cartesian4.ZERO = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n    /**\n     * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n     *\n     * @type {Cartesian4}\n     * @constant\n     */\n    Cartesian4.UNIT_X = freezeObject(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n    /**\n     * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n     *\n     * @type {Cartesian4}\n     * @constant\n     */\n    Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n    /**\n     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n     *\n     * @type {Cartesian4}\n     * @constant\n     */\n    Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n    /**\n     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n     *\n     * @type {Cartesian4}\n     * @constant\n     */\n    Cartesian4.UNIT_W = freezeObject(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n    /**\n     * Duplicates this Cartesian4 instance.\n     *\n     * @param {Cartesian4} [result] The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n     */\n    Cartesian4.prototype.clone = function(result) {\n        return Cartesian4.clone(this, result);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian4} [right] The right hand side Cartesian.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Cartesian4.prototype.equals = function(right) {\n        return Cartesian4.equals(this, right);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian4} [right] The right hand side Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian4.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\n        return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n    };\n\n    /**\n     * Creates a string representing this Cartesian in the format '(x, y)'.\n     *\n     * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n     */\n    Cartesian4.prototype.toString = function() {\n        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';\n    };\n\n    return Cartesian4;\n});\n",
    "\n/*global define*/\ndefine('Core/Matrix3',[\n        './Cartesian3',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A 3x3 matrix, indexable as a column-major order array.\n     * Constructor parameters are in row-major order for code readability.\n     * @alias Matrix3\n     * @constructor\n     *\n     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n     *\n     * @see Matrix3.fromColumnMajorArray\n     * @see Matrix3.fromRowMajorArray\n     * @see Matrix3.fromQuaternion\n     * @see Matrix3.fromScale\n     * @see Matrix3.fromUniformScale\n     * @see Matrix2\n     * @see Matrix4\n     */\n    var Matrix3 = function(column0Row0, column1Row0, column2Row0,\n                           column0Row1, column1Row1, column2Row1,\n                           column0Row2, column1Row2, column2Row2) {\n        this[0] = defaultValue(column0Row0, 0.0);\n        this[1] = defaultValue(column0Row1, 0.0);\n        this[2] = defaultValue(column0Row2, 0.0);\n        this[3] = defaultValue(column1Row0, 0.0);\n        this[4] = defaultValue(column1Row1, 0.0);\n        this[5] = defaultValue(column1Row2, 0.0);\n        this[6] = defaultValue(column2Row0, 0.0);\n        this[7] = defaultValue(column2Row1, 0.0);\n        this[8] = defaultValue(column2Row2, 0.0);\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Matrix3.packedLength = 9;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Matrix3} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Matrix3.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value[0];\n        array[startingIndex++] = value[1];\n        array[startingIndex++] = value[2];\n        array[startingIndex++] = value[3];\n        array[startingIndex++] = value[4];\n        array[startingIndex++] = value[5];\n        array[startingIndex++] = value[6];\n        array[startingIndex++] = value[7];\n        array[startingIndex++] = value[8];\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Matrix3} [result] The object into which to store the result.\n     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n     */\n    Matrix3.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Matrix3();\n        }\n\n        result[0] = array[startingIndex++];\n        result[1] = array[startingIndex++];\n        result[2] = array[startingIndex++];\n        result[3] = array[startingIndex++];\n        result[4] = array[startingIndex++];\n        result[5] = array[startingIndex++];\n        result[6] = array[startingIndex++];\n        result[7] = array[startingIndex++];\n        result[8] = array[startingIndex++];\n        return result;\n    };\n\n    /**\n     * Duplicates a Matrix3 instance.\n     *\n     * @param {Matrix3} matrix The matrix to duplicate.\n     * @param {Matrix3} [result] The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n     */\n    Matrix3.clone = function(values, result) {\n        if (!defined(values)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Matrix3(values[0], values[3], values[6],\n                               values[1], values[4], values[7],\n                               values[2], values[5], values[8]);\n        }\n        result[0] = values[0];\n        result[1] = values[1];\n        result[2] = values[2];\n        result[3] = values[3];\n        result[4] = values[4];\n        result[5] = values[5];\n        result[6] = values[6];\n        result[7] = values[7];\n        result[8] = values[8];\n        return result;\n    };\n\n    /**\n     * Creates a Matrix3 from 9 consecutive elements in an array.\n     *\n     * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n     * @param {Matrix3} [result] The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Create the Matrix3:\n     * // [1.0, 2.0, 3.0]\n     * // [1.0, 2.0, 3.0]\n     * // [1.0, 2.0, 3.0]\n     *\n     * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n     * var m = Cesium.Matrix3.fromArray(v);\n     *\n     * // Create same Matrix3 with using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n     * var m2 = Cesium.Matrix3.fromArray(v2, 2);\n     */\n    Matrix3.fromArray = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Matrix3();\n        }\n\n        result[0] = array[startingIndex];\n        result[1] = array[startingIndex + 1];\n        result[2] = array[startingIndex + 2];\n        result[3] = array[startingIndex + 3];\n        result[4] = array[startingIndex + 4];\n        result[5] = array[startingIndex + 5];\n        result[6] = array[startingIndex + 6];\n        result[7] = array[startingIndex + 7];\n        result[8] = array[startingIndex + 8];\n        return result;\n    };\n\n    /**\n     * Creates a Matrix3 instance from a column-major order array.\n     *\n     * @param {Number[]} values The column-major order array.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     */\n    Matrix3.fromColumnMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values parameter is required');\n        }\n        //>>includeEnd('debug');\n\n        return Matrix3.clone(values, result);\n    };\n\n    /**\n     * Creates a Matrix3 instance from a row-major order array.\n     * The resulting matrix will be in column-major order.\n     *\n     * @param {Number[]} values The row-major order array.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     */\n    Matrix3.fromRowMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix3(values[0], values[1], values[2],\n                               values[3], values[4], values[5],\n                               values[6], values[7], values[8]);\n        }\n        result[0] = values[0];\n        result[1] = values[3];\n        result[2] = values[6];\n        result[3] = values[1];\n        result[4] = values[4];\n        result[5] = values[7];\n        result[6] = values[2];\n        result[7] = values[5];\n        result[8] = values[8];\n        return result;\n    };\n\n    /**\n     * Computes a 3x3 rotation matrix from the provided quaternion.\n     *\n     * @param {Quaternion} quaternion the quaternion to use.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n     */\n    Matrix3.fromQuaternion = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        //>>includeEnd('debug');\n\n        var x2 = quaternion.x * quaternion.x;\n        var xy = quaternion.x * quaternion.y;\n        var xz = quaternion.x * quaternion.z;\n        var xw = quaternion.x * quaternion.w;\n        var y2 = quaternion.y * quaternion.y;\n        var yz = quaternion.y * quaternion.z;\n        var yw = quaternion.y * quaternion.w;\n        var z2 = quaternion.z * quaternion.z;\n        var zw = quaternion.z * quaternion.w;\n        var w2 = quaternion.w * quaternion.w;\n\n        var m00 = x2 - y2 - z2 + w2;\n        var m01 = 2.0 * (xy - zw);\n        var m02 = 2.0 * (xz + yw);\n\n        var m10 = 2.0 * (xy + zw);\n        var m11 = -x2 + y2 - z2 + w2;\n        var m12 = 2.0 * (yz - xw);\n\n        var m20 = 2.0 * (xz - yw);\n        var m21 = 2.0 * (yz + xw);\n        var m22 = -x2 - y2 + z2 + w2;\n\n        if (!defined(result)) {\n            return new Matrix3(m00, m01, m02,\n                               m10, m11, m12,\n                               m20, m21, m22);\n        }\n        result[0] = m00;\n        result[1] = m10;\n        result[2] = m20;\n        result[3] = m01;\n        result[4] = m11;\n        result[5] = m21;\n        result[6] = m02;\n        result[7] = m12;\n        result[8] = m22;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix3 instance representing a non-uniform scale.\n     *\n     * @param {Cartesian3} scale The x, y, and z scale factors.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [7.0, 0.0, 0.0]\n     * //   [0.0, 8.0, 0.0]\n     * //   [0.0, 0.0, 9.0]\n     * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n     */\n    Matrix3.fromScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix3(\n                scale.x, 0.0,     0.0,\n                0.0,     scale.y, 0.0,\n                0.0,     0.0,     scale.z);\n        }\n\n        result[0] = scale.x;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = scale.y;\n        result[5] = 0.0;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = scale.z;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix3 instance representing a uniform scale.\n     *\n     * @param {Number} scale The uniform scale factor.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [2.0, 0.0, 0.0]\n     * //   [0.0, 2.0, 0.0]\n     * //   [0.0, 0.0, 2.0]\n     * var m = Cesium.Matrix3.fromUniformScale(2.0);\n     */\n    Matrix3.fromUniformScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof scale !== 'number') {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix3(\n                scale, 0.0,   0.0,\n                0.0,   scale, 0.0,\n                0.0,   0.0,   scale);\n        }\n\n        result[0] = scale;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = scale;\n        result[5] = 0.0;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = scale;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n     *\n     * @param {Cartesian3} the vector on the left hand side of the cross product operation.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [0.0, -9.0,  8.0]\n     * //   [9.0,  0.0, -7.0]\n     * //   [-8.0, 7.0,  0.0]\n     * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n     */\n    Matrix3.fromCrossProduct = function(vector, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(vector)) {\n            throw new DeveloperError('vector is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix3(\n                      0.0, -vector.z,  vector.y,\n                 vector.z,       0.0, -vector.x,\n                -vector.y,  vector.x,       0.0);\n        }\n\n        result[0] = 0.0;\n        result[1] = vector.z;\n        result[2] = -vector.y;\n        result[3] = -vector.z;\n        result[4] = 0.0;\n        result[5] = vector.x;\n        result[6] = vector.y;\n        result[7] = -vector.x;\n        result[8] = 0.0;\n        return result;\n    };\n\n    /**\n     * Creates a rotation matrix around the x-axis.\n     *\n     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Rotate a point 45 degrees counterclockwise around the x-axis.\n     * var p = new Cesium.Cartesian3(5, 6, 7);\n     * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n     */\n    Matrix3.fromRotationX = function(angle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        //>>includeEnd('debug');\n\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n\n        if (!defined(result)) {\n            return new Matrix3(\n                1.0, 0.0, 0.0,\n                0.0, cosAngle, -sinAngle,\n                0.0, sinAngle, cosAngle);\n        }\n\n        result[0] = 1.0;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = cosAngle;\n        result[5] = sinAngle;\n        result[6] = 0.0;\n        result[7] = -sinAngle;\n        result[8] = cosAngle;\n\n        return result;\n    };\n\n    /**\n     * Creates a rotation matrix around the y-axis.\n     *\n     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Rotate a point 45 degrees counterclockwise around the y-axis.\n     * var p = new Cesium.Cartesian3(5, 6, 7);\n     * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n     */\n    Matrix3.fromRotationY = function(angle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        //>>includeEnd('debug');\n\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n\n        if (!defined(result)) {\n            return new Matrix3(\n                cosAngle, 0.0, sinAngle,\n                0.0, 1.0, 0.0,\n                -sinAngle, 0.0, cosAngle);\n        }\n\n        result[0] = cosAngle;\n        result[1] = 0.0;\n        result[2] = -sinAngle;\n        result[3] = 0.0;\n        result[4] = 1.0;\n        result[5] = 0.0;\n        result[6] = sinAngle;\n        result[7] = 0.0;\n        result[8] = cosAngle;\n\n        return result;\n    };\n\n    /**\n     * Creates a rotation matrix around the z-axis.\n     *\n     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n     *\n     * @example\n     * // Rotate a point 45 degrees counterclockwise around the z-axis.\n     * var p = new Cesium.Cartesian3(5, 6, 7);\n     * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n     * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n     */\n    Matrix3.fromRotationZ = function(angle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        //>>includeEnd('debug');\n\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n\n        if (!defined(result)) {\n            return new Matrix3(\n                cosAngle, -sinAngle, 0.0,\n                sinAngle, cosAngle, 0.0,\n                0.0, 0.0, 1.0);\n        }\n\n        result[0] = cosAngle;\n        result[1] = sinAngle;\n        result[2] = 0.0;\n        result[3] = -sinAngle;\n        result[4] = cosAngle;\n        result[5] = 0.0;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 1.0;\n\n        return result;\n    };\n\n    /**\n     * Creates an Array from the provided Matrix3 instance.\n     * The array will be in column-major order.\n     *\n     * @param {Matrix3} matrix The matrix to use..\n     * @param {Number[]} [result] The Array onto which to store the result.\n     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n     */\n    Matrix3.toArray = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];\n        }\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n        result[4] = matrix[4];\n        result[5] = matrix[5];\n        result[6] = matrix[6];\n        result[7] = matrix[7];\n        result[8] = matrix[8];\n        return result;\n    };\n\n    /**\n     * Computes the array index of the element at the provided row and column.\n     *\n     * @param {Number} row The zero-based index of the row.\n     * @param {Number} column The zero-based index of the column.\n     * @returns {Number} The index of the element at the provided row and column.\n     *\n     * @exception {DeveloperError} row must be 0, 1, or 2.\n     * @exception {DeveloperError} column must be 0, 1, or 2.\n     *\n     * @example\n     * var myMatrix = new Cesium.Matrix3();\n     * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n     * var column1Row0 = myMatrix[column1Row0Index]\n     * myMatrix[column1Row0Index] = 10.0;\n     */\n    Matrix3.getElementIndex = function(column, row) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof row !== 'number' || row < 0 || row > 2) {\n            throw new DeveloperError('row must be 0, 1, or 2.');\n        }\n        if (typeof column !== 'number' || column < 0 || column > 2) {\n            throw new DeveloperError('column must be 0, 1, or 2.');\n        }\n        //>>includeEnd('debug');\n\n        return column * 3 + row;\n    };\n\n    /**\n     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n     *\n     * @param {Matrix3} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to retrieve.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, or 2.\n     */\n    Matrix3.getColumn = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n\n        if (typeof index !== 'number' || index < 0 || index > 2) {\n            throw new DeveloperError('index must be 0, 1, or 2.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var startIndex = index * 3;\n        var x = matrix[startIndex];\n        var y = matrix[startIndex + 1];\n        var z = matrix[startIndex + 2];\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n     *\n     * @param {Matrix3} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to set.\n     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, or 2.\n     */\n    Matrix3.setColumn = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 2) {\n            throw new DeveloperError('index must be 0, 1, or 2.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix3.clone(matrix, result);\n        var startIndex = index * 3;\n        result[startIndex] = cartesian.x;\n        result[startIndex + 1] = cartesian.y;\n        result[startIndex + 2] = cartesian.z;\n        return result;\n    };\n\n    /**\n     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n     *\n     * @param {Matrix3} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to retrieve.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, or 2.\n     */\n    Matrix3.getRow = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 2) {\n            throw new DeveloperError('index must be 0, 1, or 2.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = matrix[index];\n        var y = matrix[index + 3];\n        var z = matrix[index + 6];\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n     *\n     * @param {Matrix3} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to set.\n     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, or 2.\n     */\n    Matrix3.setRow = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 2) {\n            throw new DeveloperError('index must be 0, 1, or 2.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix3.clone(matrix, result);\n        result[index] = cartesian.x;\n        result[index + 3] = cartesian.y;\n        result[index + 6] = cartesian.z;\n        return result;\n    };\n\n    var scratchColumn = new Cartesian3();\n\n    /**\n     * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n     *\n     * @param {Matrix3} matrix The matrix.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Matrix3.getScale = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));\n        result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));\n        result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));\n        return result;\n    };\n\n    var scratchScale = new Cartesian3();\n\n    /**\n     * Computes the maximum scale assuming the matrix is an affine transformation.\n     * The maximum scale is the maximum length of the column vectors.\n     *\n     * @param {Matrix3} matrix The matrix.\n     * @returns {Number} The maximum scale.\n     */\n    Matrix3.getMaximumScale = function(matrix) {\n        Matrix3.getScale(matrix, scratchScale);\n        return Cartesian3.maximumComponent(scratchScale);\n    };\n\n    /**\n     * Computes the product of two matrices.\n     *\n     * @param {Matrix3} left The first matrix.\n     * @param {Matrix3} right The second matrix.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.multiply = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n        var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n        var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n        var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n        var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n        var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n        var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n        var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n        var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column0Row2;\n        result[3] = column1Row0;\n        result[4] = column1Row1;\n        result[5] = column1Row2;\n        result[6] = column2Row0;\n        result[7] = column2Row1;\n        result[8] = column2Row2;\n        return result;\n    };\n\n    /**\n     * Computes the sum of two matrices.\n     *\n     * @param {Matrix3} left The first matrix.\n     * @param {Matrix3} right The second matrix.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] + right[0];\n        result[1] = left[1] + right[1];\n        result[2] = left[2] + right[2];\n        result[3] = left[3] + right[3];\n        result[4] = left[4] + right[4];\n        result[5] = left[5] + right[5];\n        result[6] = left[6] + right[6];\n        result[7] = left[7] + right[7];\n        result[8] = left[8] + right[8];\n        return result;\n    };\n\n    /**\n     * Computes the difference of two matrices.\n     *\n     * @param {Matrix3} left The first matrix.\n     * @param {Matrix3} right The second matrix.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] - right[0];\n        result[1] = left[1] - right[1];\n        result[2] = left[2] - right[2];\n        result[3] = left[3] - right[3];\n        result[4] = left[4] - right[4];\n        result[5] = left[5] - right[5];\n        result[6] = left[6] - right[6];\n        result[7] = left[7] - right[7];\n        result[8] = left[8] - right[8];\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a column vector.\n     *\n     * @param {Matrix3} matrix The matrix.\n     * @param {Cartesian3} cartesian The column.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Matrix3.multiplyByVector = function(matrix, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var vX = cartesian.x;\n        var vY = cartesian.y;\n        var vZ = cartesian.z;\n\n        var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n        var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n        var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a scalar.\n     *\n     * @param {Matrix3} matrix The matrix.\n     * @param {Number} scalar The number to multiply by.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.multiplyByScalar = function(matrix, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar must be a number');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0] * scalar;\n        result[1] = matrix[1] * scalar;\n        result[2] = matrix[2] * scalar;\n        result[3] = matrix[3] * scalar;\n        result[4] = matrix[4] * scalar;\n        result[5] = matrix[5] * scalar;\n        result[6] = matrix[6] * scalar;\n        result[7] = matrix[7] * scalar;\n        result[8] = matrix[8] * scalar;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n     *\n     * @param {Matrix3} matrix The matrix on the left-hand side.\n     * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     *\n     * @see Matrix3.fromScale\n     * @see Matrix3.multiplyByUniformScale\n     *\n     * @example\n     * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n     * Cesium.Matrix3.multiplyByScale(m, scale, m);\n     */\n    Matrix3.multiplyByScale = function(matrix, scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0] * scale.x;\n        result[1] = matrix[1] * scale.x;\n        result[2] = matrix[2] * scale.x;\n        result[3] = matrix[3] * scale.y;\n        result[4] = matrix[4] * scale.y;\n        result[5] = matrix[5] * scale.y;\n        result[6] = matrix[6] * scale.z;\n        result[7] = matrix[7] * scale.z;\n        result[8] = matrix[8] * scale.z;\n        return result;\n    };\n\n    /**\n     * Creates a negated copy of the provided matrix.\n     *\n     * @param {Matrix3} matrix The matrix to negate.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.negate = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = -matrix[0];\n        result[1] = -matrix[1];\n        result[2] = -matrix[2];\n        result[3] = -matrix[3];\n        result[4] = -matrix[4];\n        result[5] = -matrix[5];\n        result[6] = -matrix[6];\n        result[7] = -matrix[7];\n        result[8] = -matrix[8];\n        return result;\n    };\n\n    /**\n     * Computes the transpose of the provided matrix.\n     *\n     * @param {Matrix3} matrix The matrix to transpose.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.transpose = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = matrix[0];\n        var column0Row1 = matrix[3];\n        var column0Row2 = matrix[6];\n        var column1Row0 = matrix[1];\n        var column1Row1 = matrix[4];\n        var column1Row2 = matrix[7];\n        var column2Row0 = matrix[2];\n        var column2Row1 = matrix[5];\n        var column2Row2 = matrix[8];\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column0Row2;\n        result[3] = column1Row0;\n        result[4] = column1Row1;\n        result[5] = column1Row2;\n        result[6] = column2Row0;\n        result[7] = column2Row1;\n        result[8] = column2Row2;\n        return result;\n    };\n\n    function computeFrobeniusNorm(matrix) {\n        var norm = 0.0;\n        for (var i = 0; i < 9; ++i) {\n            var temp = matrix[i];\n            norm += temp * temp;\n        }\n\n        return Math.sqrt(norm);\n    }\n\n    var rowVal = [1, 0, 0];\n    var colVal = [2, 2, 1];\n\n    function offDiagonalFrobeniusNorm(matrix) {\n        // Computes the \"off-diagonal\" Frobenius norm.\n        // Assumes matrix is symmetric.\n\n        var norm = 0.0;\n        for (var i = 0; i < 3; ++i) {\n            var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n            norm += 2.0 * temp * temp;\n        }\n\n        return Math.sqrt(norm);\n    }\n\n    function shurDecomposition(matrix, result) {\n        // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n        // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n        //\n        // The routine takes a matrix, which is assumed to be symmetric, and\n        // finds the largest off-diagonal term, and then creates\n        // a matrix (result) which can be used to help reduce it\n\n        var tolerance = CesiumMath.EPSILON15;\n\n        var maxDiagonal = 0.0;\n        var rotAxis = 1;\n\n        // find pivot (rotAxis) based on max diagonal of matrix\n        for (var i = 0; i < 3; ++i) {\n            var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);\n            if (temp > maxDiagonal) {\n                rotAxis = i;\n                maxDiagonal = temp;\n            }\n        }\n\n        var c = 1.0;\n        var s = 0.0;\n\n        var p = rowVal[rotAxis];\n        var q = colVal[rotAxis];\n\n        if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n            var qq = matrix[Matrix3.getElementIndex(q, q)];\n            var pp = matrix[Matrix3.getElementIndex(p, p)];\n            var qp = matrix[Matrix3.getElementIndex(q, p)];\n\n            var tau = (qq - pp) / 2.0 / qp;\n            var t;\n\n            if (tau < 0.0) {\n                t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n            } else {\n                t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n            }\n\n            c = 1.0 / Math.sqrt(1.0 + t * t);\n            s = t * c;\n        }\n\n        result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n        result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;\n        result[Matrix3.getElementIndex(q, p)] = s;\n        result[Matrix3.getElementIndex(p, q)] = -s;\n\n        return result;\n    }\n\n    var jMatrix = new Matrix3();\n    var jMatrixTranspose = new Matrix3();\n\n    /**\n     * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n     * <p>\n     * Returns a diagonal matrix and unitary matrix such that:\n     * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n     * </p>\n     * <p>\n     * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n     * of the unitary matrix are the corresponding eigenvectors.\n     * </p>\n     *\n     * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n     * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n     * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n     *\n     * @example\n     * var a = //... symetric matrix\n     * var result = {\n     *     unitary : new Cesium.Matrix3(),\n     *     diagonal : new Cesium.Matrix3()\n     * };\n     * Cesium.Matrix3.computeEigenDecomposition(a, result);\n     *\n     * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n     * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n     * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n     *\n     * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n     * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n     * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n     */\n    Matrix3.computeEigenDecomposition = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        //>>includeEnd('debug');\n\n        // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n        // section 8.4.3 The Classical Jacobi Algorithm\n\n        var tolerance = CesiumMath.EPSILON20;\n        var maxSweeps = 10;\n\n        var count = 0;\n        var sweep = 0;\n\n        if (!defined(result)) {\n            result = {};\n        }\n\n        var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);\n        var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);\n\n        var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n        while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n            shurDecomposition(diagMatrix, jMatrix);\n            Matrix3.transpose(jMatrix, jMatrixTranspose);\n            Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n            Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n            Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n            if (++count > 2) {\n                ++sweep;\n                count = 0;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n     *\n     * @param {Matrix3} matrix The matrix with signed elements.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     */\n    Matrix3.abs = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = Math.abs(matrix[0]);\n        result[1] = Math.abs(matrix[1]);\n        result[2] = Math.abs(matrix[2]);\n        result[3] = Math.abs(matrix[3]);\n        result[4] = Math.abs(matrix[4]);\n        result[5] = Math.abs(matrix[5]);\n        result[6] = Math.abs(matrix[6]);\n        result[7] = Math.abs(matrix[7]);\n        result[8] = Math.abs(matrix[8]);\n\n        return result;\n    };\n\n    /**\n     * Computes the determinant of the provided matrix.\n     *\n     * @param {Matrix3} matrix The matrix to use.\n     * @returns {Number} The value of the determinant of the matrix.\n     */\n    Matrix3.determinant = function(matrix) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        //>>includeEnd('debug');\n\n        var m11 = matrix[0];\n        var m21 = matrix[3];\n        var m31 = matrix[6];\n        var m12 = matrix[1];\n        var m22 = matrix[4];\n        var m32 = matrix[7];\n        var m13 = matrix[2];\n        var m23 = matrix[5];\n        var m33 = matrix[8];\n\n        return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);\n    };\n\n    /**\n     * Computes the inverse of the provided matrix.\n     *\n     * @param {Matrix3} matrix The matrix to invert.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     *\n     * @exception {DeveloperError} matrix is not invertible.\n     */\n    Matrix3.inverse = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var m11 = matrix[0];\n        var m21 = matrix[1];\n        var m31 = matrix[2];\n        var m12 = matrix[3];\n        var m22 = matrix[4];\n        var m32 = matrix[5];\n        var m13 = matrix[6];\n        var m23 = matrix[7];\n        var m33 = matrix[8];\n\n        var determinant = Matrix3.determinant(matrix);\n\n        if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n            throw new DeveloperError('matrix is not invertible');\n        }\n\n        result[0] = m22 * m33 - m23 * m32;\n        result[1] = m23 * m31 - m21 * m33;\n        result[2] = m21 * m32 - m22 * m31;\n        result[3] = m13 * m32 - m12 * m33;\n        result[4] = m11 * m33 - m13 * m31;\n        result[5] = m12 * m31 - m11 * m32;\n        result[6] = m12 * m23 - m13 * m22;\n        result[7] = m13 * m21 - m11 * m23;\n        result[8] = m11 * m22 - m12 * m21;\n\n       var scale = 1.0 / determinant;\n       return Matrix3.multiplyByScalar(result, scale, result);\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix3} [left] The first matrix.\n     * @param {Matrix3} [right] The second matrix.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Matrix3.equals = function(left, right) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                left[0] === right[0] &&\n                left[1] === right[1] &&\n                left[2] === right[2] &&\n                left[3] === right[3] &&\n                left[4] === right[4] &&\n                left[5] === right[5] &&\n                left[6] === right[6] &&\n                left[7] === right[7] &&\n                left[8] === right[8]);\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix3} [left] The first matrix.\n     * @param {Matrix3} [right] The second matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Matrix3.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon must be a number');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n                (defined(left) &&\n                defined(right) &&\n                Math.abs(left[0] - right[0]) <= epsilon &&\n                Math.abs(left[1] - right[1]) <= epsilon &&\n                Math.abs(left[2] - right[2]) <= epsilon &&\n                Math.abs(left[3] - right[3]) <= epsilon &&\n                Math.abs(left[4] - right[4]) <= epsilon &&\n                Math.abs(left[5] - right[5]) <= epsilon &&\n                Math.abs(left[6] - right[6]) <= epsilon &&\n                Math.abs(left[7] - right[7]) <= epsilon &&\n                Math.abs(left[8] - right[8]) <= epsilon);\n    };\n\n    /**\n     * An immutable Matrix3 instance initialized to the identity matrix.\n     *\n     * @type {Matrix3}\n     * @constant\n     */\n    Matrix3.IDENTITY = freezeObject(new Matrix3(1.0, 0.0, 0.0,\n                                                0.0, 1.0, 0.0,\n                                                0.0, 0.0, 1.0));\n\n    /**\n     * An immutable Matrix3 instance initialized to the zero matrix.\n     *\n     * @type {Matrix3}\n     * @constant\n     */\n    Matrix3.ZERO = freezeObject(new Matrix3(0.0, 0.0, 0.0,\n                                            0.0, 0.0, 0.0,\n                                            0.0, 0.0, 0.0));\n\n    /**\n     * The index into Matrix3 for column 0, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN0ROW0 = 0;\n\n    /**\n     * The index into Matrix3 for column 0, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN0ROW1 = 1;\n\n    /**\n     * The index into Matrix3 for column 0, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN0ROW2 = 2;\n\n    /**\n     * The index into Matrix3 for column 1, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN1ROW0 = 3;\n\n    /**\n     * The index into Matrix3 for column 1, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN1ROW1 = 4;\n\n    /**\n     * The index into Matrix3 for column 1, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN1ROW2 = 5;\n\n    /**\n     * The index into Matrix3 for column 2, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN2ROW0 = 6;\n\n    /**\n     * The index into Matrix3 for column 2, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN2ROW1 = 7;\n\n    /**\n     * The index into Matrix3 for column 2, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix3.COLUMN2ROW2 = 8;\n\n    /**\n     * Duplicates the provided Matrix3 instance.\n     *\n     * @param {Matrix3} [result] The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n     */\n    Matrix3.prototype.clone = function(result) {\n        return Matrix3.clone(this, result);\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix3} [right] The right hand side matrix.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Matrix3.prototype.equals = function(right) {\n        return Matrix3.equals(this, right);\n    };\n\n    /**\n     * @private\n     */\n    Matrix3.equalsArray = function(matrix, array, offset) {\n        return matrix[0] === array[offset] &&\n               matrix[1] === array[offset + 1] &&\n               matrix[2] === array[offset + 2] &&\n               matrix[3] === array[offset + 3] &&\n               matrix[4] === array[offset + 4] &&\n               matrix[5] === array[offset + 5] &&\n               matrix[6] === array[offset + 6] &&\n               matrix[7] === array[offset + 7] &&\n               matrix[8] === array[offset + 8];\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix3} [right] The right hand side matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Matrix3.prototype.equalsEpsilon = function(right, epsilon) {\n        return Matrix3.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Creates a string representing this Matrix with each row being\n     * on a separate line and in the format '(column0, column1, column2)'.\n     *\n     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n     */\n    Matrix3.prototype.toString = function() {\n        return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\\n' +\n               '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\\n' +\n               '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';\n    };\n\n    return Matrix3;\n});\n",
    "\n/*global define*/\ndefine('Core/RuntimeError',[\n        './defined'\n    ], function(\n        defined) {\n    \"use strict\";\n\n    /**\n     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,\n     * out of memory, could not compile shader, etc.  If a function may throw this\n     * exception, the calling code should be prepared to catch it.\n     * <br /><br />\n     * On the other hand, a {@link DeveloperError} indicates an exception due\n     * to a developer error, e.g., invalid argument, that usually indicates a bug in the\n     * calling code.\n     *\n     * @alias RuntimeError\n     * @constructor\n     *\n     * @param {String} [message] The error message for this exception.\n     *\n     * @see DeveloperError\n     */\n    var RuntimeError = function(message) {\n        /**\n         * 'RuntimeError' indicating that this exception was thrown due to a runtime error.\n         * @type {String}\n         * @readonly\n         */\n        this.name = 'RuntimeError';\n\n        /**\n         * The explanation for why this exception was thrown.\n         * @type {String}\n         * @readonly\n         */\n        this.message = message;\n\n        //Browsers such as IE don't have a stack property until you actually throw the error.\n        var stack;\n        try {\n            throw new Error();\n        } catch (e) {\n            stack = e.stack;\n        }\n\n        /**\n         * The stack trace of this exception, if available.\n         * @type {String}\n         * @readonly\n         */\n        this.stack = stack;\n    };\n\n    RuntimeError.prototype.toString = function() {\n        var str = this.name + ': ' + this.message;\n\n        if (defined(this.stack)) {\n            str += '\\n' + this.stack.toString();\n        }\n\n        return str;\n    };\n\n    return RuntimeError;\n});\n",
    "\n/*global define*/\ndefine('Core/Matrix4',[\n        './Cartesian3',\n        './Cartesian4',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math',\n        './Matrix3',\n        './RuntimeError'\n    ], function(\n        Cartesian3,\n        Cartesian4,\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath,\n        Matrix3,\n        RuntimeError) {\n    \"use strict\";\n\n    /**\n     * A 4x4 matrix, indexable as a column-major order array.\n     * Constructor parameters are in row-major order for code readability.\n     * @alias Matrix4\n     * @constructor\n     *\n     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n     * @param {Number} [column3Row0=0.0] The value for column 3, row 0.\n     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n     * @param {Number} [column3Row1=0.0] The value for column 3, row 1.\n     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n     * @param {Number} [column3Row2=0.0] The value for column 3, row 2.\n     * @param {Number} [column0Row3=0.0] The value for column 0, row 3.\n     * @param {Number} [column1Row3=0.0] The value for column 1, row 3.\n     * @param {Number} [column2Row3=0.0] The value for column 2, row 3.\n     * @param {Number} [column3Row3=0.0] The value for column 3, row 3.\n     *\n     * @see Matrix4.fromColumnMajorArray\n     * @see Matrix4.fromRowMajorArray\n     * @see Matrix4.fromRotationTranslation\n     * @see Matrix4.fromTranslationQuaternionRotationScale\n     * @see Matrix4.fromTranslation\n     * @see Matrix4.fromScale\n     * @see Matrix4.fromUniformScale\n     * @see Matrix4.fromCamera\n     * @see Matrix4.computePerspectiveFieldOfView\n     * @see Matrix4.computeOrthographicOffCenter\n     * @see Matrix4.computePerspectiveOffCenter\n     * @see Matrix4.computeInfinitePerspectiveOffCenter\n     * @see Matrix4.computeViewportTransformation\n     * @see Matrix2\n     * @see Matrix3\n     * @see Packable\n     */\n    var Matrix4 = function(column0Row0, column1Row0, column2Row0, column3Row0,\n                           column0Row1, column1Row1, column2Row1, column3Row1,\n                           column0Row2, column1Row2, column2Row2, column3Row2,\n                           column0Row3, column1Row3, column2Row3, column3Row3) {\n        this[0] = defaultValue(column0Row0, 0.0);\n        this[1] = defaultValue(column0Row1, 0.0);\n        this[2] = defaultValue(column0Row2, 0.0);\n        this[3] = defaultValue(column0Row3, 0.0);\n        this[4] = defaultValue(column1Row0, 0.0);\n        this[5] = defaultValue(column1Row1, 0.0);\n        this[6] = defaultValue(column1Row2, 0.0);\n        this[7] = defaultValue(column1Row3, 0.0);\n        this[8] = defaultValue(column2Row0, 0.0);\n        this[9] = defaultValue(column2Row1, 0.0);\n        this[10] = defaultValue(column2Row2, 0.0);\n        this[11] = defaultValue(column2Row3, 0.0);\n        this[12] = defaultValue(column3Row0, 0.0);\n        this[13] = defaultValue(column3Row1, 0.0);\n        this[14] = defaultValue(column3Row2, 0.0);\n        this[15] = defaultValue(column3Row3, 0.0);\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Matrix4.packedLength = 16;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Matrix4} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Matrix4.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value[0];\n        array[startingIndex++] = value[1];\n        array[startingIndex++] = value[2];\n        array[startingIndex++] = value[3];\n        array[startingIndex++] = value[4];\n        array[startingIndex++] = value[5];\n        array[startingIndex++] = value[6];\n        array[startingIndex++] = value[7];\n        array[startingIndex++] = value[8];\n        array[startingIndex++] = value[9];\n        array[startingIndex++] = value[10];\n        array[startingIndex++] = value[11];\n        array[startingIndex++] = value[12];\n        array[startingIndex++] = value[13];\n        array[startingIndex++] = value[14];\n        array[startingIndex] = value[15];\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Matrix4} [result] The object into which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Matrix4();\n        }\n\n        result[0] = array[startingIndex++];\n        result[1] = array[startingIndex++];\n        result[2] = array[startingIndex++];\n        result[3] = array[startingIndex++];\n        result[4] = array[startingIndex++];\n        result[5] = array[startingIndex++];\n        result[6] = array[startingIndex++];\n        result[7] = array[startingIndex++];\n        result[8] = array[startingIndex++];\n        result[9] = array[startingIndex++];\n        result[10] = array[startingIndex++];\n        result[11] = array[startingIndex++];\n        result[12] = array[startingIndex++];\n        result[13] = array[startingIndex++];\n        result[14] = array[startingIndex++];\n        result[15] = array[startingIndex];\n        return result;\n    };\n\n    /**\n     * Duplicates a Matrix4 instance.\n     *\n     * @param {Matrix4} matrix The matrix to duplicate.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)\n     */\n    Matrix4.clone = function(matrix, result) {\n        if (!defined(matrix)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12],\n                               matrix[1], matrix[5], matrix[9], matrix[13],\n                               matrix[2], matrix[6], matrix[10], matrix[14],\n                               matrix[3], matrix[7], matrix[11], matrix[15]);\n        }\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n        result[4] = matrix[4];\n        result[5] = matrix[5];\n        result[6] = matrix[6];\n        result[7] = matrix[7];\n        result[8] = matrix[8];\n        result[9] = matrix[9];\n        result[10] = matrix[10];\n        result[11] = matrix[11];\n        result[12] = matrix[12];\n        result[13] = matrix[13];\n        result[14] = matrix[14];\n        result[15] = matrix[15];\n        return result;\n    };\n\n    /**\n     * Creates a Matrix4 from 16 consecutive elements in an array.\n     * @function\n     *\n     * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n     *\n     * @example\n     * // Create the Matrix4:\n     * // [1.0, 2.0, 3.0, 4.0]\n     * // [1.0, 2.0, 3.0, 4.0]\n     * // [1.0, 2.0, 3.0, 4.0]\n     * // [1.0, 2.0, 3.0, 4.0]\n     *\n     * var v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n     * var m = Cesium.Matrix4.fromArray(v);\n     *\n     * // Create same Matrix4 with using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n     * var m2 = Cesium.Matrix4.fromArray(v2, 2);\n     */\n    Matrix4.fromArray = Matrix4.unpack;\n\n    /**\n     * Computes a Matrix4 instance from a column-major order array.\n     *\n     * @param {Number[]} values The column-major order array.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.fromColumnMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values is required');\n        }\n        //>>includeEnd('debug');\n\n        return Matrix4.clone(values, result);\n    };\n\n    /**\n     * Computes a Matrix4 instance from a row-major order array.\n     * The resulting matrix will be in column-major order.\n     *\n     * @param {Number[]} values The row-major order array.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.fromRowMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix4(values[0], values[1], values[2], values[3],\n                               values[4], values[5], values[6], values[7],\n                               values[8], values[9], values[10], values[11],\n                               values[12], values[13], values[14], values[15]);\n        }\n        result[0] = values[0];\n        result[1] = values[4];\n        result[2] = values[8];\n        result[3] = values[12];\n        result[4] = values[1];\n        result[5] = values[5];\n        result[6] = values[9];\n        result[7] = values[13];\n        result[8] = values[2];\n        result[9] = values[6];\n        result[10] = values[10];\n        result[11] = values[14];\n        result[12] = values[3];\n        result[13] = values[7];\n        result[14] = values[11];\n        result[15] = values[15];\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance from a Matrix3 representing the rotation\n     * and a Cartesian3 representing the translation.\n     *\n     * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.\n     * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.fromRotationTranslation = function(rotation, translation, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rotation)) {\n            throw new DeveloperError('rotation is required.');\n        }\n        //>>includeEnd('debug');\n\n        translation = defaultValue(translation, Cartesian3.ZERO);\n\n        if (!defined(result)) {\n            return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x,\n                               rotation[1], rotation[4], rotation[7], translation.y,\n                               rotation[2], rotation[5], rotation[8], translation.z,\n                                       0.0,         0.0,         0.0,           1.0);\n        }\n\n        result[0] = rotation[0];\n        result[1] = rotation[1];\n        result[2] = rotation[2];\n        result[3] = 0.0;\n        result[4] = rotation[3];\n        result[5] = rotation[4];\n        result[6] = rotation[5];\n        result[7] = 0.0;\n        result[8] = rotation[6];\n        result[9] = rotation[7];\n        result[10] = rotation[8];\n        result[11] = 0.0;\n        result[12] = translation.x;\n        result[13] = translation.y;\n        result[14] = translation.z;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)\n     * representation with the rotation represented as a quaternion.\n     *\n     * @param {Cartesian3} translation The translation transformation.\n     * @param {Quaternion} rotation The rotation transformation.\n     * @param {Cartesian3} scale The non-uniform scale transformation.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     *\n     * @example\n     * var result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n     *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n     *   Cesium.Quaternion.IDENTITY,           // rotation\n     *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n     *   result);\n     */\n    Matrix4.fromTranslationQuaternionRotationScale = function(translation, rotation, scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(translation)) {\n            throw new DeveloperError('translation is required.');\n        }\n        if (!defined(rotation)) {\n            throw new DeveloperError('rotation is required.');\n        }\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Matrix4();\n        }\n\n        var scaleX = scale.x;\n        var scaleY = scale.y;\n        var scaleZ = scale.z;\n\n        var x2 = rotation.x * rotation.x;\n        var xy = rotation.x * rotation.y;\n        var xz = rotation.x * rotation.z;\n        var xw = rotation.x * rotation.w;\n        var y2 = rotation.y * rotation.y;\n        var yz = rotation.y * rotation.z;\n        var yw = rotation.y * rotation.w;\n        var z2 = rotation.z * rotation.z;\n        var zw = rotation.z * rotation.w;\n        var w2 = rotation.w * rotation.w;\n\n        var m00 = x2 - y2 - z2 + w2;\n        var m01 = 2.0 * (xy - zw);\n        var m02 = 2.0 * (xz + yw);\n\n        var m10 = 2.0 * (xy + zw);\n        var m11 = -x2 + y2 - z2 + w2;\n        var m12 = 2.0 * (yz - xw);\n\n        var m20 = 2.0 * (xz - yw);\n        var m21 = 2.0 * (yz + xw);\n        var m22 = -x2 - y2 + z2 + w2;\n\n        result[0]  = m00 * scaleX;\n        result[1]  = m10 * scaleX;\n        result[2]  = m20 * scaleX;\n        result[3]  = 0.0;\n        result[4]  = m01 * scaleY;\n        result[5]  = m11 * scaleY;\n        result[6]  = m21 * scaleY;\n        result[7]  = 0.0;\n        result[8]  = m02 * scaleZ;\n        result[9]  = m12 * scaleZ;\n        result[10] = m22 * scaleZ;\n        result[11] = 0.0;\n        result[12] = translation.x;\n        result[13] = translation.y;\n        result[14] = translation.z;\n        result[15] = 1.0;\n\n        return result;\n    };\n\n    /**\n     * Creates a Matrix4 instance from a Cartesian3 representing the translation.\n     *\n     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     *\n     * @see Matrix4.multiplyByTranslation\n     */\n    Matrix4.fromTranslation = function(translation, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(translation)) {\n            throw new DeveloperError('translation is required.');\n        }\n        //>>includeEnd('debug');\n\n        return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);\n    };\n\n    /**\n     * Computes a Matrix4 instance representing a non-uniform scale.\n     *\n     * @param {Cartesian3} scale The x, y, and z scale factors.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [7.0, 0.0, 0.0, 0.0]\n     * //   [0.0, 8.0, 0.0, 0.0]\n     * //   [0.0, 0.0, 9.0, 0.0]\n     * //   [0.0, 0.0, 0.0, 1.0]\n     * var m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n     */\n    Matrix4.fromScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix4(\n                scale.x, 0.0,     0.0,     0.0,\n                0.0,     scale.y, 0.0,     0.0,\n                0.0,     0.0,     scale.z, 0.0,\n                0.0,     0.0,     0.0,     1.0);\n        }\n\n        result[0] = scale.x;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = scale.y;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 0.0;\n        result[9] = 0.0;\n        result[10] = scale.z;\n        result[11] = 0.0;\n        result[12] = 0.0;\n        result[13] = 0.0;\n        result[14] = 0.0;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance representing a uniform scale.\n     *\n     * @param {Number} scale The uniform scale factor.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [2.0, 0.0, 0.0, 0.0]\n     * //   [0.0, 2.0, 0.0, 0.0]\n     * //   [0.0, 0.0, 2.0, 0.0]\n     * //   [0.0, 0.0, 0.0, 1.0]\n     * var m = Cesium.Matrix4.fromUniformScale(2.0);\n     */\n    Matrix4.fromUniformScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof scale !== 'number') {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix4(scale, 0.0,   0.0,   0.0,\n                               0.0,   scale, 0.0,   0.0,\n                               0.0,   0.0,   scale, 0.0,\n                               0.0,   0.0,   0.0,   1.0);\n        }\n\n        result[0] = scale;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = scale;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 0.0;\n        result[9] = 0.0;\n        result[10] = scale;\n        result[11] = 0.0;\n        result[12] = 0.0;\n        result[13] = 0.0;\n        result[14] = 0.0;\n        result[15] = 1.0;\n        return result;\n    };\n\n    var fromCameraF = new Cartesian3();\n    var fromCameraS = new Cartesian3();\n    var fromCameraU = new Cartesian3();\n\n    /**\n     * Computes a Matrix4 instance from a Camera.\n     *\n     * @param {Camera} camera The camera to use.\n     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.fromCamera = function(camera, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(camera)) {\n            throw new DeveloperError('camera is required.');\n        }\n        //>>includeEnd('debug');\n\n        var eye = camera.eye;\n        var target = camera.target;\n        var up = camera.up;\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(eye)) {\n            throw new DeveloperError('camera.eye is required.');\n        }\n        if (!defined(target)) {\n            throw new DeveloperError('camera.target is required.');\n        }\n        if (!defined(up)) {\n            throw new DeveloperError('camera.up is required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian3.normalize(Cartesian3.subtract(target, eye, fromCameraF), fromCameraF);\n        Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraS), fromCameraS);\n        Cartesian3.normalize(Cartesian3.cross(fromCameraS, fromCameraF, fromCameraU), fromCameraU);\n\n        var sX = fromCameraS.x;\n        var sY = fromCameraS.y;\n        var sZ = fromCameraS.z;\n        var fX = fromCameraF.x;\n        var fY = fromCameraF.y;\n        var fZ = fromCameraF.z;\n        var uX = fromCameraU.x;\n        var uY = fromCameraU.y;\n        var uZ = fromCameraU.z;\n        var eyeX = eye.x;\n        var eyeY = eye.y;\n        var eyeZ = eye.z;\n        var t0 = sX * -eyeX + sY * -eyeY+ sZ * -eyeZ;\n        var t1 = uX * -eyeX + uY * -eyeY+ uZ * -eyeZ;\n        var t2 = fX * eyeX + fY * eyeY + fZ * eyeZ;\n\n        //The code below this comment is an optimized\n        //version of the commented lines.\n        //Rather that create two matrices and then multiply,\n        //we just bake in the multiplcation as part of creation.\n        //var rotation = new Matrix4(\n        //                sX,  sY,  sZ, 0.0,\n        //                uX,  uY,  uZ, 0.0,\n        //               -fX, -fY, -fZ, 0.0,\n        //                0.0,  0.0,  0.0, 1.0);\n        //var translation = new Matrix4(\n        //                1.0, 0.0, 0.0, -eye.x,\n        //                0.0, 1.0, 0.0, -eye.y,\n        //                0.0, 0.0, 1.0, -eye.z,\n        //                0.0, 0.0, 0.0, 1.0);\n        //return rotation.multiply(translation);\n        if (!defined(result)) {\n            return new Matrix4(\n                    sX,   sY,  sZ, t0,\n                    uX,   uY,  uZ, t1,\n                   -fX,  -fY, -fZ, t2,\n                    0.0, 0.0, 0.0, 1.0);\n        }\n        result[0] = sX;\n        result[1] = uX;\n        result[2] = -fX;\n        result[3] = 0.0;\n        result[4] = sY;\n        result[5] = uY;\n        result[6] = -fY;\n        result[7] = 0.0;\n        result[8] = sZ;\n        result[9] = uZ;\n        result[10] = -fZ;\n        result[11] = 0.0;\n        result[12] = t0;\n        result[13] = t1;\n        result[14] = t2;\n        result[15] = 1.0;\n        return result;\n\n    };\n\n     /**\n      * Computes a Matrix4 instance representing a perspective transformation matrix.\n      *\n      * @param {Number} fovY The field of view along the Y axis in radians.\n      * @param {Number} aspectRatio The aspect ratio.\n      * @param {Number} near The distance to the near plane in meters.\n      * @param {Number} far The distance to the far plane in meters.\n      * @param {Matrix4} result The object in which the result will be stored.\n      * @returns {Matrix4} The modified result parameter.\n      *\n      * @exception {DeveloperError} fovY must be in [0, PI).\n      * @exception {DeveloperError} aspectRatio must be greater than zero.\n      * @exception {DeveloperError} near must be greater than zero.\n      * @exception {DeveloperError} far must be greater than zero.\n      */\n    Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (fovY <= 0.0 || fovY > Math.PI) {\n            throw new DeveloperError('fovY must be in [0, PI).');\n        }\n        if (aspectRatio <= 0.0) {\n            throw new DeveloperError('aspectRatio must be greater than zero.');\n        }\n        if (near <= 0.0) {\n            throw new DeveloperError('near must be greater than zero.');\n        }\n        if (far <= 0.0) {\n            throw new DeveloperError('far must be greater than zero.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var bottom = Math.tan(fovY * 0.5);\n\n        var column1Row1 = 1.0 / bottom;\n        var column0Row0 = column1Row1 / aspectRatio;\n        var column2Row2 = (far + near) / (near - far);\n        var column3Row2 = (2.0 * far * near) / (near - far);\n\n        result[0] = column0Row0;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = column1Row1;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 0.0;\n        result[9] = 0.0;\n        result[10] = column2Row2;\n        result[11] = -1.0;\n        result[12] = 0.0;\n        result[13] = 0.0;\n        result[14] = column3Row2;\n        result[15] = 0.0;\n        return result;\n    };\n\n    /**\n    * Computes a Matrix4 instance representing an orthographic transformation matrix.\n    *\n    * @param {Number} left The number of meters to the left of the camera that will be in view.\n    * @param {Number} right The number of meters to the right of the camera that will be in view.\n    * @param {Number} bottom The number of meters below of the camera that will be in view.\n    * @param {Number} top The number of meters above of the camera that will be in view.\n    * @param {Number} near The distance to the near plane in meters.\n    * @param {Number} far The distance to the far plane in meters.\n    * @param {Matrix4} result The object in which the result will be stored.\n    * @returns {Matrix4} The modified result parameter.\n    */\n    Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        if (!defined(bottom)) {\n            throw new DeveloperError('bottom is required.');\n        }\n        if (!defined(top)) {\n            throw new DeveloperError('top is required.');\n        }\n        if (!defined(near)) {\n            throw new DeveloperError('near is required.');\n        }\n        if (!defined(far)) {\n            throw new DeveloperError('far is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var a = 1.0 / (right - left);\n        var b = 1.0 / (top - bottom);\n        var c = 1.0 / (far - near);\n\n        var tx = -(right + left) * a;\n        var ty = -(top + bottom) * b;\n        var tz = -(far + near) * c;\n        a *= 2.0;\n        b *= 2.0;\n        c *= -2.0;\n\n        result[0] = a;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = b;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 0.0;\n        result[9] = 0.0;\n        result[10] = c;\n        result[11] = 0.0;\n        result[12] = tx;\n        result[13] = ty;\n        result[14] = tz;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance representing an off center perspective transformation.\n     *\n     * @param {Number} left The number of meters to the left of the camera that will be in view.\n     * @param {Number} right The number of meters to the right of the camera that will be in view.\n     * @param {Number} bottom The number of meters below of the camera that will be in view.\n     * @param {Number} top The number of meters above of the camera that will be in view.\n     * @param {Number} near The distance to the near plane in meters.\n     * @param {Number} far The distance to the far plane in meters.\n     * @param {Matrix4} result The object in which the result will be stored.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        if (!defined(bottom)) {\n            throw new DeveloperError('bottom is required.');\n        }\n        if (!defined(top)) {\n            throw new DeveloperError('top is required.');\n        }\n        if (!defined(near)) {\n            throw new DeveloperError('near is required.');\n        }\n        if (!defined(far)) {\n            throw new DeveloperError('far is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = 2.0 * near / (right - left);\n        var column1Row1 = 2.0 * near / (top - bottom);\n        var column2Row0 = (right + left) / (right - left);\n        var column2Row1 = (top + bottom) / (top - bottom);\n        var column2Row2 = -(far + near) / (far - near);\n        var column2Row3 = -1.0;\n        var column3Row2 = -2.0 * far * near / (far - near);\n\n        result[0] = column0Row0;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = column1Row1;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = column2Row0;\n        result[9] = column2Row1;\n        result[10] = column2Row2;\n        result[11] = column2Row3;\n        result[12] = 0.0;\n        result[13] = 0.0;\n        result[14] = column3Row2;\n        result[15] = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance representing an infinite off center perspective transformation.\n     *\n     * @param {Number} left The number of meters to the left of the camera that will be in view.\n     * @param {Number} right The number of meters to the right of the camera that will be in view.\n     * @param {Number} bottom The number of meters below of the camera that will be in view.\n     * @param {Number} top The number of meters above of the camera that will be in view.\n     * @param {Number} near The distance to the near plane in meters.\n     * @param {Number} far The distance to the far plane in meters.\n     * @param {Matrix4} result The object in which the result will be stored.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        if (!defined(bottom)) {\n            throw new DeveloperError('bottom is required.');\n        }\n        if (!defined(top)) {\n            throw new DeveloperError('top is required.');\n        }\n        if (!defined(near)) {\n            throw new DeveloperError('near is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = 2.0 * near / (right - left);\n        var column1Row1 = 2.0 * near / (top - bottom);\n        var column2Row0 = (right + left) / (right - left);\n        var column2Row1 = (top + bottom) / (top - bottom);\n        var column2Row2 = -1.0;\n        var column2Row3 = -1.0;\n        var column3Row2 = -2.0 * near;\n\n        result[0] = column0Row0;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = column1Row1;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = column2Row0;\n        result[9] = column2Row1;\n        result[10] = column2Row2;\n        result[11] = column2Row3;\n        result[12] = 0.0;\n        result[13] = 0.0;\n        result[14] = column3Row2;\n        result[15] = 0.0;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.\n     *\n     * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.\n     * @param {Number}[nearDepthRange=0.0] The near plane distance in window coordinates.\n     * @param {Number}[farDepthRange=1.0] The far plane distance in window coordinates.\n     * @param {Matrix4} result The object in which the result will be stored.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * // Create viewport transformation using an explicit viewport and depth range.\n     * var m = Cesium.Matrix4.computeViewportTransformation({\n     *     x : 0.0,\n     *     y : 0.0,\n     *     width : 1024.0,\n     *     height : 768.0\n     * }, 0.0, 1.0, new Cesium.Matrix4());\n     */\n    Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);\n        var x = defaultValue(viewport.x, 0.0);\n        var y = defaultValue(viewport.y, 0.0);\n        var width = defaultValue(viewport.width, 0.0);\n        var height = defaultValue(viewport.height, 0.0);\n        nearDepthRange = defaultValue(nearDepthRange, 0.0);\n        farDepthRange = defaultValue(farDepthRange, 1.0);\n\n        var halfWidth = width * 0.5;\n        var halfHeight = height * 0.5;\n        var halfDepth = (farDepthRange - nearDepthRange) * 0.5;\n\n        var column0Row0 = halfWidth;\n        var column1Row1 = halfHeight;\n        var column2Row2 = halfDepth;\n        var column3Row0 = x + halfWidth;\n        var column3Row1 = y + halfHeight;\n        var column3Row2 = nearDepthRange + halfDepth;\n        var column3Row3 = 1.0;\n\n        result[0] = column0Row0;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = 0.0;\n        result[4] = 0.0;\n        result[5] = column1Row1;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 0.0;\n        result[9] = 0.0;\n        result[10] = column2Row2;\n        result[11] = 0.0;\n        result[12] = column3Row0;\n        result[13] = column3Row1;\n        result[14] = column3Row2;\n        result[15] = column3Row3;\n        return result;\n    };\n\n    /**\n     * Computes an Array from the provided Matrix4 instance.\n     * The array will be in column-major order.\n     *\n     * @param {Matrix4} matrix The matrix to use..\n     * @param {Number[]} [result] The Array onto which to store the result.\n     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n     *\n     * @example\n     * //create an array from an instance of Matrix4\n     * // m = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     * var a = Cesium.Matrix4.toArray(m);\n     *\n     * // m remains the same\n     * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]\n     */\n    Matrix4.toArray = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return [matrix[0], matrix[1], matrix[2], matrix[3],\n                    matrix[4], matrix[5], matrix[6], matrix[7],\n                    matrix[8], matrix[9], matrix[10], matrix[11],\n                    matrix[12], matrix[13], matrix[14], matrix[15]];\n        }\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n        result[4] = matrix[4];\n        result[5] = matrix[5];\n        result[6] = matrix[6];\n        result[7] = matrix[7];\n        result[8] = matrix[8];\n        result[9] = matrix[9];\n        result[10] = matrix[10];\n        result[11] = matrix[11];\n        result[12] = matrix[12];\n        result[13] = matrix[13];\n        result[14] = matrix[14];\n        result[15] = matrix[15];\n        return result;\n    };\n\n    /**\n     * Computes the array index of the element at the provided row and column.\n     *\n     * @param {Number} row The zero-based index of the row.\n     * @param {Number} column The zero-based index of the column.\n     * @returns {Number} The index of the element at the provided row and column.\n     *\n     * @exception {DeveloperError} row must be 0, 1, 2, or 3.\n     * @exception {DeveloperError} column must be 0, 1, 2, or 3.\n     *\n     * @example\n     * var myMatrix = new Cesium.Matrix4();\n     * var column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n     * var column1Row0 = myMatrix[column1Row0Index];\n     * myMatrix[column1Row0Index] = 10.0;\n     */\n    Matrix4.getElementIndex = function(column, row) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof row !== 'number' || row < 0 || row > 3) {\n            throw new DeveloperError('row must be 0, 1, 2, or 3.');\n        }\n        if (typeof column !== 'number' || column < 0 || column > 3) {\n            throw new DeveloperError('column must be 0, 1, 2, or 3.');\n        }\n        //>>includeEnd('debug');\n\n        return column * 4 + row;\n    };\n\n    /**\n     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to retrieve.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n     *\n     * @example\n     * //returns a Cartesian4 instance with values from the specified column\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * //Example 1: Creates an instance of Cartesian\n     * var a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n     *\n     * @example\n     * //Example 2: Sets values for Cartesian instance\n     * var a = new Cesium.Cartesian4();\n     * Cesium.Matrix4.getColumn(m, 2, a);\n     *\n     * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;\n     */\n    Matrix4.getColumn = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n\n        if (typeof index !== 'number' || index < 0 || index > 3) {\n            throw new DeveloperError('index must be 0, 1, 2, or 3.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var startIndex = index * 4;\n        var x = matrix[startIndex];\n        var y = matrix[startIndex + 1];\n        var z = matrix[startIndex + 2];\n        var w = matrix[startIndex + 3];\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to set.\n     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n     *\n     * @example\n     * //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * var a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n     *\n     * // m remains the same\n     * // a = [10.0, 11.0, 99.0, 13.0]\n     * //     [14.0, 15.0, 98.0, 17.0]\n     * //     [18.0, 19.0, 97.0, 21.0]\n     * //     [22.0, 23.0, 96.0, 25.0]\n     */\n    Matrix4.setColumn = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 3) {\n            throw new DeveloperError('index must be 0, 1, 2, or 3.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix4.clone(matrix, result);\n        var startIndex = index * 4;\n        result[startIndex] = cartesian.x;\n        result[startIndex + 1] = cartesian.y;\n        result[startIndex + 2] = cartesian.z;\n        result[startIndex + 3] = cartesian.w;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the translation in the rightmost column of the provided\n     * matrix with the provided translation.  This assumes the matrix is an affine transformation\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.setTranslation = function(matrix, translation, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(translation)) {\n            throw new DeveloperError('translation is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n\n        result[4] = matrix[4];\n        result[5] = matrix[5];\n        result[6] = matrix[6];\n        result[7] = matrix[7];\n\n        result[8] = matrix[8];\n        result[9] = matrix[9];\n        result[10] = matrix[10];\n        result[11] = matrix[11];\n\n        result[12] = translation.x;\n        result[13] = translation.y;\n        result[14] = translation.z;\n        result[15] = matrix[15];\n\n        return result;\n    };\n\n    /**\n     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to retrieve.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n     *\n     * @example\n     * //returns a Cartesian4 instance with values from the specified column\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * //Example 1: Returns an instance of Cartesian\n     * var a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n     *\n     * @example\n     * //Example 2: Sets values for a Cartesian instance\n     * var a = new Cesium.Cartesian4();\n     * Cesium.Matrix4.getRow(m, 2, a);\n     *\n     * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;\n     */\n    Matrix4.getRow = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n\n        if (typeof index !== 'number' || index < 0 || index > 3) {\n            throw new DeveloperError('index must be 0, 1, 2, or 3.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = matrix[index];\n        var y = matrix[index + 4];\n        var z = matrix[index + 8];\n        var w = matrix[index + 12];\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to set.\n     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n     *\n     * @example\n     * //create a new Matrix4 instance with new row values from the Cartesian4 instance\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * var a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n     *\n     * // m remains the same\n     * // a = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [99.0, 98.0, 97.0, 96.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     */\n    Matrix4.setRow = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 3) {\n            throw new DeveloperError('index must be 0, 1, 2, or 3.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix4.clone(matrix, result);\n        result[index] = cartesian.x;\n        result[index + 4] = cartesian.y;\n        result[index + 8] = cartesian.z;\n        result[index + 12] = cartesian.w;\n        return result;\n    };\n\n    var scratchColumn = new Cartesian3();\n\n    /**\n     * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter\n     */\n    Matrix4.getScale = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));\n        result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));\n        result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));\n        return result;\n    };\n\n    var scratchScale = new Cartesian3();\n\n    /**\n     * Computes the maximum scale assuming the matrix is an affine transformation.\n     * The maximum scale is the maximum length of the column vectors in the upper-left\n     * 3x3 matrix.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @returns {Number} The maximum scale.\n     */\n    Matrix4.getMaximumScale = function(matrix) {\n        Matrix4.getScale(matrix, scratchScale);\n        return Cartesian3.maximumComponent(scratchScale);\n    };\n\n    /**\n     * Computes the product of two matrices.\n     *\n     * @param {Matrix4} left The first matrix.\n     * @param {Matrix4} right The second matrix.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.multiply = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var left0 = left[0];\n        var left1 = left[1];\n        var left2 = left[2];\n        var left3 = left[3];\n        var left4 = left[4];\n        var left5 = left[5];\n        var left6 = left[6];\n        var left7 = left[7];\n        var left8 = left[8];\n        var left9 = left[9];\n        var left10 = left[10];\n        var left11 = left[11];\n        var left12 = left[12];\n        var left13 = left[13];\n        var left14 = left[14];\n        var left15 = left[15];\n\n        var right0 = right[0];\n        var right1 = right[1];\n        var right2 = right[2];\n        var right3 = right[3];\n        var right4 = right[4];\n        var right5 = right[5];\n        var right6 = right[6];\n        var right7 = right[7];\n        var right8 = right[8];\n        var right9 = right[9];\n        var right10 = right[10];\n        var right11 = right[11];\n        var right12 = right[12];\n        var right13 = right[13];\n        var right14 = right[14];\n        var right15 = right[15];\n\n        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;\n        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;\n        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;\n        var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;\n\n        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;\n        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;\n        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;\n        var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;\n\n        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;\n        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;\n        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;\n        var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;\n\n        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;\n        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;\n        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;\n        var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column0Row2;\n        result[3] = column0Row3;\n        result[4] = column1Row0;\n        result[5] = column1Row1;\n        result[6] = column1Row2;\n        result[7] = column1Row3;\n        result[8] = column2Row0;\n        result[9] = column2Row1;\n        result[10] = column2Row2;\n        result[11] = column2Row3;\n        result[12] = column3Row0;\n        result[13] = column3Row1;\n        result[14] = column3Row2;\n        result[15] = column3Row3;\n        return result;\n    };\n\n    /**\n     * Computes the sum of two matrices.\n     *\n     * @param {Matrix4} left The first matrix.\n     * @param {Matrix4} right The second matrix.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] + right[0];\n        result[1] = left[1] + right[1];\n        result[2] = left[2] + right[2];\n        result[3] = left[3] + right[3];\n        result[4] = left[4] + right[4];\n        result[5] = left[5] + right[5];\n        result[6] = left[6] + right[6];\n        result[7] = left[7] + right[7];\n        result[8] = left[8] + right[8];\n        result[9] = left[9] + right[9];\n        result[10] = left[10] + right[10];\n        result[11] = left[11] + right[11];\n        result[12] = left[12] + right[12];\n        result[13] = left[13] + right[13];\n        result[14] = left[14] + right[14];\n        result[15] = left[15] + right[15];\n        return result;\n    };\n\n    /**\n     * Computes the difference of two matrices.\n     *\n     * @param {Matrix4} left The first matrix.\n     * @param {Matrix4} right The second matrix.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] - right[0];\n        result[1] = left[1] - right[1];\n        result[2] = left[2] - right[2];\n        result[3] = left[3] - right[3];\n        result[4] = left[4] - right[4];\n        result[5] = left[5] - right[5];\n        result[6] = left[6] - right[6];\n        result[7] = left[7] - right[7];\n        result[8] = left[8] - right[8];\n        result[9] = left[9] - right[9];\n        result[10] = left[10] - right[10];\n        result[11] = left[11] - right[11];\n        result[12] = left[12] - right[12];\n        result[13] = left[13] - right[13];\n        result[14] = left[14] - right[14];\n        result[15] = left[15] - right[15];\n        return result;\n    };\n\n    /**\n     * Computes the product of two matrices assuming the matrices are\n     * affine transformation matrices, where the upper left 3x3 elements\n     * are a rotation matrix, and the upper three elements in the fourth\n     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n     * The matrix is not verified to be in the proper form.\n     * This method is faster than computing the product for general 4x4\n     * matrices using {@link Matrix4.multiply}.\n     *\n     * @param {Matrix4} left The first matrix.\n     * @param {Matrix4} right The second matrix.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * var m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n     * var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n     * var m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());\n     */\n    Matrix4.multiplyTransformation = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var left0 = left[0];\n        var left1 = left[1];\n        var left2 = left[2];\n        var left4 = left[4];\n        var left5 = left[5];\n        var left6 = left[6];\n        var left8 = left[8];\n        var left9 = left[9];\n        var left10 = left[10];\n        var left12 = left[12];\n        var left13 = left[13];\n        var left14 = left[14];\n\n        var right0 = right[0];\n        var right1 = right[1];\n        var right2 = right[2];\n        var right4 = right[4];\n        var right5 = right[5];\n        var right6 = right[6];\n        var right8 = right[8];\n        var right9 = right[9];\n        var right10 = right[10];\n        var right12 = right[12];\n        var right13 = right[13];\n        var right14 = right[14];\n\n        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;\n        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;\n        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column0Row2;\n        result[3] = 0.0;\n        result[4] = column1Row0;\n        result[5] = column1Row1;\n        result[6] = column1Row2;\n        result[7] = 0.0;\n        result[8] = column2Row0;\n        result[9] = column2Row1;\n        result[10] = column2Row2;\n        result[11] = 0.0;\n        result[12] = column3Row0;\n        result[13] = column3Row1;\n        result[14] = column3Row2;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n     * by a 3x3 rotation matrix.  This is an optimization\n     * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.\n     *\n     * @param {Matrix4} matrix The matrix on the left-hand side.\n     * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n     * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);\n     */\n    Matrix4.multiplyByMatrix3 = function(matrix, rotation, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(rotation)) {\n            throw new DeveloperError('rotation is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var left0 = matrix[0];\n        var left1 = matrix[1];\n        var left2 = matrix[2];\n        var left4 = matrix[4];\n        var left5 = matrix[5];\n        var left6 = matrix[6];\n        var left8 = matrix[8];\n        var left9 = matrix[9];\n        var left10 = matrix[10];\n\n        var right0 = rotation[0];\n        var right1 = rotation[1];\n        var right2 = rotation[2];\n        var right4 = rotation[3];\n        var right5 = rotation[4];\n        var right6 = rotation[5];\n        var right8 = rotation[6];\n        var right9 = rotation[7];\n        var right10 = rotation[8];\n\n        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column0Row2;\n        result[3] = 0.0;\n        result[4] = column1Row0;\n        result[5] = column1Row1;\n        result[6] = column1Row2;\n        result[7] = 0.0;\n        result[8] = column2Row0;\n        result[9] = column2Row1;\n        result[10] = column2Row2;\n        result[11] = 0.0;\n        result[12] = matrix[12];\n        result[13] = matrix[13];\n        result[14] = matrix[14];\n        result[15] = matrix[15];\n        return result;\n    };\n\n    /**\n     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n     * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization\n     * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.\n     *\n     * @param {Matrix4} matrix The matrix on the left-hand side.\n     * @param {Cartesian3} translation The translation on the right-hand side.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n     * Cesium.Matrix4.multiplyByTranslation(m, position, m);\n     */\n    Matrix4.multiplyByTranslation = function(matrix, translation, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(translation)) {\n            throw new DeveloperError('translation is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = translation.x;\n        var y = translation.y;\n        var z = translation.z;\n\n        var tx = (x * matrix[0]) + (y * matrix[4]) + (z * matrix[8]) + matrix[12];\n        var ty = (x * matrix[1]) + (y * matrix[5]) + (z * matrix[9]) + matrix[13];\n        var tz = (x * matrix[2]) + (y * matrix[6]) + (z * matrix[10]) + matrix[14];\n\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n        result[4] = matrix[4];\n        result[5] = matrix[5];\n        result[6] = matrix[6];\n        result[7] = matrix[7];\n        result[8] = matrix[8];\n        result[9] = matrix[9];\n        result[10] = matrix[10];\n        result[11] = matrix[11];\n        result[12] = tx;\n        result[13] = ty;\n        result[14] = tz;\n        result[15] = matrix[15];\n        return result;\n    };\n\n    var uniformScaleScratch = new Cartesian3();\n\n    /**\n     * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n     * by an implicit uniform scale matrix.  This is an optimization\n     * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n     * <code>m</code> must be an affine matrix.\n     * This function performs fewer allocations and arithmetic operations.\n     *\n     * @param {Matrix4} matrix The affine matrix on the left-hand side.\n     * @param {Number} scale The uniform scale on the right-hand side.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @see Matrix4.fromUniformScale\n     * @see Matrix4.multiplyByScale\n     *\n     * @example\n     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n     * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n     */\n    Matrix4.multiplyByUniformScale = function(matrix, scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (typeof scale !== 'number') {\n            throw new DeveloperError('scale is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        uniformScaleScratch.x = scale;\n        uniformScaleScratch.y = scale;\n        uniformScaleScratch.z = scale;\n        return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);\n    };\n\n    /**\n     * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n     * by an implicit non-uniform scale matrix.  This is an optimization\n     * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n     * <code>m</code> must be an affine matrix.\n     * This function performs fewer allocations and arithmetic operations.\n     *\n     * @param {Matrix4} matrix The affine matrix on the left-hand side.\n     * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @see Matrix4.fromScale\n     * @see Matrix4.multiplyByUniformScale\n     *\n     * @example\n     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n     * Cesium.Matrix4.multiplyByScale(m, scale, m);\n     */\n    Matrix4.multiplyByScale = function(matrix, scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var scaleX = scale.x;\n        var scaleY = scale.y;\n        var scaleZ = scale.z;\n\n        // Faster than Cartesian3.equals\n        if ((scaleX === 1.0) && (scaleY === 1.0) && (scaleZ === 1.0)) {\n            return Matrix4.clone(matrix, result);\n        }\n\n        result[0] = scaleX * matrix[0];\n        result[1] = scaleX * matrix[1];\n        result[2] = scaleX * matrix[2];\n        result[3] = 0.0;\n        result[4] = scaleY * matrix[4];\n        result[5] = scaleY * matrix[5];\n        result[6] = scaleY * matrix[6];\n        result[7] = 0.0;\n        result[8] = scaleZ * matrix[8];\n        result[9] = scaleZ * matrix[9];\n        result[10] = scaleZ * matrix[10];\n        result[11] = 0.0;\n        result[12] = matrix[12];\n        result[13] = matrix[13];\n        result[14] = matrix[14];\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a column vector.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @param {Cartesian4} cartesian The vector.\n     * @param {Cartesian4} result The object onto which to store the result.\n     * @returns {Cartesian4} The modified result parameter.\n     */\n    Matrix4.multiplyByVector = function(matrix, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var vX = cartesian.x;\n        var vY = cartesian.y;\n        var vZ = cartesian.z;\n        var vW = cartesian.w;\n\n        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;\n        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;\n        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;\n        var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}\n     * with a {@link Cartesian4} with a <code>w</code> component of zero.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @param {Cartesian3} cartesian The point.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     *\n     * @example\n     * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n     * var result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n     * // A shortcut for\n     * //   Cartesian3 p = ...\n     * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);\n     */\n    Matrix4.multiplyByPointAsVector = function(matrix, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var vX = cartesian.x;\n        var vY = cartesian.y;\n        var vZ = cartesian.z;\n\n        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;\n        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;\n        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}\n     * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @param {Cartesian3} cartesian The point.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     *\n     * @example\n     * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n     * var result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());\n     */\n    Matrix4.multiplyByPoint = function(matrix, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var vX = cartesian.x;\n        var vY = cartesian.y;\n        var vZ = cartesian.z;\n\n        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];\n        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];\n        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a scalar.\n     *\n     * @param {Matrix4} matrix The matrix.\n     * @param {Number} scalar The number to multiply by.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * var a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n     *\n     * // m remains the same\n     * // a = [-20.0, -22.0, -24.0, -26.0]\n     * //     [-28.0, -30.0, -32.0, -34.0]\n     * //     [-36.0, -38.0, -40.0, -42.0]\n     * //     [-44.0, -46.0, -48.0, -50.0]\n     */\n    Matrix4.multiplyByScalar = function(matrix, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar must be a number');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0] * scalar;\n        result[1] = matrix[1] * scalar;\n        result[2] = matrix[2] * scalar;\n        result[3] = matrix[3] * scalar;\n        result[4] = matrix[4] * scalar;\n        result[5] = matrix[5] * scalar;\n        result[6] = matrix[6] * scalar;\n        result[7] = matrix[7] * scalar;\n        result[8] = matrix[8] * scalar;\n        result[9] = matrix[9] * scalar;\n        result[10] = matrix[10] * scalar;\n        result[11] = matrix[11] * scalar;\n        result[12] = matrix[12] * scalar;\n        result[13] = matrix[13] * scalar;\n        result[14] = matrix[14] * scalar;\n        result[15] = matrix[15] * scalar;\n        return result;\n    };\n\n    /**\n     * Computes a negated copy of the provided matrix.\n     *\n     * @param {Matrix4} matrix The matrix to negate.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * //create a new Matrix4 instance which is a negation of a Matrix4\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * var a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n     *\n     * // m remains the same\n     * // a = [-10.0, -11.0, -12.0, -13.0]\n     * //     [-14.0, -15.0, -16.0, -17.0]\n     * //     [-18.0, -19.0, -20.0, -21.0]\n     * //     [-22.0, -23.0, -24.0, -25.0]\n     */\n    Matrix4.negate = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = -matrix[0];\n        result[1] = -matrix[1];\n        result[2] = -matrix[2];\n        result[3] = -matrix[3];\n        result[4] = -matrix[4];\n        result[5] = -matrix[5];\n        result[6] = -matrix[6];\n        result[7] = -matrix[7];\n        result[8] = -matrix[8];\n        result[9] = -matrix[9];\n        result[10] = -matrix[10];\n        result[11] = -matrix[11];\n        result[12] = -matrix[12];\n        result[13] = -matrix[13];\n        result[14] = -matrix[14];\n        result[15] = -matrix[15];\n        return result;\n    };\n\n    /**\n     * Computes the transpose of the provided matrix.\n     *\n     * @param {Matrix4} matrix The matrix to transpose.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     *\n     * @example\n     * //returns transpose of a Matrix4\n     * // m = [10.0, 11.0, 12.0, 13.0]\n     * //     [14.0, 15.0, 16.0, 17.0]\n     * //     [18.0, 19.0, 20.0, 21.0]\n     * //     [22.0, 23.0, 24.0, 25.0]\n     *\n     * var a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n     *\n     * // m remains the same\n     * // a = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     */\n    Matrix4.transpose = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var matrix1 = matrix[1];\n        var matrix2 = matrix[2];\n        var matrix3 = matrix[3];\n        var matrix6 = matrix[6];\n        var matrix7 = matrix[7];\n        var matrix11 = matrix[11];\n\n        result[0] = matrix[0];\n        result[1] = matrix[4];\n        result[2] = matrix[8];\n        result[3] = matrix[12];\n        result[4] = matrix1;\n        result[5] = matrix[5];\n        result[6] = matrix[9];\n        result[7] = matrix[13];\n        result[8] = matrix2;\n        result[9] = matrix6;\n        result[10] = matrix[10];\n        result[11] = matrix[14];\n        result[12] = matrix3;\n        result[13] = matrix7;\n        result[14] = matrix11;\n        result[15] = matrix[15];\n        return result;\n    };\n\n    /**\n     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n     *\n     * @param {Matrix4} matrix The matrix with signed elements.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.abs = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = Math.abs(matrix[0]);\n        result[1] = Math.abs(matrix[1]);\n        result[2] = Math.abs(matrix[2]);\n        result[3] = Math.abs(matrix[3]);\n        result[4] = Math.abs(matrix[4]);\n        result[5] = Math.abs(matrix[5]);\n        result[6] = Math.abs(matrix[6]);\n        result[7] = Math.abs(matrix[7]);\n        result[8] = Math.abs(matrix[8]);\n        result[9] = Math.abs(matrix[9]);\n        result[10] = Math.abs(matrix[10]);\n        result[11] = Math.abs(matrix[11]);\n        result[12] = Math.abs(matrix[12]);\n        result[13] = Math.abs(matrix[13]);\n        result[14] = Math.abs(matrix[14]);\n        result[15] = Math.abs(matrix[15]);\n\n        return result;\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix4} [left] The first matrix.\n     * @param {Matrix4} [right] The second matrix.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     *\n     * @example\n     * //compares two Matrix4 instances\n     *\n     * // a = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     *\n     * // b = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     *\n     * if(Cesium.Matrix4.equals(a,b)) {\n     *      console.log(\"Both matrices are equal\");\n     * } else {\n     *      console.log(\"They are not equal\");\n     * }\n     *\n     * //Prints \"Both matrices are equal\" on the console\n     */\n    Matrix4.equals = function(left, right) {\n        // Given that most matrices will be transformation matrices, the elements\n        // are tested in order such that the test is likely to fail as early\n        // as possible.  I _think_ this is just as friendly to the L1 cache\n        // as testing in index order.  It is certainty faster in practice.\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                // Translation\n                left[12] === right[12] &&\n                left[13] === right[13] &&\n                left[14] === right[14] &&\n\n                // Rotation/scale\n                left[0] === right[0] &&\n                left[1] === right[1] &&\n                left[2] === right[2] &&\n                left[4] === right[4] &&\n                left[5] === right[5] &&\n                left[6] === right[6] &&\n                left[8] === right[8] &&\n                left[9] === right[9] &&\n                left[10] === right[10] &&\n\n                // Bottom row\n                left[3] === right[3] &&\n                left[7] === right[7] &&\n                left[11] === right[11] &&\n                left[15] === right[15]);\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix4} [left] The first matrix.\n     * @param {Matrix4} [right] The second matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     *\n     * @example\n     * //compares two Matrix4 instances\n     *\n     * // a = [10.5, 14.5, 18.5, 22.5]\n     * //     [11.5, 15.5, 19.5, 23.5]\n     * //     [12.5, 16.5, 20.5, 24.5]\n     * //     [13.5, 17.5, 21.5, 25.5]\n     *\n     * // b = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     *\n     * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n     *      console.log(\"Difference between both the matrices is less than 0.1\");\n     * } else {\n     *      console.log(\"Difference between both the matrices is not less than 0.1\");\n     * }\n     *\n     * //Prints \"Difference between both the matrices is not less than 0.1\" on the console\n     */\n    Matrix4.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon must be a number');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n                (defined(left) &&\n                defined(right) &&\n                Math.abs(left[0] - right[0]) <= epsilon &&\n                Math.abs(left[1] - right[1]) <= epsilon &&\n                Math.abs(left[2] - right[2]) <= epsilon &&\n                Math.abs(left[3] - right[3]) <= epsilon &&\n                Math.abs(left[4] - right[4]) <= epsilon &&\n                Math.abs(left[5] - right[5]) <= epsilon &&\n                Math.abs(left[6] - right[6]) <= epsilon &&\n                Math.abs(left[7] - right[7]) <= epsilon &&\n                Math.abs(left[8] - right[8]) <= epsilon &&\n                Math.abs(left[9] - right[9]) <= epsilon &&\n                Math.abs(left[10] - right[10]) <= epsilon &&\n                Math.abs(left[11] - right[11]) <= epsilon &&\n                Math.abs(left[12] - right[12]) <= epsilon &&\n                Math.abs(left[13] - right[13]) <= epsilon &&\n                Math.abs(left[14] - right[14]) <= epsilon &&\n                Math.abs(left[15] - right[15]) <= epsilon);\n    };\n\n    /**\n     * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Matrix4.getTranslation = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = matrix[12];\n        result.y = matrix[13];\n        result.z = matrix[14];\n        return result;\n    };\n\n    /**\n     * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.\n     *\n     * @param {Matrix4} matrix The matrix to use.\n     * @param {Matrix3} result The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter.\n     *\n     * @example\n     * // returns a Matrix3 instance from a Matrix4 instance\n     *\n     * // m = [10.0, 14.0, 18.0, 22.0]\n     * //     [11.0, 15.0, 19.0, 23.0]\n     * //     [12.0, 16.0, 20.0, 24.0]\n     * //     [13.0, 17.0, 21.0, 25.0]\n     *\n     * var b = new Cesium.Matrix3();\n     * Cesium.Matrix4.getRotation(m,b);\n     *\n     * // b = [10.0, 14.0, 18.0]\n     * //     [11.0, 15.0, 19.0]\n     * //     [12.0, 16.0, 20.0]\n     */\n    Matrix4.getRotation = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[4];\n        result[4] = matrix[5];\n        result[5] = matrix[6];\n        result[6] = matrix[8];\n        result[7] = matrix[9];\n        result[8] = matrix[10];\n        return result;\n    };\n\n    var scratchInverseRotation = new Matrix3();\n    var scratchMatrix3Zero = new Matrix3();\n    var scratchBottomRow = new Cartesian4();\n    var scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);\n\n     /**\n      * Computes the inverse of the provided matrix using Cramers Rule.\n      * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.\n      * If the matrix is an affine transformation matrix, it is more efficient\n      * to invert it with {@link Matrix4.inverseTransformation}.\n      *\n      * @param {Matrix4} matrix The matrix to invert.\n      * @param {Matrix4} result The object onto which to store the result.\n      * @returns {Matrix4} The modified result parameter.\n      *\n      * @exception {RuntimeError} matrix is not invertible because its determinate is zero.\n      */\n    Matrix4.inverse = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        // Special case for a zero scale matrix that can occur, for example,\n        // when a model's node has a [0, 0, 0] scale.\n        if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) &&\n            Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {\n\n            result[0] = 0.0;\n            result[1] = 0.0;\n            result[2] = 0.0;\n            result[3] = 0.0;\n            result[4] = 0.0;\n            result[5] = 0.0;\n            result[6] = 0.0;\n            result[7] = 0.0;\n            result[8] = 0.0;\n            result[9] = 0.0;\n            result[10] = 0.0;\n            result[11] = 0.0;\n            result[12] = -matrix[12];\n            result[13] = -matrix[13];\n            result[14] = -matrix[14];\n            result[15] = 1.0;\n            return result;\n        }\n\n        //\n        // Ported from:\n        //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf\n        //\n        var src0 = matrix[0];\n        var src1 = matrix[4];\n        var src2 = matrix[8];\n        var src3 = matrix[12];\n        var src4 = matrix[1];\n        var src5 = matrix[5];\n        var src6 = matrix[9];\n        var src7 = matrix[13];\n        var src8 = matrix[2];\n        var src9 = matrix[6];\n        var src10 = matrix[10];\n        var src11 = matrix[14];\n        var src12 = matrix[3];\n        var src13 = matrix[7];\n        var src14 = matrix[11];\n        var src15 = matrix[15];\n\n        // calculate pairs for first 8 elements (cofactors)\n        var tmp0 = src10 * src15;\n        var tmp1 = src11 * src14;\n        var tmp2 = src9 * src15;\n        var tmp3 = src11 * src13;\n        var tmp4 = src9 * src14;\n        var tmp5 = src10 * src13;\n        var tmp6 = src8 * src15;\n        var tmp7 = src11 * src12;\n        var tmp8 = src8 * src14;\n        var tmp9 = src10 * src12;\n        var tmp10 = src8 * src13;\n        var tmp11 = src9 * src12;\n\n        // calculate first 8 elements (cofactors)\n        var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);\n        var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);\n        var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);\n        var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);\n        var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);\n        var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);\n        var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);\n        var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);\n\n        // calculate pairs for second 8 elements (cofactors)\n        tmp0 = src2 * src7;\n        tmp1 = src3 * src6;\n        tmp2 = src1 * src7;\n        tmp3 = src3 * src5;\n        tmp4 = src1 * src6;\n        tmp5 = src2 * src5;\n        tmp6 = src0 * src7;\n        tmp7 = src3 * src4;\n        tmp8 = src0 * src6;\n        tmp9 = src2 * src4;\n        tmp10 = src0 * src5;\n        tmp11 = src1 * src4;\n\n        // calculate second 8 elements (cofactors)\n        var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);\n        var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);\n        var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);\n        var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);\n        var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);\n        var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);\n        var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);\n        var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);\n\n        // calculate determinant\n        var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\n\n        if (Math.abs(det) < CesiumMath.EPSILON20) {\n            throw new RuntimeError('matrix is not invertible because its determinate is zero.');\n        }\n\n        // calculate matrix inverse\n        det = 1.0 / det;\n\n        result[0] = dst0 * det;\n        result[1] = dst1 * det;\n        result[2] = dst2 * det;\n        result[3] = dst3 * det;\n        result[4] = dst4 * det;\n        result[5] = dst5 * det;\n        result[6] = dst6 * det;\n        result[7] = dst7 * det;\n        result[8] = dst8 * det;\n        result[9] = dst9 * det;\n        result[10] = dst10 * det;\n        result[11] = dst11 * det;\n        result[12] = dst12 * det;\n        result[13] = dst13 * det;\n        result[14] = dst14 * det;\n        result[15] = dst15 * det;\n        return result;\n    };\n\n    /**\n     * Computes the inverse of the provided matrix assuming it is\n     * an affine transformation matrix, where the upper left 3x3 elements\n     * are a rotation matrix, and the upper three elements in the fourth\n     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n     * The matrix is not verified to be in the proper form.\n     * This method is faster than computing the inverse for a general 4x4\n     * matrix using {@link Matrix4.inverse}.\n     *\n     * @param {Matrix4} matrix The matrix to invert.\n     * @param {Matrix4} result The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter.\n     */\n    Matrix4.inverseTransformation = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        //This function is an optimized version of the below 4 lines.\n        //var rT = Matrix3.transpose(Matrix4.getRotation(matrix));\n        //var rTN = Matrix3.negate(rT);\n        //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));\n        //return Matrix4.fromRotationTranslation(rT, rTT, result);\n\n        var matrix0 = matrix[0];\n        var matrix1 = matrix[1];\n        var matrix2 = matrix[2];\n        var matrix4 = matrix[4];\n        var matrix5 = matrix[5];\n        var matrix6 = matrix[6];\n        var matrix8 = matrix[8];\n        var matrix9 = matrix[9];\n        var matrix10 = matrix[10];\n\n        var vX = matrix[12];\n        var vY = matrix[13];\n        var vZ = matrix[14];\n\n        var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;\n        var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;\n        var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;\n\n        result[0] = matrix0;\n        result[1] = matrix4;\n        result[2] = matrix8;\n        result[3] = 0.0;\n        result[4] = matrix1;\n        result[5] = matrix5;\n        result[6] = matrix9;\n        result[7] = 0.0;\n        result[8] = matrix2;\n        result[9] = matrix6;\n        result[10] = matrix10;\n        result[11] = 0.0;\n        result[12] = x;\n        result[13] = y;\n        result[14] = z;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * An immutable Matrix4 instance initialized to the identity matrix.\n     *\n     * @type {Matrix4}\n     * @constant\n     */\n    Matrix4.IDENTITY = freezeObject(new Matrix4(1.0, 0.0, 0.0, 0.0,\n                                                0.0, 1.0, 0.0, 0.0,\n                                                0.0, 0.0, 1.0, 0.0,\n                                                0.0, 0.0, 0.0, 1.0));\n\n    /**\n     * An immutable Matrix4 instance initialized to the zero matrix.\n     *\n     * @type {Matrix4}\n     * @constant\n     */\n    Matrix4.ZERO = freezeObject(new Matrix4(0.0, 0.0, 0.0, 0.0,\n                                            0.0, 0.0, 0.0, 0.0,\n                                            0.0, 0.0, 0.0, 0.0,\n                                            0.0, 0.0, 0.0, 0.0));\n\n    /**\n     * The index into Matrix4 for column 0, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN0ROW0 = 0;\n\n    /**\n     * The index into Matrix4 for column 0, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN0ROW1 = 1;\n\n    /**\n     * The index into Matrix4 for column 0, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN0ROW2 = 2;\n\n    /**\n     * The index into Matrix4 for column 0, row 3.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN0ROW3 = 3;\n\n    /**\n     * The index into Matrix4 for column 1, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN1ROW0 = 4;\n\n    /**\n     * The index into Matrix4 for column 1, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN1ROW1 = 5;\n\n    /**\n     * The index into Matrix4 for column 1, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN1ROW2 = 6;\n\n    /**\n     * The index into Matrix4 for column 1, row 3.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN1ROW3 = 7;\n\n    /**\n     * The index into Matrix4 for column 2, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN2ROW0 = 8;\n\n    /**\n     * The index into Matrix4 for column 2, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN2ROW1 = 9;\n\n    /**\n     * The index into Matrix4 for column 2, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN2ROW2 = 10;\n\n    /**\n     * The index into Matrix4 for column 2, row 3.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN2ROW3 = 11;\n\n    /**\n     * The index into Matrix4 for column 3, row 0.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN3ROW0 = 12;\n\n    /**\n     * The index into Matrix4 for column 3, row 1.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN3ROW1 = 13;\n\n    /**\n     * The index into Matrix4 for column 3, row 2.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN3ROW2 = 14;\n\n    /**\n     * The index into Matrix4 for column 3, row 3.\n     *\n     * @type {Number}\n     * @constant\n     */\n    Matrix4.COLUMN3ROW3 = 15;\n\n    /**\n     * Duplicates the provided Matrix4 instance.\n     *\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n     */\n    Matrix4.prototype.clone = function(result) {\n        return Matrix4.clone(this, result);\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix4} [right] The right hand side matrix.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Matrix4.prototype.equals = function(right) {\n        return Matrix4.equals(this, right);\n    };\n\n    /**\n     * @private\n     */\n    Matrix4.equalsArray = function(matrix, array, offset) {\n        return matrix[0] === array[offset] &&\n               matrix[1] === array[offset + 1] &&\n               matrix[2] === array[offset + 2] &&\n               matrix[3] === array[offset + 3] &&\n               matrix[4] === array[offset + 4] &&\n               matrix[5] === array[offset + 5] &&\n               matrix[6] === array[offset + 6] &&\n               matrix[7] === array[offset + 7] &&\n               matrix[8] === array[offset + 8] &&\n               matrix[9] === array[offset + 9] &&\n               matrix[10] === array[offset + 10] &&\n               matrix[11] === array[offset + 11] &&\n               matrix[12] === array[offset + 12] &&\n               matrix[13] === array[offset + 13] &&\n               matrix[14] === array[offset + 14] &&\n               matrix[15] === array[offset + 15];\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix4} [right] The right hand side matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Matrix4.prototype.equalsEpsilon = function(right, epsilon) {\n        return Matrix4.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Computes a string representing this Matrix with each row being\n     * on a separate line and in the format '(column0, column1, column2, column3)'.\n     *\n     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.\n     */\n    Matrix4.prototype.toString = function() {\n        return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] +')\\n' +\n               '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] +')\\n' +\n               '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] +')\\n' +\n               '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] +')';\n    };\n\n    return Matrix4;\n});\n",
    "\n/*global define*/\ndefine('Core/Plane',[\n        './Cartesian3',\n        './defined',\n        './DeveloperError',\n        './freezeObject'\n    ], function(\n        Cartesian3,\n        defined,\n        DeveloperError,\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * A plane in Hessian Normal Form defined by\n     * <pre>\n     * ax + by + cz + d = 0\n     * </pre>\n     * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n     * <code>distance</code> to the plane, and (x, y, z) is any point on\n     * the plane.\n     *\n     * @alias Plane\n     * @constructor\n     *\n     * @param {Cartesian3} normal The plane's normal (normalized).\n     * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n     * <code>distance</code> determines which side of the plane the origin\n     * is on.  If <code>distance</code> is positive, the origin is in the half-space\n     * in the direction of the normal; if negative, the origin is in the half-space\n     * opposite to the normal; if zero, the plane passes through the origin.\n     *\n     * @example\n     * // The plane x=0\n     * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n     */\n    var Plane = function(normal, distance) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(normal))  {\n            throw new DeveloperError('normal is required.');\n        }\n        if (!defined(distance)) {\n            throw new DeveloperError('distance is required.');\n        }\n        //>>includeEnd('debug');\n\n        /**\n         * The plane's normal.\n         *\n         * @type {Cartesian3}\n         */\n        this.normal = Cartesian3.clone(normal);\n\n        /**\n         * The shortest distance from the origin to the plane.  The sign of\n         * <code>distance</code> determines which side of the plane the origin\n         * is on.  If <code>distance</code> is positive, the origin is in the half-space\n         * in the direction of the normal; if negative, the origin is in the half-space\n         * opposite to the normal; if zero, the plane passes through the origin.\n         *\n         * @type {Number}\n         */\n        this.distance = distance;\n    };\n\n    /**\n     * Creates a plane from a normal and a point on the plane.\n     *\n     * @param {Cartesian3} point The point on the plane.\n     * @param {Cartesian3} normal The plane's normal (normalized).\n     * @param {Plane} [result] The object onto which to store the result.\n     * @returns {Plane} A new plane instance or the modified result parameter.\n     *\n     * @example\n     * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n     * var normal = ellipsoid.geodeticSurfaceNormal(point);\n     * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n     */\n    Plane.fromPointNormal = function(point, normal, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(point)) {\n            throw new DeveloperError('point is required.');\n        }\n        if (!defined(normal)) {\n            throw new DeveloperError('normal is required.');\n        }\n        //>>includeEnd('debug');\n\n        var distance = -Cartesian3.dot(normal, point);\n\n        if (!defined(result)) {\n            return new Plane(normal, distance);\n        }\n\n        Cartesian3.clone(normal, result.normal);\n        result.distance = distance;\n        return result;\n    };\n\n    var scratchNormal = new Cartesian3();\n    /**\n     * Creates a plane from the general equation\n     *\n     * @param {Cartesian4} coefficients The plane's normal (normalized).\n     * @param {Plane} [result] The object onto which to store the result.\n     * @returns {Plane} A new plane instance or the modified result parameter.\n     */\n    Plane.fromCartesian4 = function(coefficients, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(coefficients)) {\n            throw new DeveloperError('coefficients is required.');\n        }\n        //>>includeEnd('debug');\n\n        var normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n        var distance = coefficients.w;\n\n        if (!defined(result)) {\n            return new Plane(normal, distance);\n        } else {\n            Cartesian3.clone(normal, result.normal);\n            result.distance = distance;\n            return result;\n        }\n    };\n\n    /**\n     * Computes the signed shortest distance of a point to a plane.\n     * The sign of the distance determines which side of the plane the point\n     * is on.  If the distance is positive, the point is in the half-space\n     * in the direction of the normal; if negative, the point is in the half-space\n     * opposite to the normal; if zero, the plane passes through the point.\n     *\n     * @param {Plane} plane The plane.\n     * @param {Cartesian3} point The point.\n     * @returns {Number} The signed shortest distance of the point to the plane.\n     */\n    Plane.getPointDistance = function(plane, point) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(plane)) {\n            throw new DeveloperError('plane is required.');\n        }\n        if (!defined(point)) {\n            throw new DeveloperError('point is required.');\n        }\n        //>>includeEnd('debug');\n\n        return Cartesian3.dot(plane.normal, point) + plane.distance;\n    };\n\n    /**\n     * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n     *\n     * @type {Plane}\n     * @constant\n     */\n    Plane.ORIGIN_XY_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n    /**\n     * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n     *\n     * @type {Plane}\n     * @constant\n     */\n    Plane.ORIGIN_YZ_PLANE = freezeObject(new Plane(Cartesian3.UNIT_X, 0.0));\n\n    /**\n     * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n     *\n     * @type {Plane}\n     * @constant\n     */\n    Plane.ORIGIN_ZX_PLANE = freezeObject(new Plane(Cartesian3.UNIT_Y, 0.0));\n\n    return Plane;\n});\n",
    "\n/*global define*/\ndefine('Core/BoundingSphere',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './deprecationWarning',\n        './DeveloperError',\n        './Ellipsoid',\n        './GeographicProjection',\n        './Intersect',\n        './Interval',\n        './Matrix4',\n        './Plane',\n        './Rectangle'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        deprecationWarning,\n        DeveloperError,\n        Ellipsoid,\n        GeographicProjection,\n        Intersect,\n        Interval,\n        Matrix4,\n        Plane,\n        Rectangle) {\n    \"use strict\";\n\n    /**\n     * A bounding sphere with a center and a radius.\n     * @alias BoundingSphere\n     * @constructor\n     *\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n     * @param {Number} [radius=0.0] The radius of the bounding sphere.\n     *\n     * @see AxisAlignedBoundingBox\n     * @see BoundingRectangle\n     * @see Packable\n     */\n    var BoundingSphere = function(center, radius) {\n        /**\n         * The center point of the sphere.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n        /**\n         * The radius of the sphere.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.radius = defaultValue(radius, 0.0);\n    };\n\n    var fromPointsXMin = new Cartesian3();\n    var fromPointsYMin = new Cartesian3();\n    var fromPointsZMin = new Cartesian3();\n    var fromPointsXMax = new Cartesian3();\n    var fromPointsYMax = new Cartesian3();\n    var fromPointsZMax = new Cartesian3();\n    var fromPointsCurrentPos = new Cartesian3();\n    var fromPointsScratch = new Cartesian3();\n    var fromPointsRitterCenter = new Cartesian3();\n    var fromPointsMinBoxPt = new Cartesian3();\n    var fromPointsMaxBoxPt = new Cartesian3();\n    var fromPointsNaiveCenterScratch = new Cartesian3();\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n     * The bounding sphere is computed by running two algorithms, a naive algorithm and\n     * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n     *\n     * @param {Cartesian3[]} positions An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     *\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n     */\n    BoundingSphere.fromPoints = function(positions, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n        var numPositions = positions.length;\n        for (var i = 1; i < numPositions; i++) {\n            Cartesian3.clone(positions[i], currentPos);\n\n            var x = currentPos.x;\n            var y = currentPos.y;\n            var z = currentPos.z;\n\n            // Store points containing the the smallest and largest components\n            if (x < xMin.x) {\n                Cartesian3.clone(currentPos, xMin);\n            }\n\n            if (x > xMax.x) {\n                Cartesian3.clone(currentPos, xMax);\n            }\n\n            if (y < yMin.y) {\n                Cartesian3.clone(currentPos, yMin);\n            }\n\n            if (y > yMax.y) {\n                Cartesian3.clone(currentPos, yMax);\n            }\n\n            if (z < zMin.z) {\n                Cartesian3.clone(currentPos, zMin);\n            }\n\n            if (z > zMax.z) {\n                Cartesian3.clone(currentPos, zMax);\n            }\n        }\n\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n        // Set the diameter endpoints to the largest span.\n        var diameter1 = xMin;\n        var diameter2 = xMax;\n        var maxSpan = xSpan;\n        if (ySpan > maxSpan) {\n            maxSpan = ySpan;\n            diameter1 = yMin;\n            diameter2 = yMax;\n        }\n        if (zSpan > maxSpan) {\n            maxSpan = zSpan;\n            diameter1 = zMin;\n            diameter2 = zMax;\n        }\n\n        // Calculate the center of the initial sphere found by Ritter's algorithm\n        var ritterCenter = fromPointsRitterCenter;\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n        var ritterRadius = Math.sqrt(radiusSquared);\n\n        // Find the center of the sphere found using the Naive method.\n        var minBoxPt = fromPointsMinBoxPt;\n        minBoxPt.x = xMin.x;\n        minBoxPt.y = yMin.y;\n        minBoxPt.z = zMin.z;\n\n        var maxBoxPt = fromPointsMaxBoxPt;\n        maxBoxPt.x = xMax.x;\n        maxBoxPt.y = yMax.y;\n        maxBoxPt.z = zMax.z;\n\n        var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);\n\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\n        var naiveRadius = 0;\n        for (i = 0; i < numPositions; i++) {\n            Cartesian3.clone(positions[i], currentPos);\n\n            // Find the furthest point from the naive center to calculate the naive radius.\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n            if (r > naiveRadius) {\n                naiveRadius = r;\n            }\n\n            // Make adjustments to the Ritter Sphere to include all points.\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n            if (oldCenterToPointSquared > radiusSquared) {\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n                // Calculate new radius to include the point that lies outside\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n                radiusSquared = ritterRadius * ritterRadius;\n                // Calculate center of new Ritter sphere\n                var oldToNew = oldCenterToPoint - ritterRadius;\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n            }\n        }\n\n        if (ritterRadius < naiveRadius) {\n            Cartesian3.clone(ritterCenter, result.center);\n            result.radius = ritterRadius;\n        } else {\n            Cartesian3.clone(naiveCenter, result.center);\n            result.radius = naiveRadius;\n        }\n\n        return result;\n    };\n\n    var defaultProjection = new GeographicProjection();\n    var fromRectangle2DLowerLeft = new Cartesian3();\n    var fromRectangle2DUpperRight = new Cartesian3();\n    var fromRectangle2DSouthwest = new Cartographic();\n    var fromRectangle2DNortheast = new Cartographic();\n\n    /**\n     * Computes a bounding sphere from an rectangle projected in 2D.\n     *\n     * @param {Rectangle} rectangle The rectangle around which to create a bounding sphere.\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {\n        return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0.0, 0.0, result);\n    };\n\n    /**\n     * Computes a bounding sphere from an rectangle projected in 2D.  The bounding sphere accounts for the\n     * object's minimum and maximum heights over the rectangle.\n     *\n     * @param {Rectangle} rectangle The rectangle around which to create a bounding sphere.\n     * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n     * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n     * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(rectangle)) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        projection = defaultValue(projection, defaultProjection);\n\n        Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n        fromRectangle2DSouthwest.height = minimumHeight;\n        Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n        fromRectangle2DNortheast.height = maximumHeight;\n\n        var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);\n        var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);\n\n        var width = upperRight.x - lowerLeft.x;\n        var height = upperRight.y - lowerLeft.y;\n        var elevation = upperRight.z - lowerLeft.z;\n\n        result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n        var center = result.center;\n        center.x = lowerLeft.x + width * 0.5;\n        center.y = lowerLeft.y + height * 0.5;\n        center.z = lowerLeft.z + elevation * 0.5;\n        return result;\n    };\n\n    var fromRectangle3DScratch = [];\n\n    /**\n     * Computes a bounding sphere from an rectangle in 3D. The bounding sphere is created using a subsample of points\n     * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n     *\n     * @param {Rectangle} rectangle The valid rectangle used to create a bounding sphere.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n     * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n        var positions;\n        if (defined(rectangle)) {\n            positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);\n        }\n\n        return BoundingSphere.fromPoints(positions, result);\n    };\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n     * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n     * ensure a tight fit.\n     *\n     * @param {Number[]} positions An array of points that the bounding sphere will enclose.  Each point\n     *        is formed from three elements in the array in the order X, Y, Z.\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n     *        origin of the coordinate system.  This is useful when the positions are to be used for\n     *        relative-to-center (RTC) rendering.\n     * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n     *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n     *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n     *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n     *        the stride is 5, however, two array elements are skipped and the next position begins at array\n     *        index 5.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     *\n     * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n     *\n     * @example\n     * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n     * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n     * // elements per point which are ignored for the purpose of computing the bounding sphere.\n     * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n     * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\n     *               4.0, 5.0, 6.0, 0.1, 0.2,\n     *               7.0, 8.0, 9.0, 0.1, 0.2];\n     * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n     */\n    BoundingSphere.fromVertices = function(positions, center, stride, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        center = defaultValue(center, Cartesian3.ZERO);\n\n        stride = defaultValue(stride, 3);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (stride < 3) {\n            throw new DeveloperError('stride must be 3 or greater.');\n        }\n        //>>includeEnd('debug');\n\n        var currentPos = fromPointsCurrentPos;\n        currentPos.x = positions[0] + center.x;\n        currentPos.y = positions[1] + center.y;\n        currentPos.z = positions[2] + center.z;\n\n        var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n        var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n        var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n        var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n        var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n        var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n        var numElements = positions.length;\n        for (var i = 0; i < numElements; i += stride) {\n            var x = positions[i] + center.x;\n            var y = positions[i + 1] + center.y;\n            var z = positions[i + 2] + center.z;\n\n            currentPos.x = x;\n            currentPos.y = y;\n            currentPos.z = z;\n\n            // Store points containing the the smallest and largest components\n            if (x < xMin.x) {\n                Cartesian3.clone(currentPos, xMin);\n            }\n\n            if (x > xMax.x) {\n                Cartesian3.clone(currentPos, xMax);\n            }\n\n            if (y < yMin.y) {\n                Cartesian3.clone(currentPos, yMin);\n            }\n\n            if (y > yMax.y) {\n                Cartesian3.clone(currentPos, yMax);\n            }\n\n            if (z < zMin.z) {\n                Cartesian3.clone(currentPos, zMin);\n            }\n\n            if (z > zMax.z) {\n                Cartesian3.clone(currentPos, zMax);\n            }\n        }\n\n        // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n        var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));\n        var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));\n        var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));\n\n        // Set the diameter endpoints to the largest span.\n        var diameter1 = xMin;\n        var diameter2 = xMax;\n        var maxSpan = xSpan;\n        if (ySpan > maxSpan) {\n            maxSpan = ySpan;\n            diameter1 = yMin;\n            diameter2 = yMax;\n        }\n        if (zSpan > maxSpan) {\n            maxSpan = zSpan;\n            diameter1 = zMin;\n            diameter2 = zMax;\n        }\n\n        // Calculate the center of the initial sphere found by Ritter's algorithm\n        var ritterCenter = fromPointsRitterCenter;\n        ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n        ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n        ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n        // Calculate the radius of the initial sphere found by Ritter's algorithm\n        var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));\n        var ritterRadius = Math.sqrt(radiusSquared);\n\n        // Find the center of the sphere found using the Naive method.\n        var minBoxPt = fromPointsMinBoxPt;\n        minBoxPt.x = xMin.x;\n        minBoxPt.y = yMin.y;\n        minBoxPt.z = zMin.z;\n\n        var maxBoxPt = fromPointsMaxBoxPt;\n        maxBoxPt.x = xMax.x;\n        maxBoxPt.y = yMax.y;\n        maxBoxPt.z = zMax.z;\n\n        var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);\n\n        // Begin 2nd pass to find naive radius and modify the ritter sphere.\n        var naiveRadius = 0;\n        for (i = 0; i < numElements; i += stride) {\n            currentPos.x = positions[i] + center.x;\n            currentPos.y = positions[i + 1] + center.y;\n            currentPos.z = positions[i + 2] + center.z;\n\n            // Find the furthest point from the naive center to calculate the naive radius.\n            var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));\n            if (r > naiveRadius) {\n                naiveRadius = r;\n            }\n\n            // Make adjustments to the Ritter Sphere to include all points.\n            var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));\n            if (oldCenterToPointSquared > radiusSquared) {\n                var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n                // Calculate new radius to include the point that lies outside\n                ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n                radiusSquared = ritterRadius * ritterRadius;\n                // Calculate center of new Ritter sphere\n                var oldToNew = oldCenterToPoint - ritterRadius;\n                ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n                ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n                ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n            }\n        }\n\n        if (ritterRadius < naiveRadius) {\n            Cartesian3.clone(ritterCenter, result.center);\n            result.radius = ritterRadius;\n        } else {\n            Cartesian3.clone(naiveCenter, result.center);\n            result.radius = naiveRadius;\n        }\n\n        return result;\n    };\n\n    /**\n     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n     * tighly and fully encompases the box.\n     *\n     * @param {Cartesian3} [corner] The minimum height over the rectangle.\n     * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * // Create a bounding sphere around the unit cube\n     * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n     */\n    BoundingSphere.fromCornerPoints = function(corner, oppositeCorner, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(corner) || !defined(oppositeCorner)) {\n            throw new DeveloperError('corner and oppositeCorner are required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var center = result.center;\n        Cartesian3.add(corner, oppositeCorner, center);\n        Cartesian3.multiplyByScalar(center, 0.5, center);\n        result.radius = Cartesian3.distance(center, oppositeCorner);\n        return result;\n    };\n\n    /**\n     * Creates a bounding sphere encompassing an ellipsoid.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n     */\n    BoundingSphere.fromEllipsoid = function(ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ellipsoid)) {\n            throw new DeveloperError('ellipsoid is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        Cartesian3.clone(Cartesian3.ZERO, result.center);\n        result.radius = ellipsoid.maximumRadius;\n        return result;\n    };\n\n    var fromBoundingSpheresScratch = new Cartesian3();\n\n    /**\n     * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n     *\n     * @param {BoundingSphere[]} boundingSpheres The array of bounding spheres.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.fromBoundingSpheres = function(boundingSpheres, result) {\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            result.radius = 0.0;\n            return result;\n        }\n\n        var length = boundingSpheres.length;\n        if (length === 1) {\n            return BoundingSphere.clone(boundingSpheres[0], result);\n        }\n\n        if (length === 2) {\n            return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n        }\n\n        var positions = [];\n        for (var i = 0; i < length; i++) {\n            positions.push(boundingSpheres[i].center);\n        }\n\n        result = BoundingSphere.fromPoints(positions, result);\n\n        var center = result.center;\n        var radius = result.radius;\n        for (i = 0; i < length; i++) {\n            var tmp = boundingSpheres[i];\n            radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);\n        }\n        result.radius = radius;\n\n        return result;\n    };\n\n    /**\n     * Duplicates a BoundingSphere instance.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n     */\n    BoundingSphere.clone = function(sphere, result) {\n        if (!defined(sphere)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new BoundingSphere(sphere.center, sphere.radius);\n        }\n\n        result.center = Cartesian3.clone(sphere.center, result.center);\n        result.radius = sphere.radius;\n        return result;\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    BoundingSphere.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {BoundingSphere} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    BoundingSphere.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = value.center;\n        array[startingIndex++] = center.x;\n        array[startingIndex++] = center.y;\n        array[startingIndex++] = center.z;\n        array[startingIndex] = value.radius;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {BoundingSphere} [result] The object into which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n     */\n    BoundingSphere.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var center = result.center;\n        center.x = array[startingIndex++];\n        center.y = array[startingIndex++];\n        center.z = array[startingIndex++];\n        result.radius = array[startingIndex];\n        return result;\n    };\n\n    var unionScratch = new Cartesian3();\n    var unionScratchCenter = new Cartesian3();\n    /**\n     * Computes a bounding sphere that contains both the left and right bounding spheres.\n     *\n     * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n     * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.union = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        var leftCenter = left.center;\n        var leftRadius = left.radius;\n        var rightCenter = right.center;\n        var rightRadius = right.radius;\n\n        var toRightCenter = Cartesian3.subtract(rightCenter, leftCenter, unionScratch);\n        var centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n        if (leftRadius >= (centerSeparation + rightRadius)) {\n            // Left sphere wins.\n            left.clone(result);\n            return result;\n        }\n\n        if (rightRadius >= (centerSeparation + leftRadius)) {\n            // Right sphere wins.\n            right.clone(result);\n            return result;\n        }\n\n        // There are two tangent points, one on far side of each sphere.\n        var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n        // Compute the center point halfway between the two tangent points.\n        var center = Cartesian3.multiplyByScalar(toRightCenter,\n                (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation, unionScratchCenter);\n        Cartesian3.add(center, leftCenter, center);\n        Cartesian3.clone(center, result.center);\n        result.radius = halfDistanceBetweenTangentPoints;\n\n        return result;\n    };\n\n    var expandScratch = new Cartesian3();\n    /**\n     * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n     *\n     * @param {BoundingSphere} sphere A sphere to expand.\n     * @param {Cartesian3} point A point to enclose in a bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.expand = function(sphere, point, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n\n        if (!defined(point)) {\n            throw new DeveloperError('point is required.');\n        }\n        //>>includeEnd('debug');\n\n        result = BoundingSphere.clone(sphere, result);\n\n        var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));\n        if (radius > result.radius) {\n            result.radius = radius;\n        }\n\n        return result;\n    };\n\n    /**\n     * Determines which side of a plane a sphere is located.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to test.\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n     *                      intersects the plane.\n     */\n    BoundingSphere.intersectPlane = function(sphere, plane) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n\n        if (!defined(plane)) {\n            throw new DeveloperError('plane is required.');\n        }\n        //>>includeEnd('debug');\n\n        var center = sphere.center;\n        var radius = sphere.radius;\n        var normal = plane.normal;\n        var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n        if (distanceToPlane < -radius) {\n            // The center point is negative side of the plane normal\n            return Intersect.OUTSIDE;\n        } else if (distanceToPlane < radius) {\n            // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n            return Intersect.INTERSECTING;\n        }\n        return Intersect.INSIDE;\n    };\n\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.transform = function(sphere, transform, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n\n        if (!defined(transform)) {\n            throw new DeveloperError('transform is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n        result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n        return result;\n    };\n\n    var distanceSquaredToScratch = new Cartesian3();\n\n    /**\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n     *\n     * @param {BoundingSphere} sphere The sphere.\n     * @param {Cartesian3} cartesian The point\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n     *\n     * @example\n     * // Sort bounding spheres from back to front\n     * spheres.sort(function(a, b) {\n     *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n     * });\n     */\n    BoundingSphere.distanceSquaredTo = function(sphere, cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        //>>includeEnd('debug');\n\n        var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);\n        return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;\n    };\n\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n     * The transformation matrix is not verified to have a uniform scale of 1.\n     * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n     * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     *\n     * @example\n     * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n     * var boundingSphere = new Cesium.BoundingSphere();\n     * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n     */\n    BoundingSphere.transformWithoutScale = function(sphere, transform, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n\n        if (!defined(transform)) {\n            throw new DeveloperError('transform is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new BoundingSphere();\n        }\n\n        result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);\n        result.radius = sphere.radius;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    /**\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n     * plus/minus the radius of the bounding sphere.\n     * <br>\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n     * closest and farthest planes from position that intersect the bounding sphere.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n     * @param {Cartesian3} position The position to calculate the distance from.\n     * @param {Cartesian3} direction The direction from position.\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n     */\n    BoundingSphere.computePlaneDistances = function(sphere, position, direction, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n\n        if (!defined(position)) {\n            throw new DeveloperError('position is required.');\n        }\n\n        if (!defined(direction)) {\n            throw new DeveloperError('direction is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Interval();\n        }\n\n        var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);\n        var mag = Cartesian3.dot(direction, toCenter);\n\n        result.start = mag - sphere.radius;\n        result.stop = mag + sphere.radius;\n        return result;\n    };\n\n    var projectTo2DNormalScratch = new Cartesian3();\n    var projectTo2DEastScratch = new Cartesian3();\n    var projectTo2DNorthScratch = new Cartesian3();\n    var projectTo2DWestScratch = new Cartesian3();\n    var projectTo2DSouthScratch = new Cartesian3();\n    var projectTo2DCartographicScratch = new Cartographic();\n    var projectTo2DPositionsScratch = new Array(8);\n    for (var n = 0; n < 8; ++n) {\n        projectTo2DPositionsScratch[n] = new Cartesian3();\n    }\n    var projectTo2DProjection = new GeographicProjection();\n    /**\n     * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n     * @param {Object} [projection=GeographicProjection] The projection to 2D.\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.projectTo2D = function(sphere, projection, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n        //>>includeEnd('debug');\n\n        projection = defaultValue(projection, projectTo2DProjection);\n\n        var ellipsoid = projection.ellipsoid;\n        var center = sphere.center;\n        var radius = sphere.radius;\n\n        var normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n        var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);\n        Cartesian3.normalize(east, east);\n        var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n        Cartesian3.normalize(north, north);\n\n        Cartesian3.multiplyByScalar(normal, radius, normal);\n        Cartesian3.multiplyByScalar(north, radius, north);\n        Cartesian3.multiplyByScalar(east, radius, east);\n\n        var south = Cartesian3.negate(north, projectTo2DSouthScratch);\n        var west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n        var positions = projectTo2DPositionsScratch;\n\n        // top NE corner\n        var corner = positions[0];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, east, corner);\n\n        // top NW corner\n        corner = positions[1];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // top SW corner\n        corner = positions[2];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // top SE corner\n        corner = positions[3];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, east, corner);\n\n        Cartesian3.negate(normal, normal);\n\n        // bottom NE corner\n        corner = positions[4];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, east, corner);\n\n        // bottom NW corner\n        corner = positions[5];\n        Cartesian3.add(normal, north, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // bottom SW corner\n        corner = positions[6];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, west, corner);\n\n        // bottom SE corner\n        corner = positions[7];\n        Cartesian3.add(normal, south, corner);\n        Cartesian3.add(corner, east, corner);\n\n        var length = positions.length;\n        for (var i = 0; i < length; ++i) {\n            var position = positions[i];\n            Cartesian3.add(center, position, position);\n            var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);\n            projection.project(cartographic, position);\n        }\n\n        result = BoundingSphere.fromPoints(positions, result);\n\n        // swizzle center components\n        center = result.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        return result;\n    };\n\n    /**\n     * Determines whether or not a sphere is hidden from view by the occluder.\n     *\n     * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n     * @param {Occluder} occluder The occluder.\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n     */\n    BoundingSphere.isOccluded = function(sphere, occluder) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n        if (!defined(occluder)) {\n            throw new DeveloperError('occluder is required.');\n        }\n        //>>includeEnd('debug');\n        return !occluder.isBoundingSphereVisible(sphere);\n    };\n\n    /**\n     * Compares the provided BoundingSphere componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {BoundingSphere} [left] The first BoundingSphere.\n     * @param {BoundingSphere} [right] The second BoundingSphere.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    BoundingSphere.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                Cartesian3.equals(left.center, right.center) &&\n                left.radius === right.radius);\n    };\n\n    /**\n     * Determines which side of a plane the sphere is located.\n     *\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n     *                      intersects the plane.\n     */\n    BoundingSphere.prototype.intersectPlane = function(plane) {\n        return BoundingSphere.intersectPlane(this, plane);\n    };\n\n    /**\n     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n     *\n     * @param {Cartesian3} cartesian The point\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n     *\n     * @example\n     * // Sort bounding spheres from back to front\n     * spheres.sort(function(a, b) {\n     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n     * });\n     */\n    BoundingSphere.prototype.distanceSquaredTo = function(cartesian) {\n        return BoundingSphere.distanceSquaredTo(this, cartesian);\n    };\n\n    /**\n     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n     * plus/minus the radius of the bounding sphere.\n     * <br>\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n     * closest and farthest planes from position that intersect the bounding sphere.\n     *\n     * @param {Cartesian3} position The position to calculate the distance from.\n     * @param {Cartesian3} direction The direction from position.\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n     * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n     */\n    BoundingSphere.prototype.computePlaneDistances = function(position, direction, result) {\n        return BoundingSphere.computePlaneDistances(this, position, direction, result);\n    };\n\n    /**\n     * Determines whether or not a sphere is hidden from view by the occluder.\n     *\n     * @param {Occluder} occluder The occluder.\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n     */\n    BoundingSphere.prototype.isOccluded = function(occluder) {\n        return BoundingSphere.isOccluded(this, occluder);\n    };\n\n    /**\n     * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    BoundingSphere.prototype.equals = function(right) {\n        return BoundingSphere.equals(this, right);\n    };\n\n    /**\n     * Duplicates this BoundingSphere instance.\n     *\n     * @param {BoundingSphere} [result] The object onto which to store the result.\n     * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n     */\n    BoundingSphere.prototype.clone = function(result) {\n        return BoundingSphere.clone(this, result);\n    };\n\n    return BoundingSphere;\n});\n",
    "\n/*global define*/\ndefine('Core/Cartesian2',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * A 2D Cartesian point.\n     * @alias Cartesian2\n     * @constructor\n     *\n     * @param {Number} [x=0.0] The X component.\n     * @param {Number} [y=0.0] The Y component.\n     *\n     * @see Cartesian3\n     * @see Cartesian4\n     * @see Packable\n     */\n    var Cartesian2 = function(x, y) {\n        /**\n         * The X component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.x = defaultValue(x, 0.0);\n\n        /**\n         * The Y component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.y = defaultValue(y, 0.0);\n    };\n\n    /**\n     * Creates a Cartesian2 instance from x and y coordinates.\n     *\n     * @param {Number} x The x coordinate.\n     * @param {Number} y The y coordinate.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     */\n    Cartesian2.fromElements = function(x, y, result) {\n        if (!defined(result)) {\n            return new Cartesian2(x, y);\n        }\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Duplicates a Cartesian2 instance.\n     *\n     * @param {Cartesian2} cartesian The Cartesian to duplicate.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n     */\n    Cartesian2.clone = function(cartesian, result) {\n        if (!defined(cartesian)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Cartesian2(cartesian.x, cartesian.y);\n        }\n\n        result.x = cartesian.x;\n        result.y = cartesian.y;\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n     * x and y properties of the Cartesian3 and drops z.\n     * @function\n     *\n     * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     */\n    Cartesian2.fromCartesian3 = Cartesian2.clone;\n\n    /**\n     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n     * x and y properties of the Cartesian4 and drops z and w.\n     * @function\n     *\n     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     */\n    Cartesian2.fromCartesian4 = Cartesian2.clone;\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Cartesian2.packedLength = 2;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Cartesian2} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Cartesian2.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.x;\n        array[startingIndex] = value.y;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Cartesian2} [result] The object into which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     */\n    Cartesian2.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Cartesian2();\n        }\n        result.x = array[startingIndex++];\n        result.y = array[startingIndex];\n        return result;\n    };\n\n    /**\n     * Creates a Cartesian2 from two consecutive elements in an array.\n     * @function\n     *\n     * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     *\n     * @example\n     * // Create a Cartesian2 with (1.0, 2.0)\n     * var v = [1.0, 2.0];\n     * var p = Cesium.Cartesian2.fromArray(v);\n     *\n     * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 2.0];\n     * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n     */\n    Cartesian2.fromArray = Cartesian2.unpack;\n\n    /**\n     * Computes the value of the maximum component for the supplied Cartesian.\n     *\n     * @param {Cartesian2} cartesian The cartesian to use.\n     * @returns {Number} The value of the maximum component.\n     */\n    Cartesian2.maximumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.max(cartesian.x, cartesian.y);\n    };\n\n    /**\n     * Computes the value of the minimum component for the supplied Cartesian.\n     *\n     * @param {Cartesian2} cartesian The cartesian to use.\n     * @returns {Number} The value of the minimum component.\n     */\n    Cartesian2.minimumComponent = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return Math.min(cartesian.x, cartesian.y);\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n     *\n     * @param {Cartesian2} first A cartesian to compare.\n     * @param {Cartesian2} second A cartesian to compare.\n     * @param {Cartesian2} result The object into which to store the result.\n     * @returns {Cartesian2} A cartesian with the minimum components.\n     */\n    Cartesian2.minimumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n\n        result.x = Math.min(first.x, second.x);\n        result.y = Math.min(first.y, second.y);\n\n        return result;\n    };\n\n    /**\n     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n     *\n     * @param {Cartesian2} first A cartesian to compare.\n     * @param {Cartesian2} second A cartesian to compare.\n     * @param {Cartesian2} result The object into which to store the result.\n     * @returns {Cartesian2} A cartesian with the maximum components.\n     */\n    Cartesian2.maximumByComponent = function(first, second, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(first)) {\n            throw new DeveloperError('first is required.');\n        }\n        if (!defined(second)) {\n            throw new DeveloperError('second is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.max(first.x, second.x);\n        result.y = Math.max(first.y, second.y);\n        return result;\n    };\n\n    /**\n     * Computes the provided Cartesian's squared magnitude.\n     *\n     * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n     * @returns {Number} The squared magnitude.\n     */\n    Cartesian2.magnitudeSquared = function(cartesian) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n    };\n\n    /**\n     * Computes the Cartesian's magnitude (length).\n     *\n     * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n     * @returns {Number} The magnitude.\n     */\n    Cartesian2.magnitude = function(cartesian) {\n        return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n    };\n\n    var distanceScratch = new Cartesian2();\n\n    /**\n     * Computes the distance between two points.\n     *\n     * @param {Cartesian2} left The first point to compute the distance from.\n     * @param {Cartesian2} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 1.0\n     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n     */\n    Cartesian2.distance = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian2.subtract(left, right, distanceScratch);\n        return Cartesian2.magnitude(distanceScratch);\n    };\n\n    /**\n     * Computes the squared distance between two points.  Comparing squared distances\n     * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n     *\n     * @param {Cartesian2} left The first point to compute the distance from.\n     * @param {Cartesian2} right The second point to compute the distance to.\n     * @returns {Number} The distance between two points.\n     *\n     * @example\n     * // Returns 4.0, not 2.0\n     * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n     */\n    Cartesian2.distanceSquared = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left) || !defined(right)) {\n            throw new DeveloperError('left and right are required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian2.subtract(left, right, distanceScratch);\n        return Cartesian2.magnitudeSquared(distanceScratch);\n    };\n\n    /**\n     * Computes the normalized form of the supplied Cartesian.\n     *\n     * @param {Cartesian2} cartesian The Cartesian to be normalized.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.normalize = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var magnitude = Cartesian2.magnitude(cartesian);\n\n        result.x = cartesian.x / magnitude;\n        result.y = cartesian.y / magnitude;\n        return result;\n    };\n\n    /**\n     * Computes the dot (scalar) product of two Cartesians.\n     *\n     * @param {Cartesian2} left The first Cartesian.\n     * @param {Cartesian2} right The second Cartesian.\n     * @returns {Number} The dot product.\n     */\n    Cartesian2.dot = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        return left.x * right.x + left.y * right.y;\n    };\n\n    /**\n     * Computes the componentwise product of two Cartesians.\n     *\n     * @param {Cartesian2} left The first Cartesian.\n     * @param {Cartesian2} right The second Cartesian.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.multiplyComponents = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x * right.x;\n        result.y = left.y * right.y;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise sum of two Cartesians.\n     *\n     * @param {Cartesian2} left The first Cartesian.\n     * @param {Cartesian2} right The second Cartesian.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x + right.x;\n        result.y = left.y + right.y;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise difference of two Cartesians.\n     *\n     * @param {Cartesian2} left The first Cartesian.\n     * @param {Cartesian2} right The second Cartesian.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x - right.x;\n        result.y = left.y - right.y;\n        return result;\n    };\n\n    /**\n     * Multiplies the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian2} cartesian The Cartesian to be scaled.\n     * @param {Number} scalar The scalar to multiply with.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x * scalar;\n        result.y = cartesian.y * scalar;\n        return result;\n    };\n\n    /**\n     * Divides the provided Cartesian componentwise by the provided scalar.\n     *\n     * @param {Cartesian2} cartesian The Cartesian to be divided.\n     * @param {Number} scalar The scalar to divide by.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.divideByScalar = function(cartesian, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = cartesian.x / scalar;\n        result.y = cartesian.y / scalar;\n        return result;\n    };\n\n    /**\n     * Negates the provided Cartesian.\n     *\n     * @param {Cartesian2} cartesian The Cartesian to be negated.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.negate = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = -cartesian.x;\n        result.y = -cartesian.y;\n        return result;\n    };\n\n    /**\n     * Computes the absolute value of the provided Cartesian.\n     *\n     * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.abs = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Math.abs(cartesian.x);\n        result.y = Math.abs(cartesian.y);\n        return result;\n    };\n\n    var lerpScratch = new Cartesian2();\n    /**\n     * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n     *\n     * @param {Cartesian2} start The value corresponding to t at 0.0.\n     * @param {Cartesian2} end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Cartesian2.lerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian2.multiplyByScalar(end, t, lerpScratch);\n        result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n        return Cartesian2.add(lerpScratch, result, result);\n    };\n\n    var angleBetweenScratch = new Cartesian2();\n    var angleBetweenScratch2 = new Cartesian2();\n    /**\n     * Returns the angle, in radians, between the provided Cartesians.\n     *\n     * @param {Cartesian2} left The first Cartesian.\n     * @param {Cartesian2} right The second Cartesian.\n     * @returns {Number} The angle between the Cartesians.\n     */\n    Cartesian2.angleBetween = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        Cartesian2.normalize(left, angleBetweenScratch);\n        Cartesian2.normalize(right, angleBetweenScratch2);\n        return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));\n    };\n\n    var mostOrthogonalAxisScratch = new Cartesian2();\n    /**\n     * Returns the axis that is most orthogonal to the provided Cartesian.\n     *\n     * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The most orthogonal axis.\n     */\n    Cartesian2.mostOrthogonalAxis = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n        Cartesian2.abs(f, f);\n\n        if (f.x <= f.y) {\n            result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n        } else {\n            result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n        }\n\n        return result;\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian2} [left] The first Cartesian.\n     * @param {Cartesian2} [right] The second Cartesian.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Cartesian2.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (left.x === right.x) &&\n                (left.y === right.y));\n    };\n\n    /**\n     * @private\n     */\n    Cartesian2.equalsArray = function(cartesian, array, offset) {\n        return cartesian.x === array[offset] &&\n               cartesian.y === array[offset + 1];\n    };\n\n    /**\n     * Compares the provided Cartesians componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian2} [left] The first Cartesian.\n     * @param {Cartesian2} [right] The second Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian2.equalsEpsilon = function(left, right, relativeEpsilon, absoluteEpsilon) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) &&\n                CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon));\n    };\n\n    /**\n     * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n     *\n     * @type {Cartesian2}\n     * @constant\n     */\n    Cartesian2.ZERO = freezeObject(new Cartesian2(0.0, 0.0));\n\n    /**\n     * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n     *\n     * @type {Cartesian2}\n     * @constant\n     */\n    Cartesian2.UNIT_X = freezeObject(new Cartesian2(1.0, 0.0));\n\n    /**\n     * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n     *\n     * @type {Cartesian2}\n     * @constant\n     */\n    Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0.0, 1.0));\n\n    /**\n     * Duplicates this Cartesian2 instance.\n     *\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n     */\n    Cartesian2.prototype.clone = function(result) {\n        return Cartesian2.clone(this, result);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Cartesian2} [right] The right hand side Cartesian.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Cartesian2.prototype.equals = function(right) {\n        return Cartesian2.equals(this, right);\n    };\n\n    /**\n     * Compares this Cartesian against the provided Cartesian componentwise and returns\n     * <code>true</code> if they pass an absolute or relative tolerance test,\n     * <code>false</code> otherwise.\n     *\n     * @param {Cartesian2} [right] The right hand side Cartesian.\n     * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n     * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Cartesian2.prototype.equalsEpsilon = function(right, relativeEpsilon, absoluteEpsilon) {\n        return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n    };\n\n    /**\n     * Creates a string representing this Cartesian in the format '(x, y)'.\n     *\n     * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n     */\n    Cartesian2.prototype.toString = function() {\n        return '(' + this.x + ', ' + this.y + ')';\n    };\n\n    return Cartesian2;\n});\n",
    "\n/*global define*/\ndefine('Renderer/WebGLConstants',[\n        '../Core/freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * WebGL constants.\n     *\n     * This file provides a workaround for Safari 9 where WebGL constants can't be accessed\n     * through WebGLRenderingContext.  See https://github.com/AnalyticalGraphicsInc/cesium/issues/2989\n     *\n     * @private\n     */\n    var WebGLConstants = {\n        DEPTH_BUFFER_BIT : 0x00000100,\n        STENCIL_BUFFER_BIT : 0x00000400,\n        COLOR_BUFFER_BIT : 0x00004000,\n        POINTS : 0x0000,\n        LINES : 0x0001,\n        LINE_LOOP : 0x0002,\n        LINE_STRIP : 0x0003,\n        TRIANGLES : 0x0004,\n        TRIANGLE_STRIP : 0x0005,\n        TRIANGLE_FAN : 0x0006,\n        ZERO : 0,\n        ONE : 1,\n        SRC_COLOR : 0x0300,\n        ONE_MINUS_SRC_COLOR : 0x0301,\n        SRC_ALPHA : 0x0302,\n        ONE_MINUS_SRC_ALPHA : 0x0303,\n        DST_ALPHA : 0x0304,\n        ONE_MINUS_DST_ALPHA : 0x0305,\n        DST_COLOR : 0x0306,\n        ONE_MINUS_DST_COLOR : 0x0307,\n        SRC_ALPHA_SATURATE : 0x0308,\n        FUNC_ADD : 0x8006,\n        BLEND_EQUATION : 0x8009,\n        BLEND_EQUATION_RGB : 0x8009, /* same as BLEND_EQUATION */\n        BLEND_EQUATION_ALPHA : 0x883D,\n        FUNC_SUBTRACT : 0x800A,\n        FUNC_REVERSE_SUBTRACT : 0x800B,\n        BLEND_DST_RGB : 0x80C8,\n        BLEND_SRC_RGB : 0x80C9,\n        BLEND_DST_ALPHA : 0x80CA,\n        BLEND_SRC_ALPHA : 0x80CB,\n        CONSTANT_COLOR : 0x8001,\n        ONE_MINUS_CONSTANT_COLOR : 0x8002,\n        CONSTANT_ALPHA : 0x8003,\n        ONE_MINUS_CONSTANT_ALPHA : 0x8004,\n        BLEND_COLOR : 0x8005,\n        ARRAY_BUFFER : 0x8892,\n        ELEMENT_ARRAY_BUFFER : 0x8893,\n        ARRAY_BUFFER_BINDING : 0x8894,\n        ELEMENT_ARRAY_BUFFER_BINDING : 0x8895,\n        STREAM_DRAW : 0x88E0,\n        STATIC_DRAW : 0x88E4,\n        DYNAMIC_DRAW : 0x88E8,\n        BUFFER_SIZE : 0x8764,\n        BUFFER_USAGE : 0x8765,\n        CURRENT_VERTEX_ATTRIB : 0x8626,\n        FRONT : 0x0404,\n        BACK : 0x0405,\n        FRONT_AND_BACK : 0x0408,\n        CULL_FACE : 0x0B44,\n        BLEND : 0x0BE2,\n        DITHER : 0x0BD0,\n        STENCIL_TEST : 0x0B90,\n        DEPTH_TEST : 0x0B71,\n        SCISSOR_TEST : 0x0C11,\n        POLYGON_OFFSET_FILL : 0x8037,\n        SAMPLE_ALPHA_TO_COVERAGE : 0x809E,\n        SAMPLE_COVERAGE : 0x80A0,\n        NO_ERROR : 0,\n        INVALID_ENUM : 0x0500,\n        INVALID_VALUE : 0x0501,\n        INVALID_OPERATION : 0x0502,\n        OUT_OF_MEMORY : 0x0505,\n        CW : 0x0900,\n        CCW : 0x0901,\n        LINE_WIDTH : 0x0B21,\n        ALIASED_POINT_SIZE_RANGE : 0x846D,\n        ALIASED_LINE_WIDTH_RANGE : 0x846E,\n        CULL_FACE_MODE : 0x0B45,\n        FRONT_FACE : 0x0B46,\n        DEPTH_RANGE : 0x0B70,\n        DEPTH_WRITEMASK : 0x0B72,\n        DEPTH_CLEAR_VALUE : 0x0B73,\n        DEPTH_FUNC : 0x0B74,\n        STENCIL_CLEAR_VALUE : 0x0B91,\n        STENCIL_FUNC : 0x0B92,\n        STENCIL_FAIL : 0x0B94,\n        STENCIL_PASS_DEPTH_FAIL : 0x0B95,\n        STENCIL_PASS_DEPTH_PASS : 0x0B96,\n        STENCIL_REF : 0x0B97,\n        STENCIL_VALUE_MASK : 0x0B93,\n        STENCIL_WRITEMASK : 0x0B98,\n        STENCIL_BACK_FUNC : 0x8800,\n        STENCIL_BACK_FAIL : 0x8801,\n        STENCIL_BACK_PASS_DEPTH_FAIL : 0x8802,\n        STENCIL_BACK_PASS_DEPTH_PASS : 0x8803,\n        STENCIL_BACK_REF : 0x8CA3,\n        STENCIL_BACK_VALUE_MASK : 0x8CA4,\n        STENCIL_BACK_WRITEMASK : 0x8CA5,\n        VIEWPORT : 0x0BA2,\n        SCISSOR_BOX : 0x0C10,\n        COLOR_CLEAR_VALUE : 0x0C22,\n        COLOR_WRITEMASK : 0x0C23,\n        UNPACK_ALIGNMENT : 0x0CF5,\n        PACK_ALIGNMENT : 0x0D05,\n        MAX_TEXTURE_SIZE : 0x0D33,\n        MAX_VIEWPORT_DIMS : 0x0D3A,\n        SUBPIXEL_BITS : 0x0D50,\n        RED_BITS : 0x0D52,\n        GREEN_BITS : 0x0D53,\n        BLUE_BITS : 0x0D54,\n        ALPHA_BITS : 0x0D55,\n        DEPTH_BITS : 0x0D56,\n        STENCIL_BITS : 0x0D57,\n        POLYGON_OFFSET_UNITS : 0x2A00,\n        POLYGON_OFFSET_FACTOR : 0x8038,\n        TEXTURE_BINDING_2D : 0x8069,\n        SAMPLE_BUFFERS : 0x80A8,\n        SAMPLES : 0x80A9,\n        SAMPLE_COVERAGE_VALUE : 0x80AA,\n        SAMPLE_COVERAGE_INVERT : 0x80AB,\n        COMPRESSED_TEXTURE_FORMATS : 0x86A3,\n        DONT_CARE : 0x1100,\n        FASTEST : 0x1101,\n        NICEST : 0x1102,\n        GENERATE_MIPMAP_HINT : 0x8192,\n        BYTE : 0x1400,\n        UNSIGNED_BYTE : 0x1401,\n        SHORT : 0x1402,\n        UNSIGNED_SHORT : 0x1403,\n        INT : 0x1404,\n        UNSIGNED_INT : 0x1405,\n        FLOAT : 0x1406,\n        DEPTH_COMPONENT : 0x1902,\n        ALPHA : 0x1906,\n        RGB : 0x1907,\n        RGBA : 0x1908,\n        LUMINANCE : 0x1909,\n        LUMINANCE_ALPHA : 0x190A,\n        UNSIGNED_SHORT_4_4_4_4 : 0x8033,\n        UNSIGNED_SHORT_5_5_5_1 : 0x8034,\n        UNSIGNED_SHORT_5_6_5 : 0x8363,\n        FRAGMENT_SHADER : 0x8B30,\n        VERTEX_SHADER : 0x8B31,\n        MAX_VERTEX_ATTRIBS : 0x8869,\n        MAX_VERTEX_UNIFORM_VECTORS : 0x8DFB,\n        MAX_VARYING_VECTORS : 0x8DFC,\n        MAX_COMBINED_TEXTURE_IMAGE_UNITS : 0x8B4D,\n        MAX_VERTEX_TEXTURE_IMAGE_UNITS : 0x8B4C,\n        MAX_TEXTURE_IMAGE_UNITS : 0x8872,\n        MAX_FRAGMENT_UNIFORM_VECTORS : 0x8DFD,\n        SHADER_TYPE : 0x8B4F,\n        DELETE_STATUS : 0x8B80,\n        LINK_STATUS : 0x8B82,\n        VALIDATE_STATUS : 0x8B83,\n        ATTACHED_SHADERS : 0x8B85,\n        ACTIVE_UNIFORMS : 0x8B86,\n        ACTIVE_ATTRIBUTES : 0x8B89,\n        SHADING_LANGUAGE_VERSION : 0x8B8C,\n        CURRENT_PROGRAM : 0x8B8D,\n        NEVER : 0x0200,\n        LESS : 0x0201,\n        EQUAL : 0x0202,\n        LEQUAL : 0x0203,\n        GREATER : 0x0204,\n        NOTEQUAL : 0x0205,\n        GEQUAL : 0x0206,\n        ALWAYS : 0x0207,\n        KEEP : 0x1E00,\n        REPLACE : 0x1E01,\n        INCR : 0x1E02,\n        DECR : 0x1E03,\n        INVERT : 0x150A,\n        INCR_WRAP : 0x8507,\n        DECR_WRAP : 0x8508,\n        VENDOR : 0x1F00,\n        RENDERER : 0x1F01,\n        VERSION : 0x1F02,\n        NEAREST : 0x2600,\n        LINEAR : 0x2601,\n        NEAREST_MIPMAP_NEAREST : 0x2700,\n        LINEAR_MIPMAP_NEAREST : 0x2701,\n        NEAREST_MIPMAP_LINEAR : 0x2702,\n        LINEAR_MIPMAP_LINEAR : 0x2703,\n        TEXTURE_MAG_FILTER : 0x2800,\n        TEXTURE_MIN_FILTER : 0x2801,\n        TEXTURE_WRAP_S : 0x2802,\n        TEXTURE_WRAP_T : 0x2803,\n        TEXTURE_2D : 0x0DE1,\n        TEXTURE : 0x1702,\n        TEXTURE_CUBE_MAP : 0x8513,\n        TEXTURE_BINDING_CUBE_MAP : 0x8514,\n        TEXTURE_CUBE_MAP_POSITIVE_X : 0x8515,\n        TEXTURE_CUBE_MAP_NEGATIVE_X : 0x8516,\n        TEXTURE_CUBE_MAP_POSITIVE_Y : 0x8517,\n        TEXTURE_CUBE_MAP_NEGATIVE_Y : 0x8518,\n        TEXTURE_CUBE_MAP_POSITIVE_Z : 0x8519,\n        TEXTURE_CUBE_MAP_NEGATIVE_Z : 0x851A,\n        MAX_CUBE_MAP_TEXTURE_SIZE : 0x851C,\n        TEXTURE0 : 0x84C0,\n        TEXTURE1 : 0x84C1,\n        TEXTURE2 : 0x84C2,\n        TEXTURE3 : 0x84C3,\n        TEXTURE4 : 0x84C4,\n        TEXTURE5 : 0x84C5,\n        TEXTURE6 : 0x84C6,\n        TEXTURE7 : 0x84C7,\n        TEXTURE8 : 0x84C8,\n        TEXTURE9 : 0x84C9,\n        TEXTURE10 : 0x84CA,\n        TEXTURE11 : 0x84CB,\n        TEXTURE12 : 0x84CC,\n        TEXTURE13 : 0x84CD,\n        TEXTURE14 : 0x84CE,\n        TEXTURE15 : 0x84CF,\n        TEXTURE16 : 0x84D0,\n        TEXTURE17 : 0x84D1,\n        TEXTURE18 : 0x84D2,\n        TEXTURE19 : 0x84D3,\n        TEXTURE20 : 0x84D4,\n        TEXTURE21 : 0x84D5,\n        TEXTURE22 : 0x84D6,\n        TEXTURE23 : 0x84D7,\n        TEXTURE24 : 0x84D8,\n        TEXTURE25 : 0x84D9,\n        TEXTURE26 : 0x84DA,\n        TEXTURE27 : 0x84DB,\n        TEXTURE28 : 0x84DC,\n        TEXTURE29 : 0x84DD,\n        TEXTURE30 : 0x84DE,\n        TEXTURE31 : 0x84DF,\n        ACTIVE_TEXTURE : 0x84E0,\n        REPEAT : 0x2901,\n        CLAMP_TO_EDGE : 0x812F,\n        MIRRORED_REPEAT : 0x8370,\n        FLOAT_VEC2 : 0x8B50,\n        FLOAT_VEC3 : 0x8B51,\n        FLOAT_VEC4 : 0x8B52,\n        INT_VEC2 : 0x8B53,\n        INT_VEC3 : 0x8B54,\n        INT_VEC4 : 0x8B55,\n        BOOL : 0x8B56,\n        BOOL_VEC2 : 0x8B57,\n        BOOL_VEC3 : 0x8B58,\n        BOOL_VEC4 : 0x8B59,\n        FLOAT_MAT2 : 0x8B5A,\n        FLOAT_MAT3 : 0x8B5B,\n        FLOAT_MAT4 : 0x8B5C,\n        SAMPLER_2D : 0x8B5E,\n        SAMPLER_CUBE : 0x8B60,\n        VERTEX_ATTRIB_ARRAY_ENABLED : 0x8622,\n        VERTEX_ATTRIB_ARRAY_SIZE : 0x8623,\n        VERTEX_ATTRIB_ARRAY_STRIDE : 0x8624,\n        VERTEX_ATTRIB_ARRAY_TYPE : 0x8625,\n        VERTEX_ATTRIB_ARRAY_NORMALIZED : 0x886A,\n        VERTEX_ATTRIB_ARRAY_POINTER : 0x8645,\n        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING : 0x889F,\n        IMPLEMENTATION_COLOR_READ_TYPE : 0x8B9A,\n        IMPLEMENTATION_COLOR_READ_FORMAT : 0x8B9B,\n        COMPILE_STATUS : 0x8B81,\n        LOW_FLOAT : 0x8DF0,\n        MEDIUM_FLOAT : 0x8DF1,\n        HIGH_FLOAT : 0x8DF2,\n        LOW_INT : 0x8DF3,\n        MEDIUM_INT : 0x8DF4,\n        HIGH_INT : 0x8DF5,\n        FRAMEBUFFER : 0x8D40,\n        RENDERBUFFER : 0x8D41,\n        RGBA4 : 0x8056,\n        RGB5_A1 : 0x8057,\n        RGB565 : 0x8D62,\n        DEPTH_COMPONENT16 : 0x81A5,\n        STENCIL_INDEX : 0x1901,\n        STENCIL_INDEX8 : 0x8D48,\n        DEPTH_STENCIL : 0x84F9,\n        RENDERBUFFER_WIDTH : 0x8D42,\n        RENDERBUFFER_HEIGHT : 0x8D43,\n        RENDERBUFFER_INTERNAL_FORMAT : 0x8D44,\n        RENDERBUFFER_RED_SIZE : 0x8D50,\n        RENDERBUFFER_GREEN_SIZE : 0x8D51,\n        RENDERBUFFER_BLUE_SIZE : 0x8D52,\n        RENDERBUFFER_ALPHA_SIZE : 0x8D53,\n        RENDERBUFFER_DEPTH_SIZE : 0x8D54,\n        RENDERBUFFER_STENCIL_SIZE : 0x8D55,\n        FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE : 0x8CD0,\n        FRAMEBUFFER_ATTACHMENT_OBJECT_NAME : 0x8CD1,\n        FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL : 0x8CD2,\n        FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE : 0x8CD3,\n        COLOR_ATTACHMENT0 : 0x8CE0,\n        DEPTH_ATTACHMENT : 0x8D00,\n        STENCIL_ATTACHMENT : 0x8D20,\n        DEPTH_STENCIL_ATTACHMENT : 0x821A,\n        NONE : 0,\n        FRAMEBUFFER_COMPLETE : 0x8CD5,\n        FRAMEBUFFER_INCOMPLETE_ATTACHMENT : 0x8CD6,\n        FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT : 0x8CD7,\n        FRAMEBUFFER_INCOMPLETE_DIMENSIONS : 0x8CD9,\n        FRAMEBUFFER_UNSUPPORTED : 0x8CDD,\n        FRAMEBUFFER_BINDING : 0x8CA6,\n        RENDERBUFFER_BINDING : 0x8CA7,\n        MAX_RENDERBUFFER_SIZE : 0x84E8,\n        INVALID_FRAMEBUFFER_OPERATION : 0x0506,\n        UNPACK_FLIP_Y_WEBGL : 0x9240,\n        UNPACK_PREMULTIPLY_ALPHA_WEBGL : 0x9241,\n        CONTEXT_LOST_WEBGL : 0x9242,\n        UNPACK_COLORSPACE_CONVERSION_WEBGL : 0x9243,\n        BROWSER_DEFAULT_WEBGL : 0x9244,\n\n        // Extensions\n        UNSIGNED_INT_24_8_WEBGL : 0x84FA,\n\n        // Desktop OpenGL\n        DOUBLE : 0x140A\n    };\n\n    return freezeObject(WebGLConstants);\n});\n",
    "\n/*global define*/\ndefine('Core/Fullscreen',[\n        './defined',\n        './defineProperties'\n    ], function(\n        defined,\n        defineProperties) {\n    \"use strict\";\n\n    var _supportsFullscreen;\n    var _names = {\n        requestFullscreen : undefined,\n        exitFullscreen : undefined,\n        fullscreenEnabled : undefined,\n        fullscreenElement : undefined,\n        fullscreenchange : undefined,\n        fullscreenerror : undefined\n    };\n\n    /**\n     * Browser-independent functions for working with the standard fullscreen API.\n     *\n     * @namespace\n     * @alias Fullscreen\n     *\n     * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n     */\n    var Fullscreen = {};\n\n    defineProperties(Fullscreen, {\n        /**\n         * The element that is currently fullscreen, if any.  To simply check if the\n         * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.\n         * @memberof Fullscreen\n         * @type {Object}\n         * @readonly\n         */\n        element : {\n            get : function() {\n                if (!Fullscreen.supportsFullscreen()) {\n                    return undefined;\n                }\n\n                return document[_names.fullscreenElement];\n            }\n        },\n\n        /**\n         * The name of the event on the document that is fired when fullscreen is\n         * entered or exited.  This event name is intended for use with addEventListener.\n         * In your event handler, to determine if the browser is in fullscreen mode or not,\n         * use {@link Fullscreen#fullscreen}.\n         * @memberof Fullscreen\n         * @type {String}\n         * @readonly\n         */\n        changeEventName : {\n            get : function() {\n                if (!Fullscreen.supportsFullscreen()) {\n                    return undefined;\n                }\n\n                return _names.fullscreenchange;\n            }\n        },\n\n        /**\n         * The name of the event that is fired when a fullscreen error\n         * occurs.  This event name is intended for use with addEventListener.\n         * @memberof Fullscreen\n         * @type {String}\n         * @readonly\n         */\n        errorEventName : {\n            get : function() {\n                if (!Fullscreen.supportsFullscreen()) {\n                    return undefined;\n                }\n\n                return _names.fullscreenerror;\n            }\n        },\n\n        /**\n         * Determine whether the browser will allow an element to be made fullscreen, or not.\n         * For example, by default, iframes cannot go fullscreen unless the containing page\n         * adds an \"allowfullscreen\" attribute (or prefixed equivalent).\n         * @memberof Fullscreen\n         * @type {Boolean}\n         * @readonly\n         */\n        enabled : {\n            get : function() {\n                if (!Fullscreen.supportsFullscreen()) {\n                    return undefined;\n                }\n\n                return document[_names.fullscreenEnabled];\n            }\n        },\n\n        /**\n         * Determines if the browser is currently in fullscreen mode.\n         * @memberof Fullscreen\n         * @type {Boolean}\n         * @readonly\n         */\n        fullscreen : {\n            get : function() {\n                if (!Fullscreen.supportsFullscreen()) {\n                    return undefined;\n                }\n\n                return Fullscreen.element !== null;\n            }\n        }\n    });\n\n    /**\n     * Detects whether the browser supports the standard fullscreen API.\n     *\n     * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,\n     * <code>false</code> otherwise.\n     */\n    Fullscreen.supportsFullscreen = function() {\n        if (defined(_supportsFullscreen)) {\n            return _supportsFullscreen;\n        }\n\n        _supportsFullscreen = false;\n\n        var body = document.body;\n        if (typeof body.requestFullscreen === 'function') {\n            // go with the unprefixed, standard set of names\n            _names.requestFullscreen = 'requestFullscreen';\n            _names.exitFullscreen = 'exitFullscreen';\n            _names.fullscreenEnabled = 'fullscreenEnabled';\n            _names.fullscreenElement = 'fullscreenElement';\n            _names.fullscreenchange = 'fullscreenchange';\n            _names.fullscreenerror = 'fullscreenerror';\n            _supportsFullscreen = true;\n            return _supportsFullscreen;\n        }\n\n        //check for the correct combination of prefix plus the various names that browsers use\n        var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];\n        var name;\n        for (var i = 0, len = prefixes.length; i < len; ++i) {\n            var prefix = prefixes[i];\n\n            // casing of Fullscreen differs across browsers\n            name = prefix + 'RequestFullscreen';\n            if (typeof body[name] === 'function') {\n                _names.requestFullscreen = name;\n                _supportsFullscreen = true;\n            } else {\n                name = prefix + 'RequestFullScreen';\n                if (typeof body[name] === 'function') {\n                    _names.requestFullscreen = name;\n                    _supportsFullscreen = true;\n                }\n            }\n\n            // disagreement about whether it's \"exit\" as per spec, or \"cancel\"\n            name = prefix + 'ExitFullscreen';\n            if (typeof document[name] === 'function') {\n                _names.exitFullscreen = name;\n            } else {\n                name = prefix + 'CancelFullScreen';\n                if (typeof document[name] === 'function') {\n                    _names.exitFullscreen = name;\n                }\n            }\n\n            // casing of Fullscreen differs across browsers\n            name = prefix + 'FullscreenEnabled';\n            if (defined(document[name])) {\n                _names.fullscreenEnabled = name;\n            } else {\n                name = prefix + 'FullScreenEnabled';\n                if (defined(document[name])) {\n                    _names.fullscreenEnabled = name;\n                }\n            }\n\n            // casing of Fullscreen differs across browsers\n            name = prefix + 'FullscreenElement';\n            if (defined(document[name])) {\n                _names.fullscreenElement = name;\n            } else {\n                name = prefix + 'FullScreenElement';\n                if (defined(document[name])) {\n                    _names.fullscreenElement = name;\n                }\n            }\n\n            // thankfully, event names are all lowercase per spec\n            name = prefix + 'fullscreenchange';\n            // event names do not have 'on' in the front, but the property on the document does\n            if (defined(document['on' + name])) {\n                //except on IE\n                if (prefix === 'ms') {\n                    name = 'MSFullscreenChange';\n                }\n                _names.fullscreenchange = name;\n            }\n\n            name = prefix + 'fullscreenerror';\n            if (defined(document['on' + name])) {\n                //except on IE\n                if (prefix === 'ms') {\n                    name = 'MSFullscreenError';\n                }\n                _names.fullscreenerror = name;\n            }\n        }\n\n        return _supportsFullscreen;\n    };\n\n    /**\n     * Asynchronously requests the browser to enter fullscreen mode on the given element.\n     * If fullscreen mode is not supported by the browser, does nothing.\n     *\n     * @param {Object} element The HTML element which will be placed into fullscreen mode.\n     *\n     * @example\n     * // Put the entire page into fullscreen.\n     * Cesium.Fullscreen.requestFullscreen(document.body)\n     *\n     * // Place only the Cesium canvas into fullscreen.\n     * Cesium.Fullscreen.requestFullscreen(scene.canvas)\n     */\n    Fullscreen.requestFullscreen = function(element) {\n        if (!Fullscreen.supportsFullscreen()) {\n            return;\n        }\n\n        element[_names.requestFullscreen]();\n    };\n\n    /**\n     * Asynchronously exits fullscreen mode.  If the browser is not currently\n     * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.\n     */\n    Fullscreen.exitFullscreen = function() {\n        if (!Fullscreen.supportsFullscreen()) {\n            return;\n        }\n\n        document[_names.exitFullscreen]();\n    };\n\n    return Fullscreen;\n});",
    "\n/*global define*/\ndefine('Core/FeatureDetection',[\n        './defaultValue',\n        './defined',\n        './Fullscreen'\n    ], function(\n        defaultValue,\n        defined,\n        Fullscreen) {\n    \"use strict\";\n\n    function extractVersion(versionString) {\n        var parts = versionString.split('.');\n        for (var i = 0, len = parts.length; i < len; ++i) {\n            parts[i] = parseInt(parts[i], 10);\n        }\n        return parts;\n    }\n\n    var isChromeResult;\n    var chromeVersionResult;\n    function isChrome() {\n        if (!defined(isChromeResult)) {\n            isChromeResult = false;\n\n            var fields = (/ Chrome\\/([\\.0-9]+)/).exec(navigator.userAgent);\n            if (fields !== null) {\n                isChromeResult = true;\n                chromeVersionResult = extractVersion(fields[1]);\n            }\n        }\n\n        return isChromeResult;\n    }\n\n    function chromeVersion() {\n        return isChrome() && chromeVersionResult;\n    }\n\n    var isSafariResult;\n    var safariVersionResult;\n    function isSafari() {\n        if (!defined(isSafariResult)) {\n            isSafariResult = false;\n\n            // Chrome contains Safari in the user agent too\n            if (!isChrome() && (/ Safari\\/[\\.0-9]+/).test(navigator.userAgent)) {\n                var fields = (/ Version\\/([\\.0-9]+)/).exec(navigator.userAgent);\n                if (fields !== null) {\n                    isSafariResult = true;\n                    safariVersionResult = extractVersion(fields[1]);\n                }\n            }\n        }\n\n        return isSafariResult;\n    }\n\n    function safariVersion() {\n        return isSafari() && safariVersionResult;\n    }\n\n    var isWebkitResult;\n    var webkitVersionResult;\n    function isWebkit() {\n        if (!defined(isWebkitResult)) {\n            isWebkitResult = false;\n\n            var fields = (/ AppleWebKit\\/([\\.0-9]+)(\\+?)/).exec(navigator.userAgent);\n            if (fields !== null) {\n                isWebkitResult = true;\n                webkitVersionResult = extractVersion(fields[1]);\n                webkitVersionResult.isNightly = !!fields[2];\n            }\n        }\n\n        return isWebkitResult;\n    }\n\n    function webkitVersion() {\n        return isWebkit() && webkitVersionResult;\n    }\n\n    var isInternetExplorerResult;\n    var internetExplorerVersionResult;\n    function isInternetExplorer() {\n        if (!defined(isInternetExplorerResult)) {\n            isInternetExplorerResult = false;\n\n            var fields;\n            if (navigator.appName === 'Microsoft Internet Explorer') {\n                fields = /MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(navigator.userAgent);\n                if (fields !== null) {\n                    isInternetExplorerResult = true;\n                    internetExplorerVersionResult = extractVersion(fields[1]);\n                }\n            } else if (navigator.appName === 'Netscape') {\n                fields = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(navigator.userAgent);\n                if (fields !== null) {\n                    isInternetExplorerResult = true;\n                    internetExplorerVersionResult = extractVersion(fields[1]);\n                }\n            }\n        }\n        return isInternetExplorerResult;\n    }\n\n    function internetExplorerVersion() {\n        return isInternetExplorer() && internetExplorerVersionResult;\n    }\n\n    var isFirefoxResult;\n    var firefoxVersionResult;\n    function isFirefox() {\n        if (!defined(isFirefoxResult)) {\n            isFirefoxResult = false;\n\n            var fields = /Firefox\\/([\\.0-9]+)/.exec(navigator.userAgent);\n            if (fields !== null) {\n                isFirefoxResult = true;\n                firefoxVersionResult = extractVersion(fields[1]);\n            }\n        }\n        return isFirefoxResult;\n    }\n\n    var isWindowsResult;\n    function isWindows() {\n        if (!defined(isWindowsResult)) {\n            isWindowsResult = /Windows/i.test(navigator.appVersion);\n        }\n        return isWindowsResult;\n    }\n\n\n    function firefoxVersion() {\n        return isFirefox() && firefoxVersionResult;\n    }\n\n    var hasPointerEvents;\n    function supportsPointerEvents() {\n        if (!defined(hasPointerEvents)) {\n            //While window.navigator.pointerEnabled is deprecated in the W3C specification\n            //we still need to use it if it exists in order to support browsers\n            //that rely on it, such as the Windows WebBrowser control which defines\n            //window.PointerEvent but sets window.navigator.pointerEnabled to false.\n            hasPointerEvents = defined(window.PointerEvent) && (!defined(window.navigator.pointerEnabled) || window.navigator.pointerEnabled);\n        }\n        return hasPointerEvents;\n    }\n\n    /**\n     * A set of functions to detect whether the current browser supports\n     * various features.\n     *\n     * @namespace\n     * @alias FeatureDetection\n     */\n    var FeatureDetection = {\n        isChrome : isChrome,\n        chromeVersion : chromeVersion,\n        isSafari : isSafari,\n        safariVersion : safariVersion,\n        isWebkit : isWebkit,\n        webkitVersion : webkitVersion,\n        isInternetExplorer : isInternetExplorer,\n        internetExplorerVersion : internetExplorerVersion,\n        isFirefox : isFirefox,\n        firefoxVersion : firefoxVersion,\n        isWindows : isWindows,\n        hardwareConcurrency : defaultValue(navigator.hardwareConcurrency, 3),\n        supportsPointerEvents : supportsPointerEvents\n    };\n\n    /**\n     * Detects whether the current browser supports the full screen standard.\n     *\n     * @returns {Boolean} true if the browser supports the full screen standard, false if not.\n     *\n     * @see Fullscreen\n     * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n     */\n    FeatureDetection.supportsFullscreen = function() {\n        return Fullscreen.supportsFullscreen();\n    };\n\n    /**\n     * Detects whether the current browser supports typed arrays.\n     *\n     * @returns {Boolean} true if the browser supports typed arrays, false if not.\n     *\n     * @see {@link http://www.khronos.org/registry/typedarray/specs/latest/|Typed Array Specification}\n     */\n    FeatureDetection.supportsTypedArrays = function() {\n        return typeof ArrayBuffer !== 'undefined';\n    };\n\n    /**\n     * Detects whether the current browser supports Web Workers.\n     *\n     * @returns {Boolean} true if the browsers supports Web Workers, false if not.\n     *\n     * @see {@link http://www.w3.org/TR/workers/}\n     */\n    FeatureDetection.supportsWebWorkers = function() {\n        return typeof Worker !== 'undefined';\n    };\n\n    return FeatureDetection;\n});",
    "\n/*global define*/\ndefine('Core/ComponentDatatype',[\n        '../Renderer/WebGLConstants',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './FeatureDetection',\n        './freezeObject'\n    ], function(\n        WebGLConstants,\n        defaultValue,\n        defined,\n        DeveloperError,\n        FeatureDetection,\n        freezeObject) {\n    \"use strict\";\n\n    // Bail out if the browser doesn't support typed arrays, to prevent the setup function\n    // from failing, since we won't be able to create a WebGL context anyway.\n    if (!FeatureDetection.supportsTypedArrays()) {\n        return {};\n    }\n\n    /**\n     * WebGL component datatypes.  Components are intrinsics,\n     * which form attributes, which form vertices.\n     *\n     * @namespace\n     * @alias ComponentDatatype\n     */\n    var ComponentDatatype = {\n        /**\n         * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type\n         * of an element in <code>Int8Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        BYTE : WebGLConstants.BYTE,\n\n        /**\n         * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n         * of an element in <code>Uint8Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_BYTE : WebGLConstants.UNSIGNED_BYTE,\n\n        /**\n         * 16-bit signed short corresponding to <code>SHORT</code> and the type\n         * of an element in <code>Int16Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        SHORT : WebGLConstants.SHORT,\n\n        /**\n         * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n         * of an element in <code>Uint16Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_SHORT : WebGLConstants.UNSIGNED_SHORT,\n\n        /**\n         * 32-bit floating-point corresponding to <code>FLOAT</code> and the type\n         * of an element in <code>Float32Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        FLOAT : WebGLConstants.FLOAT,\n\n        /**\n         * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;\n         * this is not supported in WebGL, and is emulated in Cesium via {@link GeometryPipeline.encodeAttribute})\n         * and the type of an element in <code>Float64Array</code>.\n         *\n         * @memberOf ComponentDatatype\n         *\n         * @type {Number}\n         * @constant\n         * @default 0x140A\n         */\n        DOUBLE : WebGLConstants.DOUBLE\n    };\n\n    /**\n     * Returns the size, in bytes, of the corresponding datatype.\n     *\n     * @param {ComponentDatatype} componentDatatype The component datatype to get the size of.\n     * @returns {Number} The size in bytes.\n     *\n     * @exception {DeveloperError} componentDatatype is not a valid value.\n     *\n     * @example\n     * // Returns Int8Array.BYTES_PER_ELEMENT\n     * var size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);\n     */\n    ComponentDatatype.getSizeInBytes = function(componentDatatype){\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(componentDatatype)) {\n            throw new DeveloperError('value is required.');\n        }\n        //>>includeEnd('debug');\n\n        switch (componentDatatype) {\n        case ComponentDatatype.BYTE:\n            return Int8Array.BYTES_PER_ELEMENT;\n        case ComponentDatatype.UNSIGNED_BYTE:\n            return Uint8Array.BYTES_PER_ELEMENT;\n        case ComponentDatatype.SHORT:\n            return Int16Array.BYTES_PER_ELEMENT;\n        case ComponentDatatype.UNSIGNED_SHORT:\n            return Uint16Array.BYTES_PER_ELEMENT;\n        case ComponentDatatype.FLOAT:\n            return Float32Array.BYTES_PER_ELEMENT;\n        case ComponentDatatype.DOUBLE:\n            return Float64Array.BYTES_PER_ELEMENT;\n        default:\n            throw new DeveloperError('componentDatatype is not a valid value.');\n        }\n    };\n\n    /**\n     * Gets the ComponentDatatype for the provided TypedArray instance.\n     *\n     * @param {TypedArray} array The typed array.\n     * @returns {ComponentDatatype} The ComponentDatatype for the provided array, or undefined if the array is not a TypedArray.\n     */\n    ComponentDatatype.fromTypedArray = function(array) {\n        if (array instanceof Int8Array) {\n            return ComponentDatatype.BYTE;\n        }\n        if (array instanceof Uint8Array) {\n            return ComponentDatatype.UNSIGNED_BYTE;\n        }\n        if (array instanceof Int16Array) {\n            return ComponentDatatype.SHORT;\n        }\n        if (array instanceof Uint16Array) {\n            return ComponentDatatype.UNSIGNED_SHORT;\n        }\n        if (array instanceof Float32Array) {\n            return ComponentDatatype.FLOAT;\n        }\n        if (array instanceof Float64Array) {\n            return ComponentDatatype.DOUBLE;\n        }\n    };\n\n    /**\n     * Validates that the provided component datatype is a valid {@link ComponentDatatype}\n     *\n     * @param {ComponentDatatype} componentDatatype The component datatype to validate.\n     * @returns {Boolean} <code>true</code> if the provided component datatype is a valid value; otherwise, <code>false</code>.\n     *\n     * @example\n     * if (!Cesium.ComponentDatatype.validate(componentDatatype)) {\n     *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');\n     * }\n     */\n    ComponentDatatype.validate = function(componentDatatype) {\n        return defined(componentDatatype) &&\n               (componentDatatype === ComponentDatatype.BYTE ||\n                componentDatatype === ComponentDatatype.UNSIGNED_BYTE ||\n                componentDatatype === ComponentDatatype.SHORT ||\n                componentDatatype === ComponentDatatype.UNSIGNED_SHORT ||\n                componentDatatype === ComponentDatatype.FLOAT ||\n                componentDatatype === ComponentDatatype.DOUBLE);\n    };\n\n    /**\n     * Creates a typed array corresponding to component data type.\n     *\n     * @param {ComponentDatatype} componentDatatype The component data type.\n     * @param {Number|Array} valuesOrLength The length of the array to create or an array.\n     * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Float32Array|Float64Array} A typed array.\n     *\n     * @exception {DeveloperError} componentDatatype is not a valid value.\n     *\n     * @example\n     * // creates a Float32Array with length of 100\n     * var typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);\n     */\n    ComponentDatatype.createTypedArray = function(componentDatatype, valuesOrLength) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(componentDatatype)) {\n            throw new DeveloperError('componentDatatype is required.');\n        }\n        if (!defined(valuesOrLength)) {\n            throw new DeveloperError('valuesOrLength is required.');\n        }\n        //>>includeEnd('debug');\n\n        switch (componentDatatype) {\n        case ComponentDatatype.BYTE:\n            return new Int8Array(valuesOrLength);\n        case ComponentDatatype.UNSIGNED_BYTE:\n            return new Uint8Array(valuesOrLength);\n        case ComponentDatatype.SHORT:\n            return new Int16Array(valuesOrLength);\n        case ComponentDatatype.UNSIGNED_SHORT:\n            return new Uint16Array(valuesOrLength);\n        case ComponentDatatype.FLOAT:\n            return new Float32Array(valuesOrLength);\n        case ComponentDatatype.DOUBLE:\n            return new Float64Array(valuesOrLength);\n        default:\n            throw new DeveloperError('componentDatatype is not a valid value.');\n        }\n    };\n\n    /**\n     * Creates a typed view of an array of bytes.\n     *\n     * @param {ComponentDatatype} componentDatatype The type of the view to create.\n     * @param {ArrayBuffer} buffer The buffer storage to use for the view.\n     * @param {Number} [byteOffset] The offset, in bytes, to the first element in the view.\n     * @param {Number} [length] The number of elements in the view.\n     * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Float32Array|Float64Array} A typed array view of the buffer.\n     *\n     * @exception {DeveloperError} componentDatatype is not a valid value.\n     */\n    ComponentDatatype.createArrayBufferView = function(componentDatatype, buffer, byteOffset, length) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(componentDatatype)) {\n            throw new DeveloperError('componentDatatype is required.');\n        }\n        if (!defined(buffer)) {\n            throw new DeveloperError('buffer is required.');\n        }\n        //>>includeEnd('debug');\n\n        byteOffset = defaultValue(byteOffset, 0);\n        length = defaultValue(length, (buffer.byteLength - byteOffset) / ComponentDatatype.getSizeInBytes(componentDatatype));\n\n        switch (componentDatatype) {\n        case ComponentDatatype.BYTE:\n            return new Int8Array(buffer, byteOffset, length);\n        case ComponentDatatype.UNSIGNED_BYTE:\n            return new Uint8Array(buffer, byteOffset, length);\n        case ComponentDatatype.SHORT:\n            return new Int16Array(buffer, byteOffset, length);\n        case ComponentDatatype.UNSIGNED_SHORT:\n            return new Uint16Array(buffer, byteOffset, length);\n        case ComponentDatatype.FLOAT:\n            return new Float32Array(buffer, byteOffset, length);\n        case ComponentDatatype.DOUBLE:\n            return new Float64Array(buffer, byteOffset, length);\n        default:\n            throw new DeveloperError('componentDatatype is not a valid value.');\n        }\n    };\n\n    return freezeObject(ComponentDatatype);\n});\n",
    "\n/*global define*/\ndefine('Core/GeometryType',[\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * @private\n     */\n    var GeometryType = {\n        NONE : 0,\n        TRIANGLES : 1,\n        LINES : 2,\n        POLYLINES : 3\n    };\n\n    return freezeObject(GeometryType);\n});\n",
    "\n/*global define*/\ndefine('Core/PrimitiveType',[\n        '../Renderer/WebGLConstants',\n        './freezeObject'\n    ], function(\n        WebGLConstants,\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * The type of a geometric primitive, i.e., points, lines, and triangles.\n     *\n     * @namespace\n     * @alias PrimitiveType\n     */\n    var PrimitiveType = {\n        /**\n         * Points primitive where each vertex (or index) is a separate point.\n         *\n         * @type {Number}\n         * @constant\n         */\n        POINTS : WebGLConstants.POINTS,\n\n        /**\n         * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\n         *\n         * @type {Number}\n         * @constant\n         */\n        LINES : WebGLConstants.LINES,\n\n        /**\n         * Line loop primitive where each vertex (or index) after the first connects a line to\n         * the previous vertex, and the last vertex implicitly connects to the first.\n         *\n         * @type {Number}\n         * @constant\n         */\n        LINE_LOOP : WebGLConstants.LINE_LOOP,\n\n        /**\n         * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\n         *\n         * @type {Number}\n         * @constant\n         */\n        LINE_STRIP : WebGLConstants.LINE_STRIP,\n\n        /**\n         * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\n         *\n         * @type {Number}\n         * @constant\n         */\n        TRIANGLES : WebGLConstants.TRIANGLES,\n\n        /**\n         * Triangle strip primitive where each vertex (or index) after the first two connect to\n         * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\n         *\n         * @type {Number}\n         * @constant\n         */\n        TRIANGLE_STRIP : WebGLConstants.TRIANGLE_STRIP,\n\n        /**\n         * Triangle fan primitive where each vertex (or index) after the first two connect to\n         * the previous vertex and the first vertex forming a triangle.  For example, this can be used\n         * to model a cone or circle.\n         *\n         * @type {Number}\n         * @constant\n         */\n        TRIANGLE_FAN : WebGLConstants.TRIANGLE_FAN,\n\n        /**\n         * @private\n         */\n        validate : function(primitiveType) {\n            return primitiveType === PrimitiveType.POINTS ||\n                   primitiveType === PrimitiveType.LINES ||\n                   primitiveType === PrimitiveType.LINE_LOOP ||\n                   primitiveType === PrimitiveType.LINE_STRIP ||\n                   primitiveType === PrimitiveType.TRIANGLES ||\n                   primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n                   primitiveType === PrimitiveType.TRIANGLE_FAN;\n        }\n    };\n\n    return freezeObject(PrimitiveType);\n});\n",
    "\n/*global define*/\ndefine('Core/Geometry',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './GeometryType',\n        './PrimitiveType'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        GeometryType,\n        PrimitiveType) {\n    \"use strict\";\n\n    /**\n     * A geometry representation with attributes forming vertices and optional index data\n     * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n     * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n     * be created from many heterogeneous - in many cases - geometries for performance.\n     * <p>\n     * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n     * </p>\n     *\n     * @alias Geometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n     * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n     * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n     * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n     *\n     * @see PolygonGeometry\n     * @see RectangleGeometry\n     * @see EllipseGeometry\n     * @see CircleGeometry\n     * @see WallGeometry\n     * @see SimplePolylineGeometry\n     * @see BoxGeometry\n     * @see EllipsoidGeometry\n     *\n     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n     *\n     * @example\n     * // Create geometry with a position attribute and indexed lines.\n     * var positions = new Float64Array([\n     *   0.0, 0.0, 0.0,\n     *   7500000.0, 0.0, 0.0,\n     *   0.0, 7500000.0, 0.0\n     * ]);\n     *\n     * var geometry = new Cesium.Geometry({\n     *   attributes : {\n     *     position : new Cesium.GeometryAttribute({\n     *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n     *       componentsPerAttribute : 3,\n     *       values : positions\n     *     })\n     *   },\n     *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n     *   primitiveType : Cesium.PrimitiveType.LINES,\n     *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n     * });\n     */\n    var Geometry = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(options.attributes)) {\n            throw new DeveloperError('options.attributes is required.');\n        }\n        //>>includeEnd('debug');\n\n        /**\n         * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n         * {@link GeometryAttribute} containing the attribute's data.\n         * <p>\n         * Attributes are always stored non-interleaved in a Geometry.\n         * </p>\n         * <p>\n         * There are reserved attribute names with well-known semantics.  The following attributes\n         * are created by a Geometry (depending on the provided {@link VertexFormat}.\n         * <ul>\n         *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n         *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n         *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n         *    <li><code>binormal</code> - Binormal (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#binormal}.</li>\n         *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n         * </ul>\n         * </p>\n         * <p>\n         * The following attribute names are generally not created by a Geometry, but are added\n         * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n         * the geometry for rendering.\n         * <ul>\n         *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n         *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n         *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n         *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n         *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n         *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n         * </ul>\n         * </p>\n         *\n         * @type GeometryAttributes\n         *\n         * @default undefined\n         *\n         * @see GeometryAttribute\n         * @see VertexFormat\n         *\n         * @example\n         * geometry.attributes.position = new Cesium.GeometryAttribute({\n         *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n         *   componentsPerAttribute : 3,\n         *   values : new Float32Array(0)\n         * });\n         */\n        this.attributes = options.attributes;\n\n        /**\n         * Optional index data that - along with {@link Geometry#primitiveType} -\n         * determines the primitives in the geometry.\n         *\n         * @type Array\n         *\n         * @default undefined\n         */\n        this.indices = options.indices;\n\n        /**\n         * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n         * but can varying based on the specific geometry.\n         *\n         * @type PrimitiveType\n         *\n         * @default undefined\n         */\n        this.primitiveType = defaultValue(options.primitiveType, PrimitiveType.TRIANGLES);\n\n        /**\n         * An optional bounding sphere that fully encloses the geometry.  This is\n         * commonly used for culling.\n         *\n         * @type BoundingSphere\n         *\n         * @default undefined\n         */\n        this.boundingSphere = options.boundingSphere;\n\n        /**\n         * @private\n         */\n        this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\n\n        /**\n         * @private\n         */\n        this.boundingSphereCV = undefined;\n    };\n\n    /**\n     * Computes the number of vertices in a geometry.  The runtime is linear with\n     * respect to the number of attributes in a vertex, not the number of vertices.\n     *\n     * @param {Geometry} geometry The geometry.\n     * @returns {Number} The number of vertices in the geometry.\n     *\n     * @example\n     * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n     */\n    Geometry.computeNumberOfVertices = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var numberOfVertices = -1;\n        for ( var property in geometry.attributes) {\n            if (geometry.attributes.hasOwnProperty(property) &&\n                    defined(geometry.attributes[property]) &&\n                    defined(geometry.attributes[property].values)) {\n\n                var attribute = geometry.attributes[property];\n                var num = attribute.values.length / attribute.componentsPerAttribute;\n                if ((numberOfVertices !== num) && (numberOfVertices !== -1)) {\n                    throw new DeveloperError('All attribute lists must have the same number of attributes.');\n                }\n                numberOfVertices = num;\n            }\n        }\n\n        return numberOfVertices;\n    };\n\n    return Geometry;\n});\n",
    "\n/*global define*/\ndefine('Core/GeometryAttribute',[\n        './defaultValue',\n        './defined',\n        './DeveloperError'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Values and type information for geometry attributes.  A {@link Geometry}\n     * generally contains one or more attributes.  All attributes together form\n     * the geometry's vertices.\n     *\n     * @alias GeometryAttribute\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.\n     * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.\n     * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n     * @param {TypedArray} [options.values] The values for the attributes stored in a typed array.\n     *\n     * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n     *\n     * @see Geometry\n     *\n     * @example\n     * var geometry = new Cesium.Geometry({\n     *   attributes : {\n     *     position : new Cesium.GeometryAttribute({\n     *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n     *       componentsPerAttribute : 3,\n     *       values : new Float32Array([\n     *         0.0, 0.0, 0.0,\n     *         7500000.0, 0.0, 0.0,\n     *         0.0, 7500000.0, 0.0\n     *       ])\n     *     })\n     *   },\n     *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n     * });\n     */\n    var GeometryAttribute = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(options.componentDatatype)) {\n            throw new DeveloperError('options.componentDatatype is required.');\n        }\n        if (!defined(options.componentsPerAttribute)) {\n            throw new DeveloperError('options.componentsPerAttribute is required.');\n        }\n        if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {\n            throw new DeveloperError('options.componentsPerAttribute must be between 1 and 4.');\n        }\n        if (!defined(options.values)) {\n            throw new DeveloperError('options.values is required.');\n        }\n        //>>includeEnd('debug');\n\n        /**\n         * The datatype of each component in the attribute, e.g., individual elements in\n         * {@link GeometryAttribute#values}.\n         *\n         * @type ComponentDatatype\n         *\n         * @default undefined\n         */\n        this.componentDatatype = options.componentDatatype;\n\n        /**\n         * A number between 1 and 4 that defines the number of components in an attributes.\n         * For example, a position attribute with x, y, and z components would have 3 as\n         * shown in the code example.\n         *\n         * @type Number\n         *\n         * @default undefined\n         *\n         * @example\n         * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n         * attribute.componentsPerAttribute = 3;\n         * attribute.values = new Float32Array([\n         *   0.0, 0.0, 0.0,\n         *   7500000.0, 0.0, 0.0,\n         *   0.0, 7500000.0, 0.0\n         * ]);\n         */\n        this.componentsPerAttribute = options.componentsPerAttribute;\n\n        /**\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n         * <p>\n         * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         *\n         * @example\n         * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n         * attribute.componentsPerAttribute = 4;\n         * attribute.normalize = true;\n         * attribute.values = new Uint8Array([\n         *   Cesium.Color.floatToByte(color.red),\n         *   Cesium.Color.floatToByte(color.green),\n         *   Cesium.Color.floatToByte(color.blue),\n         *   Cesium.Color.floatToByte(color.alpha)\n         * ]);\n         */\n        this.normalize = defaultValue(options.normalize, false);\n\n        /**\n         * The values for the attributes stored in a typed array.  In the code example,\n         * every three elements in <code>values</code> defines one attributes since\n         * <code>componentsPerAttribute</code> is 3.\n         *\n         * @type TypedArray\n         *\n         * @default undefined\n         *\n         * @example\n         * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n         * attribute.componentsPerAttribute = 3;\n         * attribute.values = new Float32Array([\n         *   0.0, 0.0, 0.0,\n         *   7500000.0, 0.0, 0.0,\n         *   0.0, 7500000.0, 0.0\n         * ]);\n         */\n        this.values = options.values;\n    };\n\n    return GeometryAttribute;\n});\n",
    "\n/*global define*/\ndefine('Core/GeometryAttributes',[\n        './defaultValue'\n    ], function(\n        defaultValue) {\n    \"use strict\";\n\n    /**\n     * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a\n     * {@link GeometryAttribute} containing the attribute's data.\n     * <p>\n     * Attributes are always stored non-interleaved in a Geometry.\n     * </p>\n     *\n     * @alias GeometryAttributes\n     * @constructor\n     */\n    var GeometryAttributes = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        /**\n         * The 3D position attribute.\n         * <p>\n         * 64-bit floating-point (for precision).  3 components per attribute.\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.position = options.position;\n\n        /**\n         * The normal attribute (normalized), which is commonly used for lighting.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.normal = options.normal;\n\n        /**\n         * The 2D texture coordinate attribute.\n         * <p>\n         * 32-bit floating-point.  2 components per attribute\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.st = options.st;\n\n        /**\n         * The binormal attribute (normalized), which is used for tangent-space effects like bump mapping.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.binormal = options.binormal;\n\n        /**\n         * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.tangent = options.tangent;\n\n        /**\n         * The color attribute.\n         * <p>\n         * 8-bit unsigned integer. 4 components per attribute.\n         * </p>\n         *\n         * @type GeometryAttribute\n         *\n         * @default undefined\n         */\n        this.color = options.color;\n    };\n\n    return GeometryAttributes;\n});",
    "\n/*global define*/\ndefine('Core/GeometryInstance',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Matrix4'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        Matrix4) {\n    \"use strict\";\n\n    /**\n     * Geometry instancing allows one {@link Geometry} object to be positions in several\n     * different locations and colored uniquely.  For example, one {@link BoxGeometry} can\n     * be instanced several times, each with a different <code>modelMatrix</code> to change\n     * its position, rotation, and scale.\n     *\n     * @alias GeometryInstance\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Geometry} options.geometry The geometry to instance.\n     * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix that transforms to transform the geometry from model to world coordinates.\n     * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.\n     * @param {Object} [options.attributes] Per-instance attributes like a show or color attribute shown in the example below.\n     *\n     * @see Geometry\n     *\n     * @example\n     * // Create geometry for a box, and two instances that refer to it.\n     * // One instance positions the box on the bottom and colored aqua.\n     * // The other instance positions the box on the top and color white.\n     * var geometry = Cesium.BoxGeometry.fromDimensions({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n     *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n     * });\n     * var instanceBottom = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n     *   attributes : {\n     *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n     *   },\n     *   id : 'bottom'\n     * });\n     * var instanceTop = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),\n     *   attributes : {\n     *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n     *   },\n     *   id : 'top'\n     * });\n     */\n    var GeometryInstance = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(options.geometry)) {\n            throw new DeveloperError('options.geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        /**\n         * The geometry being instanced.\n         *\n         * @type Geometry\n         *\n         * @default undefined\n         */\n        this.geometry = options.geometry;\n\n        /**\n         * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.\n         * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n         * Local reference frames can be used by providing a different transformation matrix, like that returned\n         * by {@link Transforms.eastNorthUpToFixedFrame}.\n         *\n         * @type Matrix4\n         *\n         * @default Matrix4.IDENTITY\n         */\n        this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n\n        /**\n         * User-defined object returned when the instance is picked or used to get/set per-instance attributes.\n         *\n         * @type Object\n         *\n         * @default undefined\n         *\n         * @see Scene#pick\n         * @see Primitive#getGeometryInstanceAttributes\n         */\n        this.id = options.id;\n\n        /**\n         * Used for picking primitives that wrap geometry instances.\n         *\n         * @private\n         */\n        this.pickPrimitive = options.pickPrimitive;\n\n        /**\n         * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.\n         * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.\n         *\n         * @type Object\n         *\n         * @default undefined\n         */\n        this.attributes = defaultValue(options.attributes, {});\n\n        /**\n         * @private\n         */\n        this.westHemisphereGeometry = undefined;\n        /**\n         * @private\n         */\n        this.eastHemisphereGeometry = undefined;\n    };\n\n    return GeometryInstance;\n});\n",
    "\n/*global define*/\ndefine('Core/AttributeCompression',[\n        './Cartesian2',\n        './Cartesian3',\n        './defined',\n        './DeveloperError',\n        './Math'\n    ], function(\n        Cartesian2,\n        Cartesian3,\n        defined,\n        DeveloperError,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * Attribute compression and decompression functions.\n     *\n     * @namespace\n     * @alias AttributeCompression\n     *\n     * @private\n     */\n    var AttributeCompression = {};\n\n    /**\n     * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n     *\n     * Oct encoding is a compact representation of unit length vectors.  The encoding and decoding functions are low cost, and represent the normalized vector within 1 degree of error.\n     * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n     * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n     *\n     * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n     * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n     * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n     *\n     * @exception {DeveloperError} vector must be defined.\n     * @exception {DeveloperError} result must be defined.\n     * @exception {DeveloperError} vector must be normalized.\n     *\n     * @see AttributeCompression.octDecode\n     */\n    AttributeCompression.octEncode = function(vector, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(vector)) {\n            throw new DeveloperError('vector is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        var magSquared = Cartesian3.magnitudeSquared(vector);\n        if (Math.abs(magSquared - 1.0) > CesiumMath.EPSILON6) {\n            throw new DeveloperError('vector must be normalized.');\n        }\n        //>>includeEnd('debug');\n\n        result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n        result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n        if (vector.z < 0) {\n            var x = result.x;\n            var y = result.y;\n            result.x = (1.0 - Math.abs(y)) * CesiumMath.signNotZero(x);\n            result.y = (1.0 - Math.abs(x)) * CesiumMath.signNotZero(y);\n        }\n\n        result.x = CesiumMath.toSNorm(result.x);\n        result.y = CesiumMath.toSNorm(result.y);\n\n        return result;\n    };\n\n    /**\n     * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n     *\n     * @param {Number} x The x component of the oct-encoded unit length vector.\n     * @param {Number} y The y component of the oct-encoded unit length vector.\n     * @param {Cartesian3} result The decoded and normalized vector\n     * @returns {Cartesian3} The decoded and normalized vector.\n     *\n     * @exception {DeveloperError} result must be defined.\n     * @exception {DeveloperError} x and y must be a signed normalized integer between 0 and 255.\n     *\n     * @see AttributeCompression.octEncode\n     */\n    AttributeCompression.octDecode = function(x, y, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        if (x < 0 || x > 255 || y < 0 || y > 255) {\n            throw new DeveloperError('x and y must be a signed normalized integer between 0 and 255');\n        }\n        //>>includeEnd('debug');\n\n        result.x = CesiumMath.fromSNorm(x);\n        result.y = CesiumMath.fromSNorm(y);\n        result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n        if (result.z < 0.0)\n        {\n            var oldVX = result.x;\n            result.x = (1.0 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);\n            result.y = (1.0 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);\n        }\n\n        return Cartesian3.normalize(result, result);\n    };\n\n    /**\n     * Packs an oct encoded vector into a single floating-point number.\n     *\n     * @param {Cartesian2} encoded The oct encoded vector.\n     * @returns {Number} The oct encoded vector packed into a single float.\n     *\n     * @exception {DeveloperError} encoded is required.\n     */\n    AttributeCompression.octPackFloat = function(encoded) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(encoded)) {\n            throw new DeveloperError('encoded is required.');\n        }\n        //>>includeEnd('debug');\n        return 256.0 * encoded.x + encoded.y;\n    };\n\n    var scratchEncodeCart2 = new Cartesian2();\n\n    /**\n     * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n     * stores those values in a single float-point number.\n     *\n     * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n     * @returns {Number} The 2 byte oct-encoded unit length vector.\n     *\n     * @exception {DeveloperError} vector must be defined.\n     * @exception {DeveloperError} vector must be normalized.\n     */\n    AttributeCompression.octEncodeFloat = function(vector) {\n        AttributeCompression.octEncode(vector, scratchEncodeCart2);\n        return AttributeCompression.octPackFloat(scratchEncodeCart2);\n    };\n\n    /**\n     * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n     *\n     * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n     * @param {Cartesian3} result The decoded and normalized vector\n     * @returns {Cartesian3} The decoded and normalized vector.\n     *\n     * @exception {DeveloperError} value must be defined.\n     * @exception {DeveloperError} result must be defined.\n     */\n    AttributeCompression.octDecodeFloat = function(value, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required.');\n        }\n        //>>includeEnd('debug');\n\n        var temp = value / 256.0;\n        var x = Math.floor(temp);\n        var y = (temp - x) * 256.0;\n\n        return AttributeCompression.octDecode(x, y, result);\n    };\n\n    /**\n     * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n     * packs those into two floating-point numbers.\n     *\n     * @param {Cartesian3} v1 A normalized vector to be compressed.\n     * @param {Cartesian3} v2 A normalized vector to be compressed.\n     * @param {Cartesian3} v3 A normalized vector to be compressed.\n     * @param {Cartesian2} result The 'oct' encoded vectors packed into two floating-point numbers.\n     * @returns {Cartesian2} The 'oct' encoded vectors packed into two floating-point numbers.\n     *\n     * @exception {DeveloperError} v1 must be defined.\n     * @exception {DeveloperError} v2 must be defined.\n     * @exception {DeveloperError} v3 must be defined.\n     * @exception {DeveloperError} result must be defined.\n     */\n    AttributeCompression.octPack = function(v1, v2, v3, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(v1)) {\n            throw new DeveloperError('v1 is required.');\n        }\n        if (!defined(v2)) {\n            throw new DeveloperError('v2 is required.');\n        }\n        if (!defined(v3)) {\n            throw new DeveloperError('v3 is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var encoded1 = AttributeCompression.octEncodeFloat(v1);\n        var encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n        var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n        result.x = 65536.0 * encoded3.x + encoded1;\n        result.y = 65536.0 * encoded3.y + encoded2;\n        return result;\n    };\n\n    /**\n     * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n     *\n     * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n     * @param {Cartesian3} v1 One decoded and normalized vector.\n     * @param {Cartesian3} v2 One decoded and normalized vector.\n     * @param {Cartesian3} v3 One decoded and normalized vector.\n     *\n     * @exception {DeveloperError} packed must be defined.\n     * @exception {DeveloperError} v1 must be defined.\n     * @exception {DeveloperError} v2 must be defined.\n     * @exception {DeveloperError} v3 must be defined.\n     */\n    AttributeCompression.octUnpack = function(packed, v1, v2, v3) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(packed)) {\n            throw new DeveloperError('packed is required.');\n        }\n        if (!defined(v1)) {\n            throw new DeveloperError('v1 is required.');\n        }\n        if (!defined(v2)) {\n            throw new DeveloperError('v2 is required.');\n        }\n        if (!defined(v3)) {\n            throw new DeveloperError('v3 is required.');\n        }\n        //>>includeEnd('debug');\n\n        var temp = packed.x / 65536.0;\n        var x = Math.floor(temp);\n        var encodedFloat1 = (temp - x) * 65536.0;\n\n        temp = packed.y / 65536.0;\n        var y = Math.floor(temp);\n        var encodedFloat2 = (temp - y) * 65536.0;\n\n        AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n        AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n        AttributeCompression.octDecode(x, y, v3);\n    };\n\n    /**\n     * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n     *\n     * @param {Cartesian2} textureCoordinates The texture coordinates to compress\n     * @returns {Number} The packed texture coordinates.\n     *\n     * @exception {DeveloperError} textureCoordinates is required.\n     */\n    AttributeCompression.compressTextureCoordinates = function(textureCoordinates) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(textureCoordinates)) {\n            throw new DeveloperError('textureCoordinates is required.');\n        }\n        //>>includeEnd('debug');\n\n        var x = textureCoordinates.x === 1.0 ? 4095.0 : (textureCoordinates.x * 4096.0) | 0;\n        var y = textureCoordinates.y === 1.0 ? 4095.0 : (textureCoordinates.y * 4096.0) | 0;\n        return 4096.0 * x + y;\n    };\n\n    /**\n     * Decompresses texture coordinates that were packed into a single float.\n     *\n     * @param {Number} compressed The compressed texture coordinates.\n     * @param {Cartesian2} result The decompressed texture coordinates.\n     * @returns {Cartesian2} The modified result parameter.\n     *\n     * @exception {DeveloperError} compressed is required.\n     * @exception {DeveloperError} result is required.\n     */\n    AttributeCompression.decompressTextureCoordinates = function(compressed, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(compressed)) {\n            throw new DeveloperError('compressed is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var temp = compressed / 4096.0;\n        result.x = Math.floor(temp) / 4096.0;\n        result.y = temp - Math.floor(temp);\n        return result;\n    };\n\n    return AttributeCompression;\n});",
    "\n/*global define*/\ndefine('Core/barycentricCoordinates',[\n        './Cartesian2',\n        './Cartesian3',\n        './defined',\n        './DeveloperError'\n    ], function(\n        Cartesian2,\n        Cartesian3,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n\n    /**\n     * Computes the barycentric coordinates for a point with respect to a triangle.\n     *\n     * @exports barycentricCoordinates\n     *\n     * @param {Cartesian2|Cartesian3} point The point to test.\n     * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.\n     * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.\n     * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n     *\n     * @example\n     * // Returns Cartesian3.UNIT_X\n     * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);\n     * var b = Cesium.barycentricCoordinates(p,\n     *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),\n     *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),\n     *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));\n     */\n    var barycentricCoordinates = function(point, p0, p1, p2, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(point) || !defined(p0) || !defined(p1) || !defined(p2)) {\n            throw new DeveloperError('point, p0, p1, and p2 are required.');\n        }\n        //>>includeEnd('debug');\n\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.\n        var v0, v1, v2;\n        var dot00, dot01, dot02, dot11, dot12;\n\n        if(!defined(p0.z)) {\n          v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);\n          v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);\n          v2 = Cartesian2.subtract(point, p0, scratchCartesian3);\n\n          dot00 = Cartesian2.dot(v0, v0);\n          dot01 = Cartesian2.dot(v0, v1);\n          dot02 = Cartesian2.dot(v0, v2);\n          dot11 = Cartesian2.dot(v1, v1);\n          dot12 = Cartesian2.dot(v1, v2);\n        } else {\n          v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);\n          v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);\n          v2 = Cartesian3.subtract(point, p0, scratchCartesian3);\n\n          dot00 = Cartesian3.dot(v0, v0);\n          dot01 = Cartesian3.dot(v0, v1);\n          dot02 = Cartesian3.dot(v0, v2);\n          dot11 = Cartesian3.dot(v1, v1);\n          dot12 = Cartesian3.dot(v1, v2);\n        }\n\n        var q = 1.0 / (dot00 * dot11 - dot01 * dot01);\n        result.y = (dot11 * dot02 - dot01 * dot12) * q;\n        result.z = (dot00 * dot12 - dot01 * dot02) * q;\n        result.x = 1.0 - result.y - result.z;\n        return result;\n    };\n\n    return barycentricCoordinates;\n});\n",
    "\n/*global define*/\ndefine('Core/EncodedCartesian3',[\n        './Cartesian3',\n        './defined',\n        './DeveloperError'\n    ], function(\n        Cartesian3,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}\n     * values that, when converted to 32-bit floating-point and added, approximate the original input.\n     * <p>\n     * This is used to encode positions in vertex buffers for rendering without jittering artifacts\n     * as described in {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.\n     * </p>\n     *\n     * @alias EncodedCartesian3\n     * @constructor\n     *\n     * @private\n     */\n    var EncodedCartesian3 = function() {\n        /**\n         * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.\n         *\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.high = Cartesian3.clone(Cartesian3.ZERO);\n\n        /**\n         * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.\n         *\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.low = Cartesian3.clone(Cartesian3.ZERO);\n    };\n\n    /**\n     * Encodes a 64-bit floating-point value as two floating-point values that, when converted to\n     * 32-bit floating-point and added, approximate the original input.  The returned object\n     * has <code>high</code> and <code>low</code> properties for the high and low bits, respectively.\n     * <p>\n     * The fixed-point encoding follows {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.\n     * </p>\n     *\n     * @param {Number} value The floating-point value to encode.\n     * @param {Object} [result] The object onto which to store the result.\n     * @returns {Object} The modified result parameter or a new instance if one was not provided.\n     *\n     * @example\n     * var value = 1234567.1234567;\n     * var splitValue = Cesium.EncodedCartesian3.encode(value);\n     */\n    EncodedCartesian3.encode = function(value, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = {\n                high : 0.0,\n                low : 0.0\n            };\n        }\n\n        var doubleHigh;\n        if (value >= 0.0) {\n            doubleHigh = Math.floor(value / 65536.0) * 65536.0;\n            result.high = doubleHigh;\n            result.low = value - doubleHigh;\n        } else {\n            doubleHigh = Math.floor(-value / 65536.0) * 65536.0;\n            result.high = -doubleHigh;\n            result.low = value + doubleHigh;\n        }\n\n        return result;\n    };\n\n    var scratchEncode = {\n        high : 0.0,\n        low : 0.0\n    };\n\n    /**\n     * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}\n     * values that, when converted to 32-bit floating-point and added, approximate the original input.\n     * <p>\n     * The fixed-point encoding follows {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.\n     * </p>\n     *\n     * @param {Cartesian3} cartesian The cartesian to encode.\n     * @param {EncodedCartesian3} [result] The object onto which to store the result.\n     * @returns {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.\n     *\n     * @example\n     * var cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n     * var encoded = Cesium.EncodedCartesian3.fromCartesian(cart);\n     */\n    EncodedCartesian3.fromCartesian = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new EncodedCartesian3();\n        }\n\n        var high = result.high;\n        var low = result.low;\n\n        EncodedCartesian3.encode(cartesian.x, scratchEncode);\n        high.x = scratchEncode.high;\n        low.x = scratchEncode.low;\n\n        EncodedCartesian3.encode(cartesian.y, scratchEncode);\n        high.y = scratchEncode.high;\n        low.y = scratchEncode.low;\n\n        EncodedCartesian3.encode(cartesian.z, scratchEncode);\n        high.z = scratchEncode.high;\n        low.z = scratchEncode.low;\n\n        return result;\n    };\n\n    var encodedP = new EncodedCartesian3();\n\n    /**\n     * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>\n     * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.\n     * <p>\n     * This is used to create interleaved high-precision position vertex attributes.\n     * </p>\n     *\n     * @param {Cartesian3} cartesian The cartesian to encode.\n     * @param {Number[]} cartesianArray The array to write to.\n     * @param {Number} index The index into the array to start writing.  Six elements will be written.\n     *\n     * @exception {DeveloperError} index must be a number greater than or equal to 0.\n     *\n     * @example\n     * var positions = [\n     *    new Cesium.Cartesian3(),\n     *    // ...\n     * ];\n     * var encodedPositions = new Float32Array(2 * 3 * positions.length);\n     * var j = 0;\n     * for (var i = 0; i < positions.length; ++i) {\n     *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n     *   j += 6;\n     * }\n     */\n    EncodedCartesian3.writeElements = function(cartesian, cartesianArray, index) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(cartesianArray)) {\n            throw new DeveloperError('cartesianArray is required');\n        }\n        if (typeof index !== 'number' || index < 0) {\n            throw new DeveloperError('index must be a number greater than or equal to 0.');\n        }\n        //>>includeEnd('debug');\n\n        EncodedCartesian3.fromCartesian(cartesian, encodedP);\n        var high = encodedP.high;\n        var low = encodedP.low;\n\n        cartesianArray[index] = high.x;\n        cartesianArray[index + 1] = high.y;\n        cartesianArray[index + 2] = high.z;\n        cartesianArray[index + 3] = low.x;\n        cartesianArray[index + 4] = low.y;\n        cartesianArray[index + 5] = low.z;\n    };\n\n    return EncodedCartesian3;\n});\n",
    "\n/*global define*/\ndefine('Core/IndexDatatype',[\n        '../Renderer/WebGLConstants',\n        './defined',\n        './DeveloperError',\n        './freezeObject',\n        './Math'\n    ], function(\n        WebGLConstants,\n        defined,\n        DeveloperError,\n        freezeObject,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * Constants for WebGL index datatypes.  These corresponds to the\n     * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n     *\n     * @namespace\n     * @alias IndexDatatype\n     */\n    var IndexDatatype = {\n        /**\n         * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n         * of an element in <code>Uint8Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_BYTE : WebGLConstants.UNSIGNED_BYTE,\n\n        /**\n         * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n         * of an element in <code>Uint16Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_SHORT : WebGLConstants.UNSIGNED_SHORT,\n\n        /**\n         * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n         * of an element in <code>Uint32Array</code>.\n         *\n         * @type {Number}\n         * @constant\n         */\n        UNSIGNED_INT : WebGLConstants.UNSIGNED_INT\n    };\n\n    /**\n     * Returns the size, in bytes, of the corresponding datatype.\n     *\n     * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n     * @returns {Number} The size in bytes.\n     *\n     * @example\n     * // Returns 2\n     * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n     */\n    IndexDatatype.getSizeInBytes = function(indexDatatype) {\n        switch(indexDatatype) {\n            case IndexDatatype.UNSIGNED_BYTE:\n                return Uint8Array.BYTES_PER_ELEMENT;\n            case IndexDatatype.UNSIGNED_SHORT:\n                return Uint16Array.BYTES_PER_ELEMENT;\n            case IndexDatatype.UNSIGNED_INT:\n                return Uint32Array.BYTES_PER_ELEMENT;\n        }\n\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError('indexDatatype is required and must be a valid IndexDatatype constant.');\n        //>>includeEnd('debug');\n    };\n\n    /**\n     * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n     *\n     * @param {IndexDatatype} indexDatatype The index datatype to validate.\n     * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n     *\n     * @example\n     * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n     *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n     * }\n     */\n    IndexDatatype.validate = function(indexDatatype) {\n        return defined(indexDatatype) &&\n               (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n                indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n                indexDatatype === IndexDatatype.UNSIGNED_INT);\n    };\n\n    /**\n     * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n     * or <code>Uint32Array</code> depending on the number of vertices.\n     *\n     * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n     * @param {Any} indicesLengthOrArray Passed through to the typed array constructor.\n     * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n     *\n     * @example\n     * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n     */\n    IndexDatatype.createTypedArray = function(numberOfVertices, indicesLengthOrArray) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(numberOfVertices)) {\n            throw new DeveloperError('numberOfVertices is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            return new Uint32Array(indicesLengthOrArray);\n        }\n\n        return new Uint16Array(indicesLengthOrArray);\n    };\n\n    /**\n     * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n     * or <code>Uint32Array</code> depending on the number of vertices.\n     *\n     * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n     * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n     * @param {Number} byteOffset Passed through to the typed array constructor.\n     * @param {Number} length Passed through to the typed array constructor.\n     * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n     *\n     */\n    IndexDatatype.createTypedArrayFromArrayBuffer = function(numberOfVertices, sourceArray, byteOffset, length) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(numberOfVertices)) {\n            throw new DeveloperError('numberOfVertices is required.');\n        }\n        if (!defined(sourceArray)) {\n            throw new DeveloperError('sourceArray is required.');\n        }\n        if (!defined(byteOffset)) {\n            throw new DeveloperError('byteOffset is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            return new Uint32Array(sourceArray, byteOffset, length);\n        }\n\n        return new Uint16Array(sourceArray, byteOffset, length);\n    };\n\n    return freezeObject(IndexDatatype);\n});\n",
    "\n/*global define*/\ndefine('Core/QuadraticRealPolynomial',[\n        './DeveloperError',\n        './Math'\n    ], function(\n        DeveloperError,\n        CesiumMath) {\n    \"use strict\";\n\n    /**\n     * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\n     *\n     * @namespace\n     * @alias QuadraticRealPolynomial\n     */\n    var QuadraticRealPolynomial = {};\n\n    /**\n     * Provides the discriminant of the quadratic equation from the supplied coefficients.\n     *\n     * @param {Number} a The coefficient of the 2nd order monomial.\n     * @param {Number} b The coefficient of the 1st order monomial.\n     * @param {Number} c The coefficient of the 0th order monomial.\n     * @returns {Number} The value of the discriminant.\n     */\n    QuadraticRealPolynomial.computeDiscriminant = function(a, b, c) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        var discriminant = b * b - 4.0 * a * c;\n        return discriminant;\n    };\n\n    function addWithCancellationCheck(left, right, tolerance) {\n        var difference = left + right;\n        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&\n                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\n            return 0.0;\n        }\n\n        return difference;\n    }\n\n    /**\n     * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\n     *\n     * @param {Number} a The coefficient of the 2nd order monomial.\n     * @param {Number} b The coefficient of the 1st order monomial.\n     * @param {Number} c The coefficient of the 0th order monomial.\n     * @returns {Number[]} The real valued roots.\n     */\n    QuadraticRealPolynomial.computeRealRoots = function(a, b, c) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        var ratio;\n        if (a === 0.0) {\n            if (b === 0.0) {\n                // Constant function: c = 0.\n                return [];\n            }\n\n            // Linear function: b * x + c = 0.\n            return [-c / b];\n        } else if (b === 0.0) {\n            if (c === 0.0) {\n                // 2nd order monomial: a * x^2 = 0.\n                return [0.0, 0.0];\n            }\n\n            var cMagnitude = Math.abs(c);\n            var aMagnitude = Math.abs(a);\n\n            if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < CesiumMath.EPSILON14)) { // c ~= 0.0.\n                // 2nd order monomial: a * x^2 = 0.\n                return [0.0, 0.0];\n            } else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < CesiumMath.EPSILON14)) { // a ~= 0.0.\n                // Constant function: c = 0.\n                return [];\n            }\n\n            // a * x^2 + c = 0\n            ratio = -c / a;\n\n            if (ratio < 0.0) {\n                // Both roots are complex.\n                return [];\n            }\n\n            // Both roots are real.\n            var root = Math.sqrt(ratio);\n            return [-root, root];\n        } else if (c === 0.0) {\n            // a * x^2 + b * x = 0\n            ratio = -b / a;\n            if (ratio < 0.0) {\n                return [ratio, 0.0];\n            }\n\n            return [0.0, ratio];\n        }\n\n        // a * x^2 + b * x + c = 0\n        var b2 = b * b;\n        var four_ac = 4.0 * a * c;\n        var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);\n\n        if (radicand < 0.0) {\n            // Both roots are complex.\n            return [];\n        }\n\n        var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);\n        if (b > 0.0) {\n            return [q / a, c / q];\n        }\n\n        return [c / q, q / a];\n    };\n\n    return QuadraticRealPolynomial;\n});",
    "\n/*global define*/\ndefine('Core/CubicRealPolynomial',[\n        './DeveloperError',\n        './QuadraticRealPolynomial'\n    ], function(\n        DeveloperError,\n        QuadraticRealPolynomial) {\n    \"use strict\";\n\n    /**\n     * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\n     *\n     * @namespace\n     * @alias CubicRealPolynomial\n     */\n    var CubicRealPolynomial = {};\n\n    /**\n     * Provides the discriminant of the cubic equation from the supplied coefficients.\n     *\n     * @param {Number} a The coefficient of the 3rd order monomial.\n     * @param {Number} b The coefficient of the 2nd order monomial.\n     * @param {Number} c The coefficient of the 1st order monomial.\n     * @param {Number} d The coefficient of the 0th order monomial.\n     * @returns {Number} The value of the discriminant.\n     */\n    CubicRealPolynomial.computeDiscriminant = function(a, b, c, d) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        if (typeof d !== 'number') {\n            throw new DeveloperError('d is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        var a2 = a * a;\n        var b2 = b * b;\n        var c2 = c * c;\n        var d2 = d * d;\n\n        var discriminant = 18.0 * a * b * c * d + b2 * c2 - 27.0 * a2 * d2 - 4.0 * (a * c2 * c + b2 * b * d);\n        return discriminant;\n    };\n\n    function computeRealRoots(a, b, c, d) {\n        var A = a;\n        var B = b / 3.0;\n        var C = c / 3.0;\n        var D = d;\n\n        var AC = A * C;\n        var BD = B * D;\n        var B2 = B * B;\n        var C2 = C * C;\n        var delta1 = A * C - B2;\n        var delta2 = A * D - B * C;\n        var delta3 = B * D - C2;\n\n        var discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\n        var temp;\n        var temp1;\n\n        if (discriminant < 0.0) {\n            var ABar;\n            var CBar;\n            var DBar;\n\n            if (B2 * BD >= AC * C2) {\n                ABar = A;\n                CBar = delta1;\n                DBar = -2.0 * B * delta1 + A * delta2;\n            } else {\n                ABar = D;\n                CBar = delta3;\n                DBar = -D * delta2 + 2.0 * C * delta3;\n            }\n\n            var s = (DBar < 0.0) ? -1.0 : 1.0; // This is not Math.Sign()!\n            var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\n            temp1 = -DBar + temp0;\n\n            var x = temp1 / 2.0;\n            var p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\n            var q = (temp1 === temp0) ? -p : -CBar / p;\n\n            temp = (CBar <= 0.0) ? p + q : -DBar / (p * p + q * q + CBar);\n\n            if (B2 * BD >= AC * C2) {\n                return [(temp - B) / A];\n            }\n\n            return [-D / (temp + C)];\n        }\n\n        var CBarA = delta1;\n        var DBarA = -2.0 * B * delta1 + A * delta2;\n\n        var CBarD = delta3;\n        var DBarD = -D * delta2 + 2.0 * C * delta3;\n\n        var squareRootOfDiscriminant = Math.sqrt(discriminant);\n        var halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\n\n        var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\n        temp = 2.0 * Math.sqrt(-CBarA);\n        var cosine = Math.cos(theta);\n        temp1 = temp * cosine;\n        var temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n        var numeratorLarge = (temp1 + temp3 > 2.0 * B) ? temp1 - B : temp3 - B;\n        var denominatorLarge = A;\n\n        var root1 = numeratorLarge / denominatorLarge;\n\n        theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\n        temp = 2.0 * Math.sqrt(-CBarD);\n        cosine = Math.cos(theta);\n        temp1 = temp * cosine;\n        temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n        var numeratorSmall = -D;\n        var denominatorSmall = (temp1 + temp3 < 2.0 * C) ? temp1 + C : temp3 + C;\n\n        var root3 = numeratorSmall / denominatorSmall;\n\n        var E = denominatorLarge * denominatorSmall;\n        var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\n        var G = numeratorLarge * numeratorSmall;\n\n        var root2 = (C * F - B * G) / (-B * F + C * E);\n\n        if (root1 <= root2) {\n            if (root1 <= root3) {\n                if (root2 <= root3) {\n                    return [root1, root2, root3];\n                }\n                return [root1, root3, root2];\n            }\n            return [root3, root1, root2];\n        }\n        if (root1 <= root3) {\n            return [root2, root1, root3];\n        }\n        if (root2 <= root3) {\n            return [root2, root3, root1];\n        }\n        return [root3, root2, root1];\n    }\n\n    /**\n     * Provides the real valued roots of the cubic polynomial with the provided coefficients.\n     *\n     * @param {Number} a The coefficient of the 3rd order monomial.\n     * @param {Number} b The coefficient of the 2nd order monomial.\n     * @param {Number} c The coefficient of the 1st order monomial.\n     * @param {Number} d The coefficient of the 0th order monomial.\n     * @returns {Number[]} The real valued roots.\n     */\n    CubicRealPolynomial.computeRealRoots = function(a, b, c, d) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        if (typeof d !== 'number') {\n            throw new DeveloperError('d is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        var roots;\n        var ratio;\n        if (a === 0.0) {\n            // Quadratic function: b * x^2 + c * x + d = 0.\n            return QuadraticRealPolynomial.computeRealRoots(b, c, d);\n        } else if (b === 0.0) {\n            if (c === 0.0) {\n                if (d === 0.0) {\n                    // 3rd order monomial: a * x^3 = 0.\n                    return [0.0, 0.0, 0.0];\n                }\n\n                // a * x^3 + d = 0\n                ratio = -d / a;\n                var root = (ratio < 0.0) ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\n                return [root, root, root];\n            } else if (d === 0.0) {\n                // x * (a * x^2 + c) = 0.\n                roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);\n\n                // Return the roots in ascending order.\n                if (roots.Length === 0) {\n                    return [0.0];\n                }\n                return [roots[0], 0.0, roots[1]];\n            }\n\n            // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\n            return computeRealRoots(a, 0, c, d);\n        } else if (c === 0.0) {\n            if (d === 0.0) {\n                // x^2 * (a * x + b) = 0.\n                ratio = -b / a;\n                if (ratio < 0.0) {\n                    return [ratio, 0.0, 0.0];\n                }\n                return [0.0, 0.0, ratio];\n            }\n            // a * x^3 + b * x^2 + d = 0.\n            return computeRealRoots(a, b, 0, d);\n        } else if (d === 0.0) {\n            // x * (a * x^2 + b * x + c) = 0\n            roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);\n\n            // Return the roots in ascending order.\n            if (roots.length === 0) {\n                return [0.0];\n            } else if (roots[1] <= 0.0) {\n                return [roots[0], roots[1], 0.0];\n            } else if (roots[0] >= 0.0) {\n                return [0.0, roots[0], roots[1]];\n            }\n            return [roots[0], 0.0, roots[1]];\n        }\n\n        return computeRealRoots(a, b, c, d);\n    };\n\n    return CubicRealPolynomial;\n});",
    "\n/*global define*/\ndefine('Core/QuarticRealPolynomial',[\n        './CubicRealPolynomial',\n        './DeveloperError',\n        './Math',\n        './QuadraticRealPolynomial'\n    ], function(\n        CubicRealPolynomial,\n        DeveloperError,\n        CesiumMath,\n        QuadraticRealPolynomial) {\n    \"use strict\";\n\n    /**\n     * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\n     *\n     * @namespace\n     * @alias QuarticRealPolynomial\n     */\n    var QuarticRealPolynomial = {};\n\n    /**\n     * Provides the discriminant of the quartic equation from the supplied coefficients.\n     *\n     * @param {Number} a The coefficient of the 4th order monomial.\n     * @param {Number} b The coefficient of the 3rd order monomial.\n     * @param {Number} c The coefficient of the 2nd order monomial.\n     * @param {Number} d The coefficient of the 1st order monomial.\n     * @param {Number} e The coefficient of the 0th order monomial.\n     * @returns {Number} The value of the discriminant.\n     */\n    QuarticRealPolynomial.computeDiscriminant = function(a, b, c, d, e) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        if (typeof d !== 'number') {\n            throw new DeveloperError('d is a required number.');\n        }\n        if (typeof e !== 'number') {\n            throw new DeveloperError('e is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        var a2 = a * a;\n        var a3 = a2 * a;\n        var b2 = b * b;\n        var b3 = b2 * b;\n        var c2 = c * c;\n        var c3 = c2 * c;\n        var d2 = d * d;\n        var d3 = d2 * d;\n        var e2 = e * e;\n        var e3 = e2 * e;\n\n        var discriminant = (b2 * c2 * d2 - 4.0 * b3 * d3 - 4.0 * a * c3 * d2 + 18 * a * b * c * d3 - 27.0 * a2 * d2 * d2 + 256.0 * a3 * e3) +\n            e * (18.0 * b3 * c * d - 4.0 * b2 * c3 + 16.0 * a * c2 * c2 - 80.0 * a * b * c2 * d - 6.0 * a * b2 * d2 + 144.0 * a2 * c * d2) +\n            e2 * (144.0 * a * b2 * c - 27.0 * b2 * b2 - 128.0 * a2 * c2 - 192.0 * a2 * b * d);\n        return discriminant;\n    };\n\n    function original(a3, a2, a1, a0) {\n        var a3Squared = a3 * a3;\n\n        var p = a2 - 3.0 * a3Squared / 8.0;\n        var q = a1 - a2 * a3 / 2.0 + a3Squared * a3 / 8.0;\n        var r = a0 - a1 * a3 / 4.0 + a2 * a3Squared / 16.0 - 3.0 * a3Squared * a3Squared / 256.0;\n\n        // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\n        var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, 2.0 * p, p * p - 4.0 * r, -q * q);\n\n        if (cubicRoots.length > 0) {\n            var temp = -a3 / 4.0;\n\n            // Use the largest positive root.\n            var hSquared = cubicRoots[cubicRoots.length - 1];\n\n            if (Math.abs(hSquared) < CesiumMath.EPSILON14) {\n                // y^4 + p y^2 + r = 0.\n                var roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\n\n                if (roots.length === 2) {\n                    var root0 = roots[0];\n                    var root1 = roots[1];\n\n                    var y;\n                    if (root0 >= 0.0 && root1 >= 0.0) {\n                        var y0 = Math.sqrt(root0);\n                        var y1 = Math.sqrt(root1);\n\n                        return [temp - y1, temp - y0, temp + y0, temp + y1];\n                    } else if (root0 >= 0.0 && root1 < 0.0) {\n                        y = Math.sqrt(root0);\n                        return [temp - y, temp + y];\n                    } else if (root0 < 0.0 && root1 >= 0.0) {\n                        y = Math.sqrt(root1);\n                        return [temp - y, temp + y];\n                    }\n                }\n                return [];\n            } else if (hSquared > 0.0) {\n                var h = Math.sqrt(hSquared);\n\n                var m = (p + hSquared - q / h) / 2.0;\n                var n = (p + hSquared + q / h) / 2.0;\n\n                // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\n                var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\n                var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\n\n                if (roots1.length !== 0) {\n                    roots1[0] += temp;\n                    roots1[1] += temp;\n\n                    if (roots2.length !== 0) {\n                        roots2[0] += temp;\n                        roots2[1] += temp;\n\n                        if (roots1[1] <= roots2[0]) {\n                            return [roots1[0], roots1[1], roots2[0], roots2[1]];\n                        } else if (roots2[1] <= roots1[0]) {\n                            return [roots2[0], roots2[1], roots1[0], roots1[1]];\n                        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n                            return [roots2[0], roots1[0], roots1[1], roots2[1]];\n                        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n                            return [roots1[0], roots2[0], roots2[1], roots1[1]];\n                        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n                            return [roots2[0], roots1[0], roots2[1], roots1[1]];\n                        }\n                        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n                    }\n                    return roots1;\n                }\n\n                if (roots2.length !== 0) {\n                    roots2[0] += temp;\n                    roots2[1] += temp;\n\n                    return roots2;\n                }\n                return [];\n            }\n        }\n        return [];\n    }\n\n    function neumark(a3, a2, a1, a0) {\n        var a1Squared = a1 * a1;\n        var a2Squared = a2 * a2;\n        var a3Squared = a3 * a3;\n\n        var p = -2.0 * a2;\n        var q = a1 * a3 + a2Squared - 4.0 * a0;\n        var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\n\n        var cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\n\n        if (cubicRoots.length > 0) {\n            // Use the most positive root\n            var y = cubicRoots[0];\n\n            var temp = (a2 - y);\n            var tempSquared = temp * temp;\n\n            var g1 = a3 / 2.0;\n            var h1 = temp / 2.0;\n\n            var m = tempSquared - 4.0 * a0;\n            var mError = tempSquared + 4.0 * Math.abs(a0);\n\n            var n = a3Squared - 4.0 * y;\n            var nError = a3Squared + 4.0 * Math.abs(y);\n\n            var g2;\n            var h2;\n\n            if (y < 0.0 || (m * nError < n * mError)) {\n                var squareRootOfN = Math.sqrt(n);\n                g2 = squareRootOfN / 2.0;\n                h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\n            } else {\n                var squareRootOfM = Math.sqrt(m);\n                g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\n                h2 = squareRootOfM / 2.0;\n            }\n\n            var G;\n            var g;\n            if (g1 === 0.0 && g2 === 0.0) {\n                G = 0.0;\n                g = 0.0;\n            } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {\n                G = g1 + g2;\n                g = y / G;\n            } else {\n                g = g1 - g2;\n                G = y / g;\n            }\n\n            var H;\n            var h;\n            if (h1 === 0.0 && h2 === 0.0) {\n                H = 0.0;\n                h = 0.0;\n            } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {\n                H = h1 + h2;\n                h = a0 / H;\n            } else {\n                h = h1 - h2;\n                H = a0 / h;\n            }\n\n            // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\n            var roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\n            var roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\n\n            if (roots1.length !== 0) {\n                if (roots2.length !== 0) {\n                    if (roots1[1] <= roots2[0]) {\n                        return [roots1[0], roots1[1], roots2[0], roots2[1]];\n                    } else if (roots2[1] <= roots1[0]) {\n                        return [roots2[0], roots2[1], roots1[0], roots1[1]];\n                    } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n                        return [roots2[0], roots1[0], roots1[1], roots2[1]];\n                    } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n                        return [roots1[0], roots2[0], roots2[1], roots1[1]];\n                    } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n                        return [roots2[0], roots1[0], roots2[1], roots1[1]];\n                    } else {\n                        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n                    }\n                }\n                return roots1;\n            }\n            if (roots2.length !== 0) {\n                return roots2;\n            }\n        }\n        return [];\n    }\n\n    /**\n     * Provides the real valued roots of the quartic polynomial with the provided coefficients.\n     *\n     * @param {Number} a The coefficient of the 4th order monomial.\n     * @param {Number} b The coefficient of the 3rd order monomial.\n     * @param {Number} c The coefficient of the 2nd order monomial.\n     * @param {Number} d The coefficient of the 1st order monomial.\n     * @param {Number} e The coefficient of the 0th order monomial.\n     * @returns {Number[]} The real valued roots.\n     */\n    QuarticRealPolynomial.computeRealRoots = function(a, b, c, d, e) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof a !== 'number') {\n            throw new DeveloperError('a is a required number.');\n        }\n        if (typeof b !== 'number') {\n            throw new DeveloperError('b is a required number.');\n        }\n        if (typeof c !== 'number') {\n            throw new DeveloperError('c is a required number.');\n        }\n        if (typeof d !== 'number') {\n            throw new DeveloperError('d is a required number.');\n        }\n        if (typeof e !== 'number') {\n            throw new DeveloperError('e is a required number.');\n        }\n        //>>includeEnd('debug');\n\n        if (Math.abs(a) < CesiumMath.EPSILON15) {\n            return CubicRealPolynomial.computeRealRoots(b, c, d, e);\n        }\n        var a3 = b / a;\n        var a2 = c / a;\n        var a1 = d / a;\n        var a0 = e / a;\n\n        var k = (a3 < 0.0) ? 1 : 0;\n        k += (a2 < 0.0) ? k + 1 : k;\n        k += (a1 < 0.0) ? k + 1 : k;\n        k += (a0 < 0.0) ? k + 1 : k;\n\n        switch (k) {\n        case 0:\n            return original(a3, a2, a1, a0);\n        case 1:\n            return neumark(a3, a2, a1, a0);\n        case 2:\n            return neumark(a3, a2, a1, a0);\n        case 3:\n            return original(a3, a2, a1, a0);\n        case 4:\n            return original(a3, a2, a1, a0);\n        case 5:\n            return neumark(a3, a2, a1, a0);\n        case 6:\n            return original(a3, a2, a1, a0);\n        case 7:\n            return original(a3, a2, a1, a0);\n        case 8:\n            return neumark(a3, a2, a1, a0);\n        case 9:\n            return original(a3, a2, a1, a0);\n        case 10:\n            return original(a3, a2, a1, a0);\n        case 11:\n            return neumark(a3, a2, a1, a0);\n        case 12:\n            return original(a3, a2, a1, a0);\n        case 13:\n            return original(a3, a2, a1, a0);\n        case 14:\n            return original(a3, a2, a1, a0);\n        case 15:\n            return original(a3, a2, a1, a0);\n        default:\n            return undefined;\n        }\n    };\n\n    return QuarticRealPolynomial;\n});",
    "\n/*global define*/\ndefine('Core/Ray',[\n        './Cartesian3',\n        './defaultValue',\n        './defined',\n        './DeveloperError'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Represents a ray that extends infinitely from the provided origin in the provided direction.\n     * @alias Ray\n     * @constructor\n     *\n     * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.\n     * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.\n     */\n    var Ray = function(origin, direction) {\n        direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));\n        if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {\n            Cartesian3.normalize(direction, direction);\n        }\n\n        /**\n         * The origin of the ray.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));\n\n        /**\n         * The direction of the ray.\n         * @type {Cartesian3}\n         */\n        this.direction = direction;\n    };\n\n    /**\n     * Computes the point along the ray given by r(t) = o + t*d,\n     * where o is the origin of the ray and d is the direction.\n     *\n     * @param {Ray} ray The ray.\n     * @param {Number} t A scalar value.\n     * @param {Cartesian3} [result] The object in which the result will be stored.\n     * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.\n     *\n     * @example\n     * //Get the first intersection point of a ray and an ellipsoid.\n     * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n     * var point = Cesium.Ray.getPoint(ray, intersection.start);\n     */\n    Ray.getPoint = function(ray, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)){\n            throw new DeveloperError('ray is requred');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is a required number');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        result = Cartesian3.multiplyByScalar(ray.direction, t, result);\n        return Cartesian3.add(ray.origin, result, result);\n    };\n\n    return Ray;\n});\n",
    "\n/*global define*/\ndefine('Core/IntersectionTests',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Math',\n        './Matrix3',\n        './QuadraticRealPolynomial',\n        './QuarticRealPolynomial',\n        './Ray'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        DeveloperError,\n        CesiumMath,\n        Matrix3,\n        QuadraticRealPolynomial,\n        QuarticRealPolynomial,\n        Ray) {\n    \"use strict\";\n\n    /**\n     * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n     *\n     * @namespace\n     * @alias IntersectionTests\n     */\n    var IntersectionTests = {};\n\n    /**\n     * Computes the intersection of a ray and a plane.\n     *\n     * @param {Ray} ray The ray.\n     * @param {Plane} plane The plane.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n     */\n    IntersectionTests.rayPlane = function(ray, plane, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)) {\n            throw new DeveloperError('ray is required.');\n        }\n        if (!defined(plane)) {\n            throw new DeveloperError('plane is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var origin = ray.origin;\n        var direction = ray.direction;\n        var normal = plane.normal;\n        var denominator = Cartesian3.dot(normal, direction);\n\n        if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n            // Ray is parallel to plane.  The ray may be in the polygon's plane.\n            return undefined;\n        }\n\n        var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n        if (t < 0) {\n            return undefined;\n        }\n\n        result = Cartesian3.multiplyByScalar(direction, t, result);\n        return Cartesian3.add(origin, result, result);\n    };\n\n    var scratchEdge0 = new Cartesian3();\n    var scratchEdge1 = new Cartesian3();\n    var scratchPVec = new Cartesian3();\n    var scratchTVec = new Cartesian3();\n    var scratchQVec = new Cartesian3();\n\n    function rayTriangle(ray, p0, p1, p2, cullBackFaces) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)) {\n            throw new DeveloperError('ray is required.');\n        }\n        if (!defined(p0)) {\n            throw new DeveloperError('p0 is required.');\n        }\n        if (!defined(p1)) {\n            throw new DeveloperError('p1 is required.');\n        }\n        if (!defined(p2)) {\n            throw new DeveloperError('p2 is required.');\n        }\n        //>>includeEnd('debug');\n\n        cullBackFaces = defaultValue(cullBackFaces, false);\n\n        var origin = ray.origin;\n        var direction = ray.direction;\n\n        var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n        var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n        var p = Cartesian3.cross(direction, edge1, scratchPVec);\n        var det = Cartesian3.dot(edge0, p);\n\n        var tvec;\n        var q;\n\n        var u;\n        var v;\n        var t;\n\n        if (cullBackFaces) {\n            if (det < CesiumMath.EPSILON6) {\n                return undefined;\n            }\n\n            tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n            u = Cartesian3.dot(tvec, p);\n            if (u < 0.0 || u > det) {\n                return undefined;\n            }\n\n            q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n            v = Cartesian3.dot(direction, q);\n            if (v < 0.0 || u + v > det) {\n                return undefined;\n            }\n\n            t = Cartesian3.dot(edge1, q) / det;\n        } else {\n            if (Math.abs(det) < CesiumMath.EPSILON6) {\n                return undefined;\n            }\n            var invDet = 1.0 / det;\n\n            tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n            u = Cartesian3.dot(tvec, p) * invDet;\n            if (u < 0.0 || u > 1.0) {\n                return undefined;\n            }\n\n            q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n            v = Cartesian3.dot(direction, q) * invDet;\n            if (v < 0.0 || u + v > 1.0) {\n                return undefined;\n            }\n\n            t = Cartesian3.dot(edge1, q) * invDet;\n        }\n\n        return t;\n    }\n\n    /**\n     * Computes the intersection of a ray and a triangle.\n     * @memberof IntersectionTests\n     *\n     * @param {Ray} ray The ray.\n     * @param {Cartesian3} p0 The first vertex of the triangle.\n     * @param {Cartesian3} p1 The second vertex of the triangle.\n     * @param {Cartesian3} p2 The third vertex of the triangle.\n     * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n     *                  and return undefined for intersections with the back face.\n     * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n     */\n    IntersectionTests.rayTriangle = function(ray, p0, p1, p2, cullBackFaces, result) {\n        var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);\n        if (!defined(t) || t < 0.0) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        Cartesian3.multiplyByScalar(ray.direction, t, result);\n        return Cartesian3.add(ray.origin, result, result);\n    };\n\n    var scratchLineSegmentTriangleRay = new Ray();\n\n    /**\n     * Computes the intersection of a line segment and a triangle.\n     * @memberof IntersectionTests\n     *\n     * @param {Cartesian3} v0 The an end point of the line segment.\n     * @param {Cartesian3} v1 The other end point of the line segment.\n     * @param {Cartesian3} p0 The first vertex of the triangle.\n     * @param {Cartesian3} p1 The second vertex of the triangle.\n     * @param {Cartesian3} p2 The third vertex of the triangle.\n     * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n     *                  and return undefined for intersections with the back face.\n     * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n     */\n    IntersectionTests.lineSegmentTriangle = function(v0, v1, p0, p1, p2, cullBackFaces, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(v0)) {\n            throw new DeveloperError('v0 is required.');\n        }\n        if (!defined(v1)) {\n            throw new DeveloperError('v1 is required.');\n        }\n        //>>includeEnd('debug');\n\n        var ray = scratchLineSegmentTriangleRay;\n        Cartesian3.clone(v0, ray.origin);\n        Cartesian3.subtract(v1, v0, ray.direction);\n        Cartesian3.normalize(ray.direction, ray.direction);\n\n        var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);\n        if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        Cartesian3.multiplyByScalar(ray.direction, t, result);\n        return Cartesian3.add(ray.origin, result, result);\n    };\n\n    function solveQuadratic(a, b, c, result) {\n        var det = b * b - 4.0 * a * c;\n        if (det < 0.0) {\n            return undefined;\n        } else if (det > 0.0) {\n            var denom = 1.0 / (2.0 * a);\n            var disc = Math.sqrt(det);\n            var root0 = (-b + disc) * denom;\n            var root1 = (-b - disc) * denom;\n\n            if (root0 < root1) {\n                result.root0 = root0;\n                result.root1 = root1;\n            } else {\n                result.root0 = root1;\n                result.root1 = root0;\n            }\n\n            return result;\n        }\n\n        var root = -b / (2.0 * a);\n        if (root === 0.0) {\n            return undefined;\n        }\n\n        result.root0 = result.root1 = root;\n        return result;\n    }\n\n    var raySphereRoots = {\n        root0 : 0.0,\n        root1 : 0.0\n    };\n\n    function raySphere(ray, sphere, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n\n        var origin = ray.origin;\n        var direction = ray.direction;\n\n        var center = sphere.center;\n        var radiusSquared = sphere.radius * sphere.radius;\n\n        var diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n        var a = Cartesian3.dot(direction, direction);\n        var b = 2.0 * Cartesian3.dot(direction, diff);\n        var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n        var roots = solveQuadratic(a, b, c, raySphereRoots);\n        if (!defined(roots)) {\n            return undefined;\n        }\n\n        result.start = roots.root0;\n        result.stop = roots.root1;\n        return result;\n    }\n\n    /**\n     * Computes the intersection points of a ray with a sphere.\n     * @memberof IntersectionTests\n     *\n     * @param {Ray} ray The ray.\n     * @param {BoundingSphere} sphere The sphere.\n     * @param {Object} [result] The result onto which to store the result.\n     * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the ray or undefined if there are no intersections.\n     */\n    IntersectionTests.raySphere = function(ray, sphere, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)) {\n            throw new DeveloperError('ray is required.');\n        }\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n        //>>includeEnd('debug');\n\n        result = raySphere(ray, sphere, result);\n        if (!defined(result) || result.stop < 0.0) {\n            return undefined;\n        }\n\n        result.start = Math.max(result.start, 0.0);\n        return result;\n    };\n\n    var scratchLineSegmentRay = new Ray();\n\n    /**\n     * Computes the intersection points of a line segment with a sphere.\n     * @memberof IntersectionTests\n     *\n     * @param {Cartesian3} p0 An end point of the line segment.\n     * @param {Cartesian3} p1 The other end point of the line segment.\n     * @param {BoundingSphere} sphere The sphere.\n     * @param {Object} [result] The result onto which to store the result.\n     * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the line segment or undefined if there are no intersections.\n     */\n    IntersectionTests.lineSegmentSphere = function(p0, p1, sphere, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(p0)) {\n            throw new DeveloperError('p0 is required.');\n        }\n        if (!defined(p1)) {\n            throw new DeveloperError('p1 is required.');\n        }\n        if (!defined(sphere)) {\n            throw new DeveloperError('sphere is required.');\n        }\n        //>>includeEnd('debug');\n\n        var ray = scratchLineSegmentRay;\n        var origin = Cartesian3.clone(p0, ray.origin);\n        var direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n        var maxT = Cartesian3.magnitude(direction);\n        Cartesian3.normalize(direction, direction);\n\n        result = raySphere(ray, sphere, result);\n        if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n            return undefined;\n        }\n\n        result.start = Math.max(result.start, 0.0);\n        result.stop = Math.min(result.stop, maxT);\n        return result;\n    };\n\n    var scratchQ = new Cartesian3();\n    var scratchW = new Cartesian3();\n\n    /**\n     * Computes the intersection points of a ray with an ellipsoid.\n     *\n     * @param {Ray} ray The ray.\n     * @param {Ellipsoid} ellipsoid The ellipsoid.\n     * @returns {Object} An object with the first (<code>start</code>) and the second (<code>stop</code>) intersection scalars for points along the ray or undefined if there are no intersections.\n     */\n    IntersectionTests.rayEllipsoid = function(ray, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)) {\n            throw new DeveloperError('ray is required.');\n        }\n        if (!defined(ellipsoid)) {\n            throw new DeveloperError('ellipsoid is required.');\n        }\n        //>>includeEnd('debug');\n\n        var inverseRadii = ellipsoid.oneOverRadii;\n        var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n        var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);\n\n        var q2 = Cartesian3.magnitudeSquared(q);\n        var qw = Cartesian3.dot(q, w);\n\n        var difference, w2, product, discriminant, temp;\n\n        if (q2 > 1.0) {\n            // Outside ellipsoid.\n            if (qw >= 0.0) {\n                // Looking outward or tangent (0 intersections).\n                return undefined;\n            }\n\n            // qw < 0.0.\n            var qw2 = qw * qw;\n            difference = q2 - 1.0; // Positively valued.\n            w2 = Cartesian3.magnitudeSquared(w);\n            product = w2 * difference;\n\n            if (qw2 < product) {\n                // Imaginary roots (0 intersections).\n                return undefined;\n            } else if (qw2 > product) {\n                // Distinct roots (2 intersections).\n                discriminant = qw * qw - product;\n                temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n                var root0 = temp / w2;\n                var root1 = difference / temp;\n                if (root0 < root1) {\n                    return {\n                        start : root0,\n                        stop : root1\n                    };\n                }\n\n                return {\n                    start : root1,\n                    stop : root0\n                };\n            } else {\n                // qw2 == product.  Repeated roots (2 intersections).\n                var root = Math.sqrt(difference / w2);\n                return {\n                    start : root,\n                    stop : root\n                };\n            }\n        } else if (q2 < 1.0) {\n            // Inside ellipsoid (2 intersections).\n            difference = q2 - 1.0; // Negatively valued.\n            w2 = Cartesian3.magnitudeSquared(w);\n            product = w2 * difference; // Negatively valued.\n\n            discriminant = qw * qw - product;\n            temp = -qw + Math.sqrt(discriminant); // Positively valued.\n            return {\n                start : 0.0,\n                stop : temp / w2\n            };\n        } else {\n            // q2 == 1.0. On ellipsoid.\n            if (qw < 0.0) {\n                // Looking inward.\n                w2 = Cartesian3.magnitudeSquared(w);\n                return {\n                    start : 0.0,\n                    stop : -qw / w2\n                };\n            }\n\n            // qw >= 0.0.  Looking outward or tangent.\n            return undefined;\n        }\n    };\n\n    function addWithCancellationCheck(left, right, tolerance) {\n        var difference = left + right;\n        if ((CesiumMath.sign(left) !== CesiumMath.sign(right)) &&\n                Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {\n            return 0.0;\n        }\n\n        return difference;\n    }\n\n    function quadraticVectorExpression(A, b, c, x, w) {\n        var xSquared = x * x;\n        var wSquared = w * w;\n\n        var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n        var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);\n        var l0 = (A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared) + x * b.x + c;\n\n        var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);\n        var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);\n\n        var cosines;\n        var solutions = [];\n        if (r0 === 0.0 && r1 === 0.0) {\n            cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n            if (cosines.length === 0) {\n                return solutions;\n            }\n\n            var cosine0 = cosines[0];\n            var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n            solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n            solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n            if (cosines.length === 2) {\n                var cosine1 = cosines[1];\n                var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n                solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n                solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n            }\n\n            return solutions;\n        }\n\n        var r0Squared = r0 * r0;\n        var r1Squared = r1 * r1;\n        var l2Squared = l2 * l2;\n        var r0r1 = r0 * r1;\n\n        var c4 = l2Squared + r1Squared;\n        var c3 = 2.0 * (l1 * l2 + r0r1);\n        var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n        var c1 = 2.0 * (l0 * l1 - r0r1);\n        var c0 = l0 * l0 - r0Squared;\n\n        if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n            return solutions;\n        }\n\n        cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n        var length = cosines.length;\n        if (length === 0) {\n            return solutions;\n        }\n\n        for ( var i = 0; i < length; ++i) {\n            var cosine = cosines[i];\n            var cosineSquared = cosine * cosine;\n            var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n            var sine = Math.sqrt(sineSquared);\n\n            //var left = l2 * cosineSquared + l1 * cosine + l0;\n            var left;\n            if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n                left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);\n            } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n                left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);\n            } else {\n                left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);\n            }\n\n            var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);\n            var product = left * right;\n\n            if (product < 0.0) {\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\n            } else if (product > 0.0) {\n                solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n            } else if (sine !== 0.0) {\n                solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\n                ++i;\n            } else {\n                solutions.push(new Cartesian3(x, w * cosine, w * sine));\n            }\n        }\n\n        return solutions;\n    }\n\n    var firstAxisScratch = new Cartesian3();\n    var secondAxisScratch = new Cartesian3();\n    var thirdAxisScratch = new Cartesian3();\n    var referenceScratch = new Cartesian3();\n    var bCart = new Cartesian3();\n    var bScratch = new Matrix3();\n    var btScratch = new Matrix3();\n    var diScratch = new Matrix3();\n    var dScratch = new Matrix3();\n    var cScratch = new Matrix3();\n    var tempMatrix = new Matrix3();\n    var aScratch = new Matrix3();\n    var sScratch = new Cartesian3();\n    var closestScratch = new Cartesian3();\n    var surfPointScratch = new Cartographic();\n\n    /**\n     * Provides the point along the ray which is nearest to the ellipsoid.\n     *\n     * @param {Ray} ray The ray.\n     * @param {Ellipsoid} ellipsoid The ellipsoid.\n     * @returns {Cartesian3} The nearest planetodetic point on the ray.\n     */\n    IntersectionTests.grazingAltitudeLocation = function(ray, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ray)) {\n            throw new DeveloperError('ray is required.');\n        }\n        if (!defined(ellipsoid)) {\n            throw new DeveloperError('ellipsoid is required.');\n        }\n        //>>includeEnd('debug');\n\n        var position = ray.origin;\n        var direction = ray.direction;\n\n        var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n        if (Cartesian3.dot(direction, normal) >= 0.0) { // The location provided is the closest point in altitude\n            return position;\n        }\n\n        var intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n        // Compute the scaled direction vector.\n        var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\n\n        // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n        var firstAxis = Cartesian3.normalize(f, f);\n        var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n        var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);\n        var thirdAxis  = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);\n        var B = bScratch;\n        B[0] = firstAxis.x;\n        B[1] = firstAxis.y;\n        B[2] = firstAxis.z;\n        B[3] = secondAxis.x;\n        B[4] = secondAxis.y;\n        B[5] = secondAxis.z;\n        B[6] = thirdAxis.x;\n        B[7] = thirdAxis.y;\n        B[8] = thirdAxis.z;\n\n        var B_T = Matrix3.transpose(B, btScratch);\n\n        // Get the scaling matrix and its inverse.\n        var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n        var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n        var C = cScratch;\n        C[0] = 0.0;\n        C[1] = -direction.z;\n        C[2] = direction.y;\n        C[3] = direction.z;\n        C[4] = 0.0;\n        C[5] = -direction.x;\n        C[6] = -direction.y;\n        C[7] = direction.x;\n        C[8] = 0.0;\n\n        var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);\n        var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);\n        var b = Matrix3.multiplyByVector(temp, position, bCart);\n\n        // Solve for the solutions to the expression in standard form:\n        var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0.0, 0.0, 1.0);\n\n        var s;\n        var altitude;\n        var length = solutions.length;\n        if (length > 0) {\n            var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n            var maximumValue = Number.NEGATIVE_INFINITY;\n\n            for ( var i = 0; i < length; ++i) {\n                s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);\n                var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);\n                var dotProduct = Cartesian3.dot(v, direction);\n\n                if (dotProduct > maximumValue) {\n                    maximumValue = dotProduct;\n                    closest = Cartesian3.clone(s, closest);\n                }\n            }\n\n            var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);\n            maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n            altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1.0 - maximumValue * maximumValue);\n            altitude = intersects ? -altitude : altitude;\n            surfacePoint.height = altitude;\n            return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n        }\n\n        return undefined;\n    };\n\n    var lineSegmentPlaneDifference = new Cartesian3();\n\n    /**\n     * Computes the intersection of a line segment and a plane.\n     *\n     * @param {Cartesian3} endPoint0 An end point of the line segment.\n     * @param {Cartesian3} endPoint1 The other end point of the line segment.\n     * @param {Plane} plane The plane.\n     * @param {Cartesian3} [result] The object onto which to store the result.\n     * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n     *\n     * @example\n     * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n     * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n     * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n     *\n     * var p0 = new Cesium.Cartesian3(...);\n     * var p1 = new Cesium.Cartesian3(...);\n     *\n     * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n     * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n     */\n    IntersectionTests.lineSegmentPlane = function(endPoint0, endPoint1, plane, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(endPoint0)) {\n            throw new DeveloperError('endPoint0 is required.');\n        }\n        if (!defined(endPoint1)) {\n            throw new DeveloperError('endPoint1 is required.');\n        }\n        if (!defined(plane)) {\n            throw new DeveloperError('plane is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian3();\n        }\n\n        var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);\n        var normal = plane.normal;\n        var nDotDiff = Cartesian3.dot(normal, difference);\n\n        // check if the segment and plane are parallel\n        if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n            return undefined;\n        }\n\n        var nDotP0 = Cartesian3.dot(normal, endPoint0);\n        var t = -(plane.distance + nDotP0) / nDotDiff;\n\n        // intersection only if t is in [0, 1]\n        if (t < 0.0 || t > 1.0) {\n            return undefined;\n        }\n\n        // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n        Cartesian3.multiplyByScalar(difference, t, result);\n        Cartesian3.add(endPoint0, result, result);\n        return result;\n    };\n\n    /**\n     * Computes the intersection of a triangle and a plane\n     *\n     * @param {Cartesian3} p0 First point of the triangle\n     * @param {Cartesian3} p1 Second point of the triangle\n     * @param {Cartesian3} p2 Third point of the triangle\n     * @param {Plane} plane Intersection plane\n     * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n     *\n     * @example\n     * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n     * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n     * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n     *\n     * var p0 = new Cesium.Cartesian3(...);\n     * var p1 = new Cesium.Cartesian3(...);\n     * var p2 = new Cesium.Cartesian3(...);\n     *\n     * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n     * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n     */\n    IntersectionTests.trianglePlaneIntersection = function(p0, p1, p2, plane) {\n        //>>includeStart('debug', pragmas.debug);\n        if ((!defined(p0)) ||\n            (!defined(p1)) ||\n            (!defined(p2)) ||\n            (!defined(plane))) {\n            throw new DeveloperError('p0, p1, p2, and plane are required.');\n        }\n        //>>includeEnd('debug');\n\n        var planeNormal = plane.normal;\n        var planeD = plane.distance;\n        var p0Behind = (Cartesian3.dot(planeNormal, p0) + planeD) < 0.0;\n        var p1Behind = (Cartesian3.dot(planeNormal, p1) + planeD) < 0.0;\n        var p2Behind = (Cartesian3.dot(planeNormal, p2) + planeD) < 0.0;\n        // Given these dots products, the calls to lineSegmentPlaneIntersection\n        // always have defined results.\n\n        var numBehind = 0;\n        numBehind += p0Behind ? 1 : 0;\n        numBehind += p1Behind ? 1 : 0;\n        numBehind += p2Behind ? 1 : 0;\n\n        var u1, u2;\n        if (numBehind === 1 || numBehind === 2) {\n            u1 = new Cartesian3();\n            u2 = new Cartesian3();\n        }\n\n        if (numBehind === 1) {\n            if (p0Behind) {\n                IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n                IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        0, 3, 4,\n\n                        // In front\n                        1, 2, 4,\n                        1, 4, 3\n                    ]\n                };\n            } else if (p1Behind) {\n                IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n                IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        1, 3, 4,\n\n                        // In front\n                        2, 0, 4,\n                        2, 4, 3\n                    ]\n                };\n            } else if (p2Behind) {\n                IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n                IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        2, 3, 4,\n\n                        // In front\n                        0, 1, 4,\n                        0, 4, 3\n                    ]\n                };\n            }\n        } else if (numBehind === 2) {\n            if (!p0Behind) {\n                IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n                IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        1, 2, 4,\n                        1, 4, 3,\n\n                        // In front\n                        0, 3, 4\n                    ]\n                };\n            } else if (!p1Behind) {\n                IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n                IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        2, 0, 4,\n                        2, 4, 3,\n\n                        // In front\n                        1, 3, 4\n                    ]\n                };\n            } else if (!p2Behind) {\n                IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n                IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n                return {\n                    positions : [p0, p1, p2, u1, u2 ],\n                    indices : [\n                        // Behind\n                        0, 1, 4,\n                        0, 4, 3,\n\n                        // In front\n                        2, 3, 4\n                    ]\n                };\n            }\n        }\n\n        // if numBehind is 3, the triangle is completely behind the plane;\n        // otherwise, it is completely in front (numBehind is 0).\n        return undefined;\n    };\n\n    return IntersectionTests;\n});\n",
    "\n/*global define*/\ndefine('Core/Tipsify',[\n        './defaultValue',\n        './defined',\n        './DeveloperError'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Encapsulates an algorithm to optimize triangles for the post\n     * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n     * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'\n     * The runtime is linear but several passes are made.\n     *\n     * @namespace\n     * @alias Tipsify\n     *\n     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>\n     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n     * by Sander, Nehab, and Barczak\n     *\n     * @private\n     */\n    var Tipsify = {};\n\n    /**\n     * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n     *                        in the vertex buffer that define the geometry's triangles.\n     * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n     *                                     If not supplied, this value will be computed.\n     * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n     * @returns {Number} The average cache miss ratio (ACMR).\n     *\n     * @exception {DeveloperError} indices length must be a multiple of three.\n     * @exception {DeveloperError} cacheSize must be greater than two.\n     *\n     * @example\n     * var indices = [0, 1, 2, 3, 4, 5];\n     * var maxIndex = 5;\n     * var cacheSize = 3;\n     * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n     */\n    Tipsify.calculateACMR = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var indices = options.indices;\n        var maximumIndex = options.maximumIndex;\n        var cacheSize = defaultValue(options.cacheSize, 24);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(indices)) {\n            throw new DeveloperError('indices is required.');\n        }\n        //>>includeEnd('debug');\n\n        var numIndices = indices.length;\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numIndices < 3 || numIndices % 3 !== 0) {\n            throw new DeveloperError('indices length must be a multiple of three.');\n        }\n        if (maximumIndex <= 0) {\n            throw new DeveloperError('maximumIndex must be greater than zero.');\n        }\n        if (cacheSize < 3) {\n            throw new DeveloperError('cacheSize must be greater than two.');\n        }\n        //>>includeEnd('debug');\n\n        // Compute the maximumIndex if not given\n        if (!defined(maximumIndex)) {\n            maximumIndex = 0;\n            var currentIndex = 0;\n            var intoIndices = indices[currentIndex];\n            while (currentIndex < numIndices) {\n                if (intoIndices > maximumIndex) {\n                    maximumIndex = intoIndices;\n                }\n                ++currentIndex;\n                intoIndices = indices[currentIndex];\n            }\n        }\n\n        // Vertex time stamps\n        var vertexTimeStamps = [];\n        for ( var i = 0; i < maximumIndex + 1; i++) {\n            vertexTimeStamps[i] = 0;\n        }\n\n        // Cache processing\n        var s = cacheSize + 1;\n        for ( var j = 0; j < numIndices; ++j) {\n            if ((s - vertexTimeStamps[indices[j]]) > cacheSize) {\n                vertexTimeStamps[indices[j]] = s;\n                ++s;\n            }\n        }\n\n        return (s - cacheSize + 1) / (numIndices / 3);\n    };\n\n    /**\n     * Optimizes triangles for the post-vertex shader cache.\n     *\n     * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n     *                        in the vertex buffer that define the geometry's triangles.\n     * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n     *                                     If not supplied, this value will be computed.\n     * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n     * @returns {Number[]} A list of the input indices in an optimized order.\n     *\n     * @exception {DeveloperError} indices length must be a multiple of three.\n     * @exception {DeveloperError} cacheSize must be greater than two.\n     *\n     * @example\n     * var indices = [0, 1, 2, 3, 4, 5];\n     * var maxIndex = 5;\n     * var cacheSize = 3;\n     * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n     */\n    Tipsify.tipsify = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var indices = options.indices;\n        var maximumIndex = options.maximumIndex;\n        var cacheSize = defaultValue(options.cacheSize, 24);\n\n        var cursor;\n\n        function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n            while (deadEnd.length >= 1) {\n                // while the stack is not empty\n                var d = deadEnd[deadEnd.length - 1]; // top of the stack\n                deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n                if (vertices[d].numLiveTriangles > 0) {\n                    return d;\n                }\n            }\n\n            while (cursor < maximumIndexPlusOne) {\n                if (vertices[cursor].numLiveTriangles > 0) {\n                    ++cursor;\n                    return cursor - 1;\n                }\n                ++cursor;\n            }\n            return -1;\n        }\n\n        function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {\n            var n = -1;\n            var p;\n            var m = -1;\n            var itOneRing = 0;\n            while (itOneRing < oneRing.length) {\n                var index = oneRing[itOneRing];\n                if (vertices[index].numLiveTriangles) {\n                    p = 0;\n                    if ((s - vertices[index].timeStamp + (2 * vertices[index].numLiveTriangles)) <= cacheSize) {\n                        p = s - vertices[index].timeStamp;\n                    }\n                    if ((p > m) || (m === -1)) {\n                        m = p;\n                        n = index;\n                    }\n                }\n                ++itOneRing;\n            }\n            if (n === -1) {\n                return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n            }\n            return n;\n        }\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(indices)) {\n            throw new DeveloperError('indices is required.');\n        }\n        //>>includeEnd('debug');\n\n        var numIndices = indices.length;\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numIndices < 3 || numIndices % 3 !== 0) {\n            throw new DeveloperError('indices length must be a multiple of three.');\n        }\n        if (maximumIndex <= 0) {\n            throw new DeveloperError('maximumIndex must be greater than zero.');\n        }\n        if (cacheSize < 3) {\n            throw new DeveloperError('cacheSize must be greater than two.');\n        }\n        //>>includeEnd('debug');\n\n        // Determine maximum index\n        var maximumIndexPlusOne = 0;\n        var currentIndex = 0;\n        var intoIndices = indices[currentIndex];\n        var endIndex = numIndices;\n        if (defined(maximumIndex)) {\n            maximumIndexPlusOne = maximumIndex + 1;\n        } else {\n            while (currentIndex < endIndex) {\n                if (intoIndices > maximumIndexPlusOne) {\n                    maximumIndexPlusOne = intoIndices;\n                }\n                ++currentIndex;\n                intoIndices = indices[currentIndex];\n            }\n            if (maximumIndexPlusOne === -1) {\n                return 0;\n            }\n            ++maximumIndexPlusOne;\n        }\n\n        // Vertices\n        var vertices = [];\n        for ( var i = 0; i < maximumIndexPlusOne; i++) {\n            vertices[i] = {\n                numLiveTriangles : 0,\n                timeStamp : 0,\n                vertexTriangles : []\n            };\n        }\n        currentIndex = 0;\n        var triangle = 0;\n        while (currentIndex < endIndex) {\n            vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n            ++(vertices[indices[currentIndex]]).numLiveTriangles;\n            vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n            ++(vertices[indices[currentIndex + 1]]).numLiveTriangles;\n            vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n            ++(vertices[indices[currentIndex + 2]]).numLiveTriangles;\n            ++triangle;\n            currentIndex += 3;\n        }\n\n        // Starting index\n        var f = 0;\n\n        // Time Stamp\n        var s = cacheSize + 1;\n        cursor = 1;\n\n        // Process\n        var oneRing = [];\n        var deadEnd = []; //Stack\n        var vertex;\n        var intoVertices;\n        var currentOutputIndex = 0;\n        var outputIndices = [];\n        var numTriangles = numIndices / 3;\n        var triangleEmitted = [];\n        for (i = 0; i < numTriangles; i++) {\n            triangleEmitted[i] = false;\n        }\n        var index;\n        var limit;\n        while (f !== -1) {\n            oneRing = [];\n            intoVertices = vertices[f];\n            limit = intoVertices.vertexTriangles.length;\n            for ( var k = 0; k < limit; ++k) {\n                triangle = intoVertices.vertexTriangles[k];\n                if (!triangleEmitted[triangle]) {\n                    triangleEmitted[triangle] = true;\n                    currentIndex = triangle + triangle + triangle;\n                    for ( var j = 0; j < 3; ++j) {\n                        // Set this index as a possible next index\n                        index = indices[currentIndex];\n                        oneRing.push(index);\n                        deadEnd.push(index);\n\n                        // Output index\n                        outputIndices[currentOutputIndex] = index;\n                        ++currentOutputIndex;\n\n                        // Cache processing\n                        vertex = vertices[index];\n                        --vertex.numLiveTriangles;\n                        if ((s - vertex.timeStamp) > cacheSize) {\n                            vertex.timeStamp = s;\n                            ++s;\n                        }\n                        ++currentIndex;\n                    }\n                }\n            }\n            f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);\n        }\n\n        return outputIndices;\n    };\n\n    return Tipsify;\n});\n",
    "\n/*global define*/\ndefine('Core/GeometryPipeline',[\n        './AttributeCompression',\n        './barycentricCoordinates',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartesian4',\n        './Cartographic',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './EncodedCartesian3',\n        './GeographicProjection',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryInstance',\n        './GeometryType',\n        './IndexDatatype',\n        './Intersect',\n        './IntersectionTests',\n        './Math',\n        './Matrix3',\n        './Matrix4',\n        './Plane',\n        './PrimitiveType',\n        './Tipsify'\n    ], function(\n        AttributeCompression,\n        barycentricCoordinates,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Cartesian4,\n        Cartographic,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        EncodedCartesian3,\n        GeographicProjection,\n        Geometry,\n        GeometryAttribute,\n        GeometryInstance,\n        GeometryType,\n        IndexDatatype,\n        Intersect,\n        IntersectionTests,\n        CesiumMath,\n        Matrix3,\n        Matrix4,\n        Plane,\n        PrimitiveType,\n        Tipsify) {\n    \"use strict\";\n\n    /**\n     * Content pipeline functions for geometries.\n     *\n     * @namespace\n     * @alias GeometryPipeline\n     *\n     * @see Geometry\n     */\n    var GeometryPipeline = {};\n\n    function addTriangle(lines, index, i0, i1, i2) {\n        lines[index++] = i0;\n        lines[index++] = i1;\n\n        lines[index++] = i1;\n        lines[index++] = i2;\n\n        lines[index++] = i2;\n        lines[index] = i0;\n    }\n\n    function trianglesToLines(triangles) {\n        var count = triangles.length;\n        var size = (count / 3) * 6;\n        var lines = IndexDatatype.createTypedArray(count, size);\n\n        var index = 0;\n        for ( var i = 0; i < count; i += 3, index += 6) {\n            addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n        }\n\n        return lines;\n    }\n\n    function triangleStripToLines(triangles) {\n        var count = triangles.length;\n        if (count >= 3) {\n            var size = (count - 2) * 6;\n            var lines = IndexDatatype.createTypedArray(count, size);\n\n            addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n            var index = 6;\n\n            for ( var i = 3; i < count; ++i, index += 6) {\n                addTriangle(lines, index, triangles[i - 1], triangles[i], triangles[i - 2]);\n            }\n\n            return lines;\n        }\n\n        return new Uint16Array();\n    }\n\n    function triangleFanToLines(triangles) {\n        if (triangles.length > 0) {\n            var count = triangles.length - 1;\n            var size = (count - 1) * 6;\n            var lines = IndexDatatype.createTypedArray(count, size);\n\n            var base = triangles[0];\n            var index = 0;\n            for ( var i = 1; i < count; ++i, index += 6) {\n                addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n            }\n\n            return lines;\n        }\n\n        return new Uint16Array();\n    }\n\n    /**\n     * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n     * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n     * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n     * <p>\n     * This is commonly used to create a wireframe geometry for visual debugging.\n     * </p>\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n     *\n     * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n     */\n    GeometryPipeline.toWireframe = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = geometry.indices;\n        if (defined(indices)) {\n            switch (geometry.primitiveType) {\n                case PrimitiveType.TRIANGLES:\n                    geometry.indices = trianglesToLines(indices);\n                    break;\n                case PrimitiveType.TRIANGLE_STRIP:\n                    geometry.indices = triangleStripToLines(indices);\n                    break;\n                case PrimitiveType.TRIANGLE_FAN:\n                    geometry.indices = triangleFanToLines(indices);\n                    break;\n                default:\n                    throw new DeveloperError('geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.');\n            }\n\n            geometry.primitiveType = PrimitiveType.LINES;\n        }\n\n        return geometry;\n    };\n\n    /**\n     * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n     * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n     * visualize vector attributes like normals, binormals, and tangents.\n     *\n     * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n     * @param {String} [attributeName='normal'] The name of the attribute.\n     * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n     * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n     *\n     * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n     *\n     * @example\n     * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'binormal', 100000.0);\n     */\n    GeometryPipeline.createLineSegmentsForVectors = function(geometry, attributeName, length) {\n        attributeName = defaultValue(attributeName, 'normal');\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        if (!defined(geometry.attributes.position)) {\n            throw new DeveloperError('geometry.attributes.position is required.');\n        }\n        if (!defined(geometry.attributes[attributeName])) {\n            throw new DeveloperError('geometry.attributes must have an attribute with the same name as the attributeName parameter, ' + attributeName + '.');\n        }\n        //>>includeEnd('debug');\n\n        length = defaultValue(length, 10000.0);\n\n        var positions = geometry.attributes.position.values;\n        var vectors = geometry.attributes[attributeName].values;\n        var positionsLength = positions.length;\n\n        var newPositions = new Float64Array(2 * positionsLength);\n\n        var j = 0;\n        for (var i = 0; i < positionsLength; i += 3) {\n            newPositions[j++] = positions[i];\n            newPositions[j++] = positions[i + 1];\n            newPositions[j++] = positions[i + 2];\n\n            newPositions[j++] = positions[i] + (vectors[i] * length);\n            newPositions[j++] = positions[i + 1] + (vectors[i + 1] * length);\n            newPositions[j++] = positions[i + 2] + (vectors[i + 2] * length);\n        }\n\n        var newBoundingSphere;\n        var bs = geometry.boundingSphere;\n        if (defined(bs)) {\n            newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n        }\n\n        return new Geometry({\n            attributes : {\n                position : new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.DOUBLE,\n                    componentsPerAttribute : 3,\n                    values : newPositions\n                })\n            },\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : newBoundingSphere\n        });\n    };\n\n    /**\n     * Creates an object that maps attribute names to unique locations (indices)\n     * for matching vertex attributes and shader programs.\n     *\n     * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n     * @returns {Object} An object with attribute name / index pairs.\n     *\n     * @example\n     * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n     * // Example output\n     * // {\n     * //   'position' : 0,\n     * //   'normal' : 1\n     * // }\n     */\n    GeometryPipeline.createAttributeLocations = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug')\n\n        // There can be a WebGL performance hit when attribute 0 is disabled, so\n        // assign attribute locations to well-known attributes.\n        var semantics = [\n            'position',\n            'positionHigh',\n            'positionLow',\n\n            // From VertexFormat.position - after 2D projection and high-precision encoding\n            'position3DHigh',\n            'position3DLow',\n            'position2DHigh',\n            'position2DLow',\n\n            // From Primitive\n            'pickColor',\n\n            // From VertexFormat\n            'normal',\n            'st',\n            'binormal',\n            'tangent',\n\n            // From compressing texture coordinates and normals\n            'compressedAttributes'\n        ];\n\n        var attributes = geometry.attributes;\n        var indices = {};\n        var j = 0;\n        var i;\n        var len = semantics.length;\n\n        // Attribute locations for well-known attributes\n        for (i = 0; i < len; ++i) {\n            var semantic = semantics[i];\n\n            if (defined(attributes[semantic])) {\n                indices[semantic] = j++;\n            }\n        }\n\n        // Locations for custom attributes\n        for (var name in attributes) {\n            if (attributes.hasOwnProperty(name) && (!defined(indices[name]))) {\n                indices[name] = j++;\n            }\n        }\n\n        return indices;\n    };\n\n    /**\n     * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n     *\n     * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n     *\n     * @see GeometryPipeline.reorderForPostVertexCache\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n     */\n    GeometryPipeline.reorderForPreVertexCache = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var numVertices = Geometry.computeNumberOfVertices(geometry);\n\n        var indices = geometry.indices;\n        if (defined(indices)) {\n            var indexCrossReferenceOldToNew = new Int32Array(numVertices);\n            for ( var i = 0; i < numVertices; i++) {\n                indexCrossReferenceOldToNew[i] = -1;\n            }\n\n            // Construct cross reference and reorder indices\n            var indicesIn = indices;\n            var numIndices = indicesIn.length;\n            var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n            var intoIndicesIn = 0;\n            var intoIndicesOut = 0;\n            var nextIndex = 0;\n            var tempIndex;\n            while (intoIndicesIn < numIndices) {\n                tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n                if (tempIndex !== -1) {\n                    indicesOut[intoIndicesOut] = tempIndex;\n                } else {\n                    tempIndex = indicesIn[intoIndicesIn];\n                    indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n                    indicesOut[intoIndicesOut] = nextIndex;\n                    ++nextIndex;\n                }\n                ++intoIndicesIn;\n                ++intoIndicesOut;\n            }\n            geometry.indices = indicesOut;\n\n            // Reorder attributes\n            var attributes = geometry.attributes;\n            for ( var property in attributes) {\n                if (attributes.hasOwnProperty(property) &&\n                        defined(attributes[property]) &&\n                        defined(attributes[property].values)) {\n\n                    var attribute = attributes[property];\n                    var elementsIn = attribute.values;\n                    var intoElementsIn = 0;\n                    var numComponents = attribute.componentsPerAttribute;\n                    var elementsOut = ComponentDatatype.createTypedArray(attribute.componentDatatype, nextIndex * numComponents);\n                    while (intoElementsIn < numVertices) {\n                        var temp = indexCrossReferenceOldToNew[intoElementsIn];\n                        if (temp !== -1) {\n                            for (i = 0; i < numComponents; i++) {\n                                elementsOut[numComponents * temp + i] = elementsIn[numComponents * intoElementsIn + i];\n                            }\n                        }\n                        ++intoElementsIn;\n                    }\n                    attribute.values = elementsOut;\n                }\n            }\n        }\n\n        return geometry;\n    };\n\n    /**\n     * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n     * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n     * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n     *\n     * @exception {DeveloperError} cacheCapacity must be greater than two.\n     *\n     * @see GeometryPipeline.reorderForPreVertexCache\n     * @see {@link http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n     * by Sander, Nehab, and Barczak\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n     */\n    GeometryPipeline.reorderForPostVertexCache = function(geometry, cacheCapacity) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = geometry.indices;\n        if ((geometry.primitiveType === PrimitiveType.TRIANGLES) && (defined(indices))) {\n            var numIndices = indices.length;\n            var maximumIndex = 0;\n            for ( var j = 0; j < numIndices; j++) {\n                if (indices[j] > maximumIndex) {\n                    maximumIndex = indices[j];\n                }\n            }\n            geometry.indices = Tipsify.tipsify({\n                indices : indices,\n                maximumIndex : maximumIndex,\n                cacheSize : cacheCapacity\n            });\n        }\n\n        return geometry;\n    };\n\n    function copyAttributesDescriptions(attributes) {\n        var newAttributes = {};\n\n        for ( var attribute in attributes) {\n            if (attributes.hasOwnProperty(attribute) &&\n                    defined(attributes[attribute]) &&\n                    defined(attributes[attribute].values)) {\n\n                var attr = attributes[attribute];\n                newAttributes[attribute] = new GeometryAttribute({\n                    componentDatatype : attr.componentDatatype,\n                    componentsPerAttribute : attr.componentsPerAttribute,\n                    normalize : attr.normalize,\n                    values : []\n                });\n            }\n        }\n\n        return newAttributes;\n    }\n\n    function copyVertex(destinationAttributes, sourceAttributes, index) {\n        for ( var attribute in sourceAttributes) {\n            if (sourceAttributes.hasOwnProperty(attribute) &&\n                    defined(sourceAttributes[attribute]) &&\n                    defined(sourceAttributes[attribute].values)) {\n\n                var attr = sourceAttributes[attribute];\n\n                for ( var k = 0; k < attr.componentsPerAttribute; ++k) {\n                    destinationAttributes[attribute].values.push(attr.values[(index * attr.componentsPerAttribute) + k]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n     * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n     * when unsigned int indices are not supported.\n     * <p>\n     * If the geometry does not have any <code>indices</code>, this function has no effect.\n     * </p>\n     *\n     * @param {Geometry} geometry The geometry to be split into multiple geometries.\n     * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n     *\n     * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n     * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n     *\n     * @example\n     * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n     */\n    GeometryPipeline.fitToUnsignedShortIndices = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        if ((defined(geometry.indices)) &&\n            ((geometry.primitiveType !== PrimitiveType.TRIANGLES) &&\n             (geometry.primitiveType !== PrimitiveType.LINES) &&\n             (geometry.primitiveType !== PrimitiveType.POINTS))) {\n            throw new DeveloperError('geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.');\n        }\n        //>>includeEnd('debug');\n\n        var geometries = [];\n\n        // If there's an index list and more than 64K attributes, it is possible that\n        // some indices are outside the range of unsigned short [0, 64K - 1]\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n        if (defined(geometry.indices) && (numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES)) {\n            var oldToNewIndex = [];\n            var newIndices = [];\n            var currentIndex = 0;\n            var newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n            var originalIndices = geometry.indices;\n            var numberOfIndices = originalIndices.length;\n\n            var indicesPerPrimitive;\n\n            if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n                indicesPerPrimitive = 3;\n            } else if (geometry.primitiveType === PrimitiveType.LINES) {\n                indicesPerPrimitive = 2;\n            } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n                indicesPerPrimitive = 1;\n            }\n\n            for ( var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n                for (var k = 0; k < indicesPerPrimitive; ++k) {\n                    var x = originalIndices[j + k];\n                    var i = oldToNewIndex[x];\n                    if (!defined(i)) {\n                        i = currentIndex++;\n                        oldToNewIndex[x] = i;\n                        copyVertex(newAttributes, geometry.attributes, x);\n                    }\n                    newIndices.push(i);\n                }\n\n                if (currentIndex + indicesPerPrimitive > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n                    geometries.push(new Geometry({\n                        attributes : newAttributes,\n                        indices : newIndices,\n                        primitiveType : geometry.primitiveType,\n                        boundingSphere : geometry.boundingSphere,\n                        boundingSphereCV : geometry.boundingSphereCV\n                    }));\n\n                    // Reset for next vertex-array\n                    oldToNewIndex = [];\n                    newIndices = [];\n                    currentIndex = 0;\n                    newAttributes = copyAttributesDescriptions(geometry.attributes);\n                }\n            }\n\n            if (newIndices.length !== 0) {\n                geometries.push(new Geometry({\n                    attributes : newAttributes,\n                    indices : newIndices,\n                    primitiveType : geometry.primitiveType,\n                    boundingSphere : geometry.boundingSphere,\n                    boundingSphereCV : geometry.boundingSphereCV\n                }));\n            }\n        } else {\n            // No need to split into multiple geometries\n            geometries.push(geometry);\n        }\n\n        return geometries;\n    };\n\n    var scratchProjectTo2DCartesian3 = new Cartesian3();\n    var scratchProjectTo2DCartographic = new Cartographic();\n\n    /**\n     * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n     * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n     * <p>\n     * If the geometry does not have a <code>position</code>, this function has no effect.\n     * </p>\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @param {String} attributeName The name of the attribute.\n     * @param {String} attributeName3D The name of the attribute in 3D.\n     * @param {String} attributeName2D The name of the attribute in 2D.\n     * @param {Object} [projection=new GeographicProjection()] The projection to use.\n     * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n     *\n     * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n     * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n     * @exception {DeveloperError} Could not project a point to 2D.\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n     */\n    GeometryPipeline.projectTo2D = function(geometry, attributeName, attributeName3D, attributeName2D, projection) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        if (!defined(attributeName)) {\n            throw new DeveloperError('attributeName is required.');\n        }\n        if (!defined(attributeName3D)) {\n            throw new DeveloperError('attributeName3D is required.');\n        }\n        if (!defined(attributeName2D)) {\n            throw new DeveloperError('attributeName2D is required.');\n        }\n        if (!defined(geometry.attributes[attributeName])) {\n            throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');\n        }\n        if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n            throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');\n        }\n        //>>includeEnd('debug');\n\n        var attribute = geometry.attributes[attributeName];\n        projection = (defined(projection)) ? projection : new GeographicProjection();\n        var ellipsoid = projection.ellipsoid;\n\n        // Project original values to 2D.\n        var values3D = attribute.values;\n        var projectedValues = new Float64Array(values3D.length);\n        var index = 0;\n\n        for ( var i = 0; i < values3D.length; i += 3) {\n            var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);\n\n            var lonLat = ellipsoid.cartesianToCartographic(value, scratchProjectTo2DCartographic);\n            if (!defined(lonLat)) {\n                throw new DeveloperError('Could not project point (' + value.x + ', ' + value.y + ', ' + value.z + ') to 2D.');\n            }\n\n            var projectedLonLat = projection.project(lonLat, scratchProjectTo2DCartesian3);\n\n            projectedValues[index++] = projectedLonLat.x;\n            projectedValues[index++] = projectedLonLat.y;\n            projectedValues[index++] = projectedLonLat.z;\n        }\n\n        // Rename original cartesians to WGS84 cartesians.\n        geometry.attributes[attributeName3D] = attribute;\n\n        // Replace original cartesians with 2D projected cartesians\n        geometry.attributes[attributeName2D] = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : projectedValues\n        });\n        delete geometry.attributes[attributeName];\n\n        return geometry;\n    };\n\n    var encodedResult = {\n        high : 0.0,\n        low : 0.0\n    };\n\n    /**\n     * Encodes floating-point geometry attribute values as two separate attributes to improve\n     * rendering precision.\n     * <p>\n     * This is commonly used to create high-precision position vertex attributes.\n     * </p>\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @param {String} attributeName The name of the attribute.\n     * @param {String} attributeHighName The name of the attribute for the encoded high bits.\n     * @param {String} attributeLowName The name of the attribute for the encoded low bits.\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n     *\n     * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n     * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n     */\n    GeometryPipeline.encodeAttribute = function(geometry, attributeName, attributeHighName, attributeLowName) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        if (!defined(attributeName)) {\n            throw new DeveloperError('attributeName is required.');\n        }\n        if (!defined(attributeHighName)) {\n            throw new DeveloperError('attributeHighName is required.');\n        }\n        if (!defined(attributeLowName)) {\n            throw new DeveloperError('attributeLowName is required.');\n        }\n        if (!defined(geometry.attributes[attributeName])) {\n            throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');\n        }\n        if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {\n            throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');\n        }\n        //>>includeEnd('debug');\n\n        var attribute = geometry.attributes[attributeName];\n        var values = attribute.values;\n        var length = values.length;\n        var highValues = new Float32Array(length);\n        var lowValues = new Float32Array(length);\n\n        for (var i = 0; i < length; ++i) {\n            EncodedCartesian3.encode(values[i], encodedResult);\n            highValues[i] = encodedResult.high;\n            lowValues[i] = encodedResult.low;\n        }\n\n        var componentsPerAttribute = attribute.componentsPerAttribute;\n\n        geometry.attributes[attributeHighName] = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : componentsPerAttribute,\n            values : highValues\n        });\n        geometry.attributes[attributeLowName] = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : componentsPerAttribute,\n            values : lowValues\n        });\n        delete geometry.attributes[attributeName];\n\n        return geometry;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n\n    function transformPoint(matrix, attribute) {\n        if (defined(attribute)) {\n            var values = attribute.values;\n            var length = values.length;\n            for (var i = 0; i < length; i += 3) {\n                Cartesian3.unpack(values, i, scratchCartesian3);\n                Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n                Cartesian3.pack(scratchCartesian3, values, i);\n            }\n        }\n    }\n\n    function transformVector(matrix, attribute) {\n        if (defined(attribute)) {\n            var values = attribute.values;\n            var length = values.length;\n            for (var i = 0; i < length; i += 3) {\n                Cartesian3.unpack(values, i, scratchCartesian3);\n                Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n                scratchCartesian3 = Cartesian3.normalize(scratchCartesian3, scratchCartesian3);\n                Cartesian3.pack(scratchCartesian3, values, i);\n            }\n        }\n    }\n\n    var inverseTranspose = new Matrix4();\n    var normalMatrix = new Matrix3();\n\n    /**\n     * Transforms a geometry instance to world coordinates.  This changes\n     * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n     * following attributes if they are present: <code>position</code>, <code>normal</code>,\n     * <code>binormal</code>, and <code>tangent</code>.\n     *\n     * @param {GeometryInstance} instance The geometry instance to modify.\n     * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n     *\n     * @example\n     * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n     */\n    GeometryPipeline.transformToWorldCoordinates = function(instance) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(instance)) {\n            throw new DeveloperError('instance is required.');\n        }\n        //>>includeEnd('debug');\n\n        var modelMatrix = instance.modelMatrix;\n\n        if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n            // Already in world coordinates\n            return instance;\n        }\n\n        var attributes = instance.geometry.attributes;\n\n        // Transform attributes in known vertex formats\n        transformPoint(modelMatrix, attributes.position);\n        transformPoint(modelMatrix, attributes.prevPosition);\n        transformPoint(modelMatrix, attributes.nextPosition);\n\n        if ((defined(attributes.normal)) ||\n            (defined(attributes.binormal)) ||\n            (defined(attributes.tangent))) {\n\n            Matrix4.inverse(modelMatrix, inverseTranspose);\n            Matrix4.transpose(inverseTranspose, inverseTranspose);\n            Matrix4.getRotation(inverseTranspose, normalMatrix);\n\n            transformVector(normalMatrix, attributes.normal);\n            transformVector(normalMatrix, attributes.binormal);\n            transformVector(normalMatrix, attributes.tangent);\n        }\n\n        var boundingSphere = instance.geometry.boundingSphere;\n\n        if (defined(boundingSphere)) {\n            instance.geometry.boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, boundingSphere);\n        }\n\n        instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n        return instance;\n    };\n\n    function findAttributesInAllGeometries(instances, propertyName) {\n        var length = instances.length;\n\n        var attributesInAllGeometries = {};\n\n        var attributes0 = instances[0][propertyName].attributes;\n        var name;\n\n        for (name in attributes0) {\n            if (attributes0.hasOwnProperty(name) &&\n                    defined(attributes0[name]) &&\n                    defined(attributes0[name].values)) {\n\n                var attribute = attributes0[name];\n                var numberOfComponents = attribute.values.length;\n                var inAllGeometries = true;\n\n                // Does this same attribute exist in all geometries?\n                for (var i = 1; i < length; ++i) {\n                    var otherAttribute = instances[i][propertyName].attributes[name];\n\n                    if ((!defined(otherAttribute)) ||\n                        (attribute.componentDatatype !== otherAttribute.componentDatatype) ||\n                        (attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute) ||\n                        (attribute.normalize !== otherAttribute.normalize)) {\n\n                        inAllGeometries = false;\n                        break;\n                    }\n\n                    numberOfComponents += otherAttribute.values.length;\n                }\n\n                if (inAllGeometries) {\n                    attributesInAllGeometries[name] = new GeometryAttribute({\n                        componentDatatype : attribute.componentDatatype,\n                        componentsPerAttribute : attribute.componentsPerAttribute,\n                        normalize : attribute.normalize,\n                        values : ComponentDatatype.createTypedArray(attribute.componentDatatype, numberOfComponents)\n                    });\n                }\n            }\n        }\n\n        return attributesInAllGeometries;\n    }\n\n    var tempScratch = new Cartesian3();\n\n    function combineGeometries(instances, propertyName) {\n        var length = instances.length;\n\n        var name;\n        var i;\n        var j;\n        var k;\n\n        var m = instances[0].modelMatrix;\n        var haveIndices = (defined(instances[0][propertyName].indices));\n        var primitiveType = instances[0][propertyName].primitiveType;\n\n        //>>includeStart('debug', pragmas.debug);\n        for (i = 1; i < length; ++i) {\n            if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n                throw new DeveloperError('All instances must have the same modelMatrix.');\n            }\n            if ((defined(instances[i][propertyName].indices)) !== haveIndices) {\n                throw new DeveloperError('All instance geometries must have an indices or not have one.');\n            }\n            if (instances[i][propertyName].primitiveType !== primitiveType) {\n                throw new DeveloperError('All instance geometries must have the same primitiveType.');\n            }\n        }\n        //>>includeEnd('debug');\n\n        // Find subset of attributes in all geometries\n        var attributes = findAttributesInAllGeometries(instances, propertyName);\n        var values;\n        var sourceValues;\n        var sourceValuesLength;\n\n        // Combine attributes from each geometry into a single typed array\n        for (name in attributes) {\n            if (attributes.hasOwnProperty(name)) {\n                values = attributes[name].values;\n\n                k = 0;\n                for (i = 0; i < length; ++i) {\n                    sourceValues = instances[i][propertyName].attributes[name].values;\n                    sourceValuesLength = sourceValues.length;\n\n                    for (j = 0; j < sourceValuesLength; ++j) {\n                        values[k++] = sourceValues[j];\n                    }\n                }\n            }\n        }\n\n        // Combine index lists\n        var indices;\n\n        if (haveIndices) {\n            var numberOfIndices = 0;\n            for (i = 0; i < length; ++i) {\n                numberOfIndices += instances[i][propertyName].indices.length;\n            }\n\n            var numberOfVertices = Geometry.computeNumberOfVertices(new Geometry({\n                attributes : attributes,\n                primitiveType : PrimitiveType.POINTS\n            }));\n            var destIndices = IndexDatatype.createTypedArray(numberOfVertices, numberOfIndices);\n\n            var destOffset = 0;\n            var offset = 0;\n\n            for (i = 0; i < length; ++i) {\n                var sourceIndices = instances[i][propertyName].indices;\n                var sourceIndicesLen = sourceIndices.length;\n\n                for (k = 0; k < sourceIndicesLen; ++k) {\n                    destIndices[destOffset++] = offset + sourceIndices[k];\n                }\n\n                offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n            }\n\n            indices = destIndices;\n        }\n\n        // Create bounding sphere that includes all instances\n        var center = new Cartesian3();\n        var radius = 0.0;\n        var bs;\n\n        for (i = 0; i < length; ++i) {\n            bs = instances[i][propertyName].boundingSphere;\n            if (!defined(bs)) {\n                // If any geometries have an undefined bounding sphere, then so does the combined geometry\n                center = undefined;\n                break;\n            }\n\n            Cartesian3.add(bs.center, center, center);\n        }\n\n        if (defined(center)) {\n            Cartesian3.divideByScalar(center, length, center);\n\n            for (i = 0; i < length; ++i) {\n                bs = instances[i][propertyName].boundingSphere;\n                var tempRadius = Cartesian3.magnitude(Cartesian3.subtract(bs.center, center, tempScratch)) + bs.radius;\n\n                if (tempRadius > radius) {\n                    radius = tempRadius;\n                }\n            }\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : primitiveType,\n            boundingSphere : (defined(center)) ? new BoundingSphere(center, radius) : undefined\n        });\n    }\n\n    /**\n     * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n     * This concatenates the attributes, concatenates and adjusts the indices, and creates\n     * a bounding sphere encompassing all instances.\n     * <p>\n     * If the instances do not have the same attributes, a subset of attributes common\n     * to all instances is used, and the others are ignored.\n     * </p>\n     * <p>\n     * This is used by {@link Primitive} to efficiently render a large amount of static data.\n     * </p>\n     * \n     * @private\n     *\n     * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n     * @returns {Geometry} A single geometry created from the provided geometry instances.\n     *\n     * @exception {DeveloperError} All instances must have the same modelMatrix.\n     * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n     * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n     *\n     * @see GeometryPipeline.transformToWorldCoordinates\n     *\n     * @example\n     * for (var i = 0; i < instances.length; ++i) {\n     *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n     * }\n     * var geometries = Cesium.GeometryPipeline.combineInstances(instances);\n     */\n    GeometryPipeline.combineInstances = function(instances) {\n        //>>includeStart('debug', pragmas.debug);\n        if ((!defined(instances)) || (instances.length < 1)) {\n            throw new DeveloperError('instances is required and must have length greater than zero.');\n        }\n        //>>includeEnd('debug');\n\n        var instanceGeometry = [];\n        var instanceSplitGeometry = [];\n        var length = instances.length;\n        for (var i = 0; i < length; ++i) {\n            var instance = instances[i];\n            if (defined(instance.geometry)) {\n                instanceGeometry.push(instance);\n            } else {\n                instanceSplitGeometry.push(instance);\n            }\n        }\n\n        var geometries = [];\n        if (instanceGeometry.length > 0) {\n            geometries.push(combineGeometries(instanceGeometry, 'geometry'));\n        }\n\n        if (instanceSplitGeometry.length > 0) {\n            geometries.push(combineGeometries(instanceSplitGeometry, 'westHemisphereGeometry'));\n            geometries.push(combineGeometries(instanceSplitGeometry, 'eastHemisphereGeometry'));\n        }\n\n        return geometries;\n    };\n\n    var normal = new Cartesian3();\n    var v0 = new Cartesian3();\n    var v1 = new Cartesian3();\n    var v2 = new Cartesian3();\n\n    /**\n     * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n     * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n     * This assumes a counter-clockwise winding order.\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n     *\n     * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n     * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n     *\n     * @example\n     * Cesium.GeometryPipeline.computeNormal(geometry);\n     */\n    GeometryPipeline.computeNormal = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        if (!defined(geometry.attributes.position) || !defined(geometry.attributes.position.values)) {\n            throw new DeveloperError('geometry.attributes.position.values is required.');\n        }\n        if (!defined(geometry.indices)) {\n            throw new DeveloperError('geometry.indices is required.');\n        }\n        if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n            throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');\n        }\n        if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n            throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = geometry.indices;\n        var attributes = geometry.attributes;\n        var vertices = attributes.position.values;\n        var numVertices = attributes.position.values.length / 3;\n        var numIndices = indices.length;\n        var normalsPerVertex = new Array(numVertices);\n        var normalsPerTriangle = new Array(numIndices / 3);\n        var normalIndices = new Array(numIndices);\n\n        for ( var i = 0; i < numVertices; i++) {\n            normalsPerVertex[i] = {\n                indexOffset : 0,\n                count : 0,\n                currentCount : 0\n            };\n        }\n\n        var j = 0;\n        for (i = 0; i < numIndices; i += 3) {\n            var i0 = indices[i];\n            var i1 = indices[i + 1];\n            var i2 = indices[i + 2];\n            var i03 = i0 * 3;\n            var i13 = i1 * 3;\n            var i23 = i2 * 3;\n\n            v0.x = vertices[i03];\n            v0.y = vertices[i03 + 1];\n            v0.z = vertices[i03 + 2];\n            v1.x = vertices[i13];\n            v1.y = vertices[i13 + 1];\n            v1.z = vertices[i13 + 2];\n            v2.x = vertices[i23];\n            v2.y = vertices[i23 + 1];\n            v2.z = vertices[i23 + 2];\n\n            normalsPerVertex[i0].count++;\n            normalsPerVertex[i1].count++;\n            normalsPerVertex[i2].count++;\n\n            Cartesian3.subtract(v1, v0, v1);\n            Cartesian3.subtract(v2, v0, v2);\n            normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n            j++;\n        }\n\n        var indexOffset = 0;\n        for (i = 0; i < numVertices; i++) {\n            normalsPerVertex[i].indexOffset += indexOffset;\n            indexOffset += normalsPerVertex[i].count;\n        }\n\n        j = 0;\n        var vertexNormalData;\n        for (i = 0; i < numIndices; i += 3) {\n            vertexNormalData = normalsPerVertex[indices[i]];\n            var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n            normalIndices[index] = j;\n            vertexNormalData.currentCount++;\n\n            vertexNormalData = normalsPerVertex[indices[i + 1]];\n            index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n            normalIndices[index] = j;\n            vertexNormalData.currentCount++;\n\n            vertexNormalData = normalsPerVertex[indices[i + 2]];\n            index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n            normalIndices[index] = j;\n            vertexNormalData.currentCount++;\n\n            j++;\n        }\n\n        var normalValues = new Float32Array(numVertices * 3);\n        for (i = 0; i < numVertices; i++) {\n            var i3 = i * 3;\n            vertexNormalData = normalsPerVertex[i];\n            if (vertexNormalData.count > 0) {\n                Cartesian3.clone(Cartesian3.ZERO, normal);\n                for (j = 0; j < vertexNormalData.count; j++) {\n                    Cartesian3.add(normal, normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]], normal);\n                }\n                Cartesian3.normalize(normal, normal);\n                normalValues[i3] = normal.x;\n                normalValues[i3 + 1] = normal.y;\n                normalValues[i3 + 2] = normal.z;\n            } else {\n                normalValues[i3] = 0.0;\n                normalValues[i3 + 1] = 0.0;\n                normalValues[i3 + 2] = 1.0;\n            }\n        }\n\n        geometry.attributes.normal = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 3,\n            values : normalValues\n        });\n\n        return geometry;\n    };\n\n    var normalScratch = new Cartesian3();\n    var normalScale = new Cartesian3();\n    var tScratch = new Cartesian3();\n\n    /**\n     * Computes per-vertex binormals and tangents for a geometry containing <code>TRIANGLES</code>.\n     * The result is new <code>binormal</code> and <code>tangent</code> attributes added to the geometry.\n     * This assumes a counter-clockwise winding order.\n     * <p>\n     * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n     * for an Arbitrary Mesh</a> by Eric Lengyel.\n     * </p>\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>binormal</code> and <code>tangent</code> attributes.\n     *\n     * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n     * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n     *\n     * @example\n     * Cesium.GeometryPipeline.computeBinormalAndTangent(geometry);\n     */\n    GeometryPipeline.computeBinormalAndTangent = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var attributes = geometry.attributes;\n        var indices = geometry.indices;\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(attributes.position) || !defined(attributes.position.values)) {\n            throw new DeveloperError('geometry.attributes.position.values is required.');\n        }\n        if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n            throw new DeveloperError('geometry.attributes.normal.values is required.');\n        }\n        if (!defined(attributes.st) || !defined(attributes.st.values)) {\n            throw new DeveloperError('geometry.attributes.st.values is required.');\n        }\n        if (!defined(indices)) {\n            throw new DeveloperError('geometry.indices is required.');\n        }\n        if (indices.length < 2 || indices.length % 3 !== 0) {\n            throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');\n        }\n        if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n            throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');\n        }\n        //>>includeEnd('debug');\n\n        var vertices = geometry.attributes.position.values;\n        var normals = geometry.attributes.normal.values;\n        var st = geometry.attributes.st.values;\n\n        var numVertices = geometry.attributes.position.values.length / 3;\n        var numIndices = indices.length;\n        var tan1 = new Array(numVertices * 3);\n\n        for ( var i = 0; i < tan1.length; i++) {\n            tan1[i] = 0;\n        }\n\n        var i03;\n        var i13;\n        var i23;\n        for (i = 0; i < numIndices; i += 3) {\n            var i0 = indices[i];\n            var i1 = indices[i + 1];\n            var i2 = indices[i + 2];\n            i03 = i0 * 3;\n            i13 = i1 * 3;\n            i23 = i2 * 3;\n            var i02 = i0 * 2;\n            var i12 = i1 * 2;\n            var i22 = i2 * 2;\n\n            var ux = vertices[i03];\n            var uy = vertices[i03 + 1];\n            var uz = vertices[i03 + 2];\n\n            var wx = st[i02];\n            var wy = st[i02 + 1];\n            var t1 = st[i12 + 1] - wy;\n            var t2 = st[i22 + 1] - wy;\n\n            var r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n            var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n            var sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n            var sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n            tan1[i03] += sdirx;\n            tan1[i03 + 1] += sdiry;\n            tan1[i03 + 2] += sdirz;\n\n            tan1[i13] += sdirx;\n            tan1[i13 + 1] += sdiry;\n            tan1[i13 + 2] += sdirz;\n\n            tan1[i23] += sdirx;\n            tan1[i23 + 1] += sdiry;\n            tan1[i23 + 2] += sdirz;\n        }\n\n        var binormalValues = new Float32Array(numVertices * 3);\n        var tangentValues = new Float32Array(numVertices * 3);\n\n        for (i = 0; i < numVertices; i++) {\n            i03 = i * 3;\n            i13 = i03 + 1;\n            i23 = i03 + 2;\n\n            var n = Cartesian3.fromArray(normals, i03, normalScratch);\n            var t = Cartesian3.fromArray(tan1, i03, tScratch);\n            var scalar = Cartesian3.dot(n, t);\n            Cartesian3.multiplyByScalar(n, scalar, normalScale);\n            Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n            tangentValues[i03] = t.x;\n            tangentValues[i13] = t.y;\n            tangentValues[i23] = t.z;\n\n            Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n            binormalValues[i03] = t.x;\n            binormalValues[i13] = t.y;\n            binormalValues[i23] = t.z;\n        }\n\n        geometry.attributes.tangent = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 3,\n            values : tangentValues\n        });\n\n        geometry.attributes.binormal = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 3,\n            values : binormalValues\n        });\n\n        return geometry;\n    };\n\n    var scratchCartesian2 = new Cartesian2();\n    var toEncode1 = new Cartesian3();\n    var toEncode2 = new Cartesian3();\n    var toEncode3 = new Cartesian3();\n\n    /**\n     * Compresses and packs geometry normal attribute values to save memory.\n     *\n     * @param {Geometry} geometry The geometry to modify.\n     * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n     *\n     * @example\n     * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n     */\n    GeometryPipeline.compressVertices = function(geometry) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(geometry)) {\n            throw new DeveloperError('geometry is required.');\n        }\n        //>>includeEnd('debug');\n\n        var normalAttribute = geometry.attributes.normal;\n        var stAttribute = geometry.attributes.st;\n        if (!defined(normalAttribute) && !defined(stAttribute)) {\n            return geometry;\n        }\n\n        var tangentAttribute = geometry.attributes.tangent;\n        var binormalAttribute = geometry.attributes.binormal;\n\n        var normals;\n        var st;\n        var tangents;\n        var binormals;\n\n        if (defined(normalAttribute)) {\n            normals = normalAttribute.values;\n        }\n        if (defined(stAttribute)) {\n            st = stAttribute.values;\n        }\n        if (defined(tangentAttribute)) {\n            tangents = tangentAttribute.values;\n        }\n        if (binormalAttribute) {\n            binormals = binormalAttribute.values;\n        }\n\n        var length = defined(normals) ? normals.length : st.length;\n        var numComponents = defined(normals) ? 3.0 : 2.0;\n        var numVertices = length / numComponents;\n\n        var compressedLength = numVertices;\n        var numCompressedComponents = defined(st) && defined(normals) ? 2.0 : 1.0;\n        numCompressedComponents += defined(tangents) || defined(binormals) ? 1.0 : 0.0;\n        compressedLength *= numCompressedComponents;\n\n        var compressedAttributes = new Float32Array(compressedLength);\n\n        var normalIndex = 0;\n        for (var i = 0; i < numVertices; ++i) {\n            if (defined(st)) {\n                Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n                compressedAttributes[normalIndex++] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n            }\n\n            var index = i * 3.0;\n            if (defined(normals) && defined(tangents) && defined(binormals)) {\n                Cartesian3.fromArray(normals, index, toEncode1);\n                Cartesian3.fromArray(tangents, index, toEncode2);\n                Cartesian3.fromArray(binormals, index, toEncode3);\n\n                AttributeCompression.octPack(toEncode1, toEncode2, toEncode3, scratchCartesian2);\n                compressedAttributes[normalIndex++] = scratchCartesian2.x;\n                compressedAttributes[normalIndex++] = scratchCartesian2.y;\n            } else {\n                if (defined(normals)) {\n                    Cartesian3.fromArray(normals, index, toEncode1);\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n                }\n\n                if (defined(tangents)) {\n                    Cartesian3.fromArray(tangents, index, toEncode1);\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n                }\n\n                if (defined(binormals)) {\n                    Cartesian3.fromArray(binormals, index, toEncode1);\n                    compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);\n                }\n            }\n        }\n\n        geometry.attributes.compressedAttributes = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : numCompressedComponents,\n            values : compressedAttributes\n        });\n\n        if (defined(normals)) {\n            delete geometry.attributes.normal;\n        }\n        if (defined(st)) {\n            delete geometry.attributes.st;\n        }\n        if (defined(tangents)) {\n            delete geometry.attributes.tangent;\n        }\n        if (defined(binormals)) {\n            delete geometry.attributes.binormal;\n        }\n\n        return geometry;\n    };\n\n    function indexTriangles(geometry) {\n        if (defined(geometry.indices)) {\n            return geometry;\n        }\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 3) {\n            throw new DeveloperError('The number of vertices must be at least three.');\n        }\n        if (numberOfVertices % 3 !== 0) {\n            throw new DeveloperError('The number of vertices must be a multiple of three.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n        for (var i = 0; i < numberOfVertices; ++i) {\n            indices[i] = i;\n        }\n\n        geometry.indices = indices;\n        return geometry;\n    }\n\n    function indexTriangleFan(geometry) {\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 3) {\n            throw new DeveloperError('The number of vertices must be at least three.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n        indices[0] = 1;\n        indices[1] = 0;\n        indices[2] = 2;\n\n        var indicesIndex = 3;\n        for (var i = 3; i < numberOfVertices; ++i) {\n            indices[indicesIndex++] = i - 1;\n            indices[indicesIndex++] = 0;\n            indices[indicesIndex++] = i;\n        }\n\n        geometry.indices = indices;\n        geometry.primitiveType = PrimitiveType.TRIANGLES;\n        return geometry;\n    }\n\n    function indexTriangleStrip(geometry) {\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 3) {\n            throw new DeveloperError('The number of vertices must be at least 3.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 2;\n\n        if (numberOfVertices > 3) {\n            indices[3] = 0;\n            indices[4] = 2;\n            indices[5] = 3;\n        }\n\n        var indicesIndex = 6;\n        for (var i = 3; i < numberOfVertices - 1; i += 2) {\n            indices[indicesIndex++] = i;\n            indices[indicesIndex++] = i - 1;\n            indices[indicesIndex++] = i + 1;\n\n            if (i + 2 < numberOfVertices) {\n                indices[indicesIndex++] = i;\n                indices[indicesIndex++] = i + 1;\n                indices[indicesIndex++] = i + 2;\n            }\n        }\n\n        geometry.indices = indices;\n        geometry.primitiveType = PrimitiveType.TRIANGLES;\n        return geometry;\n    }\n\n    function indexLines(geometry) {\n        if (defined(geometry.indices)) {\n            return geometry;\n        }\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 2) {\n            throw new DeveloperError('The number of vertices must be at least two.');\n        }\n        if (numberOfVertices % 2 !== 0) {\n            throw new DeveloperError('The number of vertices must be a multiple of 2.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);\n        for (var i = 0; i < numberOfVertices; ++i) {\n            indices[i] = i;\n        }\n\n        geometry.indices = indices;\n        return geometry;\n    }\n\n    function indexLineStrip(geometry) {\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 2) {\n            throw new DeveloperError('The number of vertices must be at least two.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 1) * 2);\n        indices[0] = 0;\n        indices[1] = 1;\n        var indicesIndex = 2;\n        for (var i = 2; i < numberOfVertices; ++i) {\n            indices[indicesIndex++] = i - 1;\n            indices[indicesIndex++] = i;\n        }\n\n        geometry.indices = indices;\n        geometry.primitiveType = PrimitiveType.LINES;\n        return geometry;\n    }\n\n    function indexLineLoop(geometry) {\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (numberOfVertices < 2) {\n            throw new DeveloperError('The number of vertices must be at least two.');\n        }\n        //>>includeEnd('debug');\n\n        var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices * 2);\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        var indicesIndex = 2;\n        for (var i = 2; i < numberOfVertices; ++i) {\n            indices[indicesIndex++] = i - 1;\n            indices[indicesIndex++] = i;\n        }\n\n        indices[indicesIndex++] = numberOfVertices - 1;\n        indices[indicesIndex] = 0;\n\n        geometry.indices = indices;\n        geometry.primitiveType = PrimitiveType.LINES;\n        return geometry;\n    }\n\n    function indexPrimitive(geometry) {\n        switch (geometry.primitiveType) {\n        case PrimitiveType.TRIANGLE_FAN:\n            return indexTriangleFan(geometry);\n        case PrimitiveType.TRIANGLE_STRIP:\n            return indexTriangleStrip(geometry);\n        case PrimitiveType.TRIANGLES:\n            return indexTriangles(geometry);\n        case PrimitiveType.LINE_STRIP:\n            return indexLineStrip(geometry);\n        case PrimitiveType.LINE_LOOP:\n            return indexLineLoop(geometry);\n        case PrimitiveType.LINES:\n            return indexLines(geometry);\n        }\n\n        return geometry;\n    }\n\n    function offsetPointFromXZPlane(p, isBehind) {\n        if (Math.abs(p.y) < CesiumMath.EPSILON6){\n            if (isBehind) {\n                p.y = -CesiumMath.EPSILON6;\n            } else {\n                p.y = CesiumMath.EPSILON6;\n            }\n        }\n    }\n\n    function offsetTriangleFromXZPlane(p0, p1, p2) {\n        if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n            offsetPointFromXZPlane(p0, p0.y < 0.0);\n            offsetPointFromXZPlane(p1, p1.y < 0.0);\n            offsetPointFromXZPlane(p2, p2.y < 0.0);\n            return;\n        }\n\n        var p0y = Math.abs(p0.y);\n        var p1y = Math.abs(p1.y);\n        var p2y = Math.abs(p2.y);\n\n        var sign;\n        if (p0y > p1y) {\n            if (p0y > p2y) {\n                sign = CesiumMath.sign(p0.y);\n            } else {\n                sign = CesiumMath.sign(p2.y);\n            }\n        } else if (p1y > p2y) {\n            sign = CesiumMath.sign(p1.y);\n        } else {\n            sign = CesiumMath.sign(p2.y);\n        }\n\n        var isBehind = sign < 0.0;\n        offsetPointFromXZPlane(p0, isBehind);\n        offsetPointFromXZPlane(p1, isBehind);\n        offsetPointFromXZPlane(p2, isBehind);\n    }\n\n    var c3 = new Cartesian3();\n    function getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n        Cartesian3.add(p, Cartesian3.multiplyByScalar(Cartesian3.subtract(p1, p, c3), p.y/(p.y-p1.y), c3), u1);\n        Cartesian3.clone(u1, v1);\n        offsetPointFromXZPlane(u1, true);\n        offsetPointFromXZPlane(v1, false);\n    }\n\n    var u1 = new Cartesian3();\n    var u2 = new Cartesian3();\n    var q1 = new Cartesian3();\n    var q2 = new Cartesian3();\n\n    var splitTriangleResult = {\n        positions : new Array(7),\n        indices : new Array(3 * 3)\n    };\n\n    function splitTriangle(p0, p1, p2) {\n        // In WGS84 coordinates, for a triangle approximately on the\n        // ellipsoid to cross the IDL, first it needs to be on the\n        // negative side of the plane x = 0.\n        if ((p0.x >= 0.0) || (p1.x >= 0.0) || (p2.x >= 0.0)) {\n            return undefined;\n        }\n\n        offsetTriangleFromXZPlane(p0, p1, p2);\n\n        var p0Behind = p0.y < 0.0;\n        var p1Behind = p1.y < 0.0;\n        var p2Behind = p2.y < 0.0;\n\n        var numBehind = 0;\n        numBehind += p0Behind ? 1 : 0;\n        numBehind += p1Behind ? 1 : 0;\n        numBehind += p2Behind ? 1 : 0;\n\n        var indices = splitTriangleResult.indices;\n\n        if (numBehind === 1) {\n            indices[1] = 3;\n            indices[2] = 4;\n            indices[5] = 6;\n            indices[7] = 6;\n            indices[8] = 5;\n\n            if (p0Behind) {\n                getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n                getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n                indices[0] = 0;\n                indices[3] = 1;\n                indices[4] = 2;\n                indices[6] = 1;\n            } else if (p1Behind) {\n                getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n                getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n                indices[0] = 1;\n                indices[3] = 2;\n                indices[4] = 0;\n                indices[6] = 2;\n            } else if (p2Behind) {\n                getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n                getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n                indices[0] = 2;\n                indices[3] = 0;\n                indices[4] = 1;\n                indices[6] = 0;\n            }\n        } else if (numBehind === 2) {\n            indices[2] = 4;\n            indices[4] = 4;\n            indices[5] = 3;\n            indices[7] = 5;\n            indices[8] = 6;\n\n            if (!p0Behind) {\n                getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n                getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n                indices[0] = 1;\n                indices[1] = 2;\n                indices[3] = 1;\n                indices[6] = 0;\n            } else if (!p1Behind) {\n                getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n                getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n                indices[0] = 2;\n                indices[1] = 0;\n                indices[3] = 2;\n                indices[6] = 1;\n            } else if (!p2Behind) {\n                getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n                getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n                indices[0] = 0;\n                indices[1] = 1;\n                indices[3] = 0;\n                indices[6] = 2;\n            }\n        }\n\n        var positions = splitTriangleResult.positions;\n        positions[0] = p0;\n        positions[1] = p1;\n        positions[2] = p2;\n        positions.length = 3;\n\n        if (numBehind === 1 || numBehind === 2) {\n            positions[3] = u1;\n            positions[4] = u2;\n            positions[5] = q1;\n            positions[6] = q2;\n            positions.length = 7;\n        }\n\n        return splitTriangleResult;\n    }\n\n    function updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n        var attributes = geometry.attributes;\n\n        if (attributes.position.values.length === 0) {\n            return undefined;\n        }\n\n        for (var property in attributes) {\n            if (attributes.hasOwnProperty(property) &&\n                    defined(attributes[property]) &&\n                    defined(attributes[property].values)) {\n\n                var attribute = attributes[property];\n                attribute.values = ComponentDatatype.createTypedArray(attribute.componentDatatype, attribute.values);\n            }\n        }\n\n        var numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n        geometry.indices = IndexDatatype.createTypedArray(numberOfVertices, geometry.indices);\n\n        if (computeBoundingSphere) {\n            geometry.boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n        }\n\n        return geometry;\n    }\n\n    function copyGeometryForSplit(geometry) {\n        var attributes = geometry.attributes;\n        var copiedAttributes = {};\n\n        for (var property in attributes) {\n            if (attributes.hasOwnProperty(property) &&\n                    defined(attributes[property]) &&\n                    defined(attributes[property].values)) {\n\n                var attribute = attributes[property];\n                copiedAttributes[property] = new GeometryAttribute({\n                    componentDatatype : attribute.componentDatatype,\n                    componentsPerAttribute : attribute.componentsPerAttribute,\n                    normalize : attribute.normalize,\n                    values : []\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : copiedAttributes,\n            indices : [],\n            primitiveType : geometry.primitiveType\n        });\n    }\n\n    function updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n        var computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n        westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n        eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n        if (defined(eastGeometry) && !defined(westGeometry)) {\n            instance.geometry = eastGeometry;\n        } else if (!defined(eastGeometry) && defined(westGeometry)) {\n            instance.geometry = westGeometry;\n        } else {\n            instance.westHemisphereGeometry = westGeometry;\n            instance.eastHemisphereGeometry = eastGeometry;\n            instance.geometry = undefined;\n        }\n    }\n\n    var p0Scratch = new Cartesian3();\n    var p1Scratch = new Cartesian3();\n    var p2Scratch = new Cartesian3();\n    var barycentricScratch = new Cartesian3();\n    var s0Scratch = new Cartesian2();\n    var s1Scratch = new Cartesian2();\n    var s2Scratch = new Cartesian2();\n\n    function computeTriangleAttributes(i0, i1, i2, point, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex) {\n        if (!defined(normals) && !defined(binormals) && !defined(tangents) && !defined(texCoords)) {\n            return;\n        }\n\n        var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n        var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n        var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n        var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n\n        if (defined(normals)) {\n            var n0 = Cartesian3.fromArray(normals, i0 * 3, p0Scratch);\n            var n1 = Cartesian3.fromArray(normals, i1 * 3, p1Scratch);\n            var n2 = Cartesian3.fromArray(normals, i2 * 3, p2Scratch);\n\n            Cartesian3.multiplyByScalar(n0, coords.x, n0);\n            Cartesian3.multiplyByScalar(n1, coords.y, n1);\n            Cartesian3.multiplyByScalar(n2, coords.z, n2);\n\n            var normal = Cartesian3.add(n0, n1, n0);\n            Cartesian3.add(normal, n2, normal);\n            Cartesian3.normalize(normal, normal);\n\n            Cartesian3.pack(normal, currentAttributes.normal.values, insertedIndex * 3);\n        }\n\n        if (defined(binormals)) {\n            var b0 = Cartesian3.fromArray(binormals, i0 * 3, p0Scratch);\n            var b1 = Cartesian3.fromArray(binormals, i1 * 3, p1Scratch);\n            var b2 = Cartesian3.fromArray(binormals, i2 * 3, p2Scratch);\n\n            Cartesian3.multiplyByScalar(b0, coords.x, b0);\n            Cartesian3.multiplyByScalar(b1, coords.y, b1);\n            Cartesian3.multiplyByScalar(b2, coords.z, b2);\n\n            var binormal = Cartesian3.add(b0, b1, b0);\n            Cartesian3.add(binormal, b2, binormal);\n            Cartesian3.normalize(binormal, binormal);\n\n            Cartesian3.pack(binormal, currentAttributes.binormal.values, insertedIndex * 3);\n        }\n\n        if (defined(tangents)) {\n            var t0 = Cartesian3.fromArray(tangents, i0 * 3, p0Scratch);\n            var t1 = Cartesian3.fromArray(tangents, i1 * 3, p1Scratch);\n            var t2 = Cartesian3.fromArray(tangents, i2 * 3, p2Scratch);\n\n            Cartesian3.multiplyByScalar(t0, coords.x, t0);\n            Cartesian3.multiplyByScalar(t1, coords.y, t1);\n            Cartesian3.multiplyByScalar(t2, coords.z, t2);\n\n            var tangent = Cartesian3.add(t0, t1, t0);\n            Cartesian3.add(tangent, t2, tangent);\n            Cartesian3.normalize(tangent, tangent);\n\n            Cartesian3.pack(tangent, currentAttributes.tangent.values, insertedIndex * 3);\n        }\n\n        if (defined(texCoords)) {\n            var s0 = Cartesian2.fromArray(texCoords, i0 * 2, s0Scratch);\n            var s1 = Cartesian2.fromArray(texCoords, i1 * 2, s1Scratch);\n            var s2 = Cartesian2.fromArray(texCoords, i2 * 2, s2Scratch);\n\n            Cartesian2.multiplyByScalar(s0, coords.x, s0);\n            Cartesian2.multiplyByScalar(s1, coords.y, s1);\n            Cartesian2.multiplyByScalar(s2, coords.z, s2);\n\n            var texCoord = Cartesian2.add(s0, s1, s0);\n            Cartesian2.add(texCoord, s2, texCoord);\n\n            Cartesian2.pack(texCoord, currentAttributes.st.values, insertedIndex * 2);\n        }\n    }\n\n    function insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {\n        var insertIndex = currentAttributes.position.values.length / 3;\n\n        if (currentIndex !== -1) {\n            var prevIndex = indices[currentIndex];\n            var newIndex = currentIndexMap[prevIndex];\n\n            if (newIndex === -1) {\n                currentIndexMap[prevIndex] = insertIndex;\n                currentAttributes.position.values.push(point.x, point.y, point.z);\n                currentIndices.push(insertIndex);\n                return insertIndex;\n            }\n\n            currentIndices.push(newIndex);\n            return newIndex;\n        }\n\n        currentAttributes.position.values.push(point.x, point.y, point.z);\n        currentIndices.push(insertIndex);\n        return insertIndex;\n    }\n\n    function splitLongitudeTriangles(instance) {\n        var geometry = instance.geometry;\n        var attributes = geometry.attributes;\n        var positions = attributes.position.values;\n        var normals = (defined(attributes.normal)) ? attributes.normal.values : undefined;\n        var binormals = (defined(attributes.binormal)) ? attributes.binormal.values : undefined;\n        var tangents = (defined(attributes.tangent)) ? attributes.tangent.values : undefined;\n        var texCoords = (defined(attributes.st)) ? attributes.st.values : undefined;\n        var indices = geometry.indices;\n\n        var eastGeometry = copyGeometryForSplit(geometry);\n        var westGeometry = copyGeometryForSplit(geometry);\n\n        var currentAttributes;\n        var currentIndices;\n        var currentIndexMap;\n        var insertedIndex;\n        var i;\n\n        var westGeometryIndexMap = [];\n        westGeometryIndexMap.length = positions.length / 3;\n\n        var eastGeometryIndexMap = [];\n        eastGeometryIndexMap.length = positions.length / 3;\n\n        for (i = 0; i < westGeometryIndexMap.length; ++i) {\n            westGeometryIndexMap[i] = -1;\n            eastGeometryIndexMap[i] = -1;\n        }\n\n        var len = indices.length;\n        for (i = 0; i < len; i += 3) {\n            var i0 = indices[i];\n            var i1 = indices[i + 1];\n            var i2 = indices[i + 2];\n\n            var p0 = Cartesian3.fromArray(positions, i0 * 3);\n            var p1 = Cartesian3.fromArray(positions, i1 * 3);\n            var p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n            var result = splitTriangle(p0, p1, p2);\n            if (defined(result) && result.positions.length > 3) {\n                var resultPositions = result.positions;\n                var resultIndices = result.indices;\n                var resultLength = resultIndices.length;\n\n                for (var j = 0; j < resultLength; ++j) {\n                    var resultIndex = resultIndices[j];\n                    var point = resultPositions[resultIndex];\n\n                    if (point.y < 0.0) {\n                        currentAttributes = westGeometry.attributes;\n                        currentIndices = westGeometry.indices;\n                        currentIndexMap = westGeometryIndexMap;\n                    } else {\n                        currentAttributes = eastGeometry.attributes;\n                        currentIndices = eastGeometry.indices;\n                        currentIndexMap = eastGeometryIndexMap;\n                    }\n\n                    insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, resultIndex < 3 ? i + resultIndex : -1, point);\n                    computeTriangleAttributes(i0, i1, i2, point, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);\n                }\n            } else {\n                if (defined(result)) {\n                    p0 = result.positions[0];\n                    p1 = result.positions[1];\n                    p2 = result.positions[2];\n                }\n\n                if (p0.y < 0.0) {\n                    currentAttributes = westGeometry.attributes;\n                    currentIndices = westGeometry.indices;\n                    currentIndexMap = westGeometryIndexMap;\n                } else {\n                    currentAttributes = eastGeometry.attributes;\n                    currentIndices = eastGeometry.indices;\n                    currentIndexMap = eastGeometryIndexMap;\n                }\n\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n                computeTriangleAttributes(i0, i1, i2, p0, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);\n\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n                computeTriangleAttributes(i0, i1, i2, p1, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);\n\n                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 2, p2);\n                computeTriangleAttributes(i0, i1, i2, p2, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);\n            }\n        }\n\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n    }\n\n    var xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\n    var offsetScratch = new Cartesian3();\n    var offsetPointScratch = new Cartesian3();\n\n    function splitLongitudeLines(instance) {\n        var geometry = instance.geometry;\n        var attributes = geometry.attributes;\n        var positions = attributes.position.values;\n        var indices = geometry.indices;\n\n        var eastGeometry = copyGeometryForSplit(geometry);\n        var westGeometry = copyGeometryForSplit(geometry);\n\n        var i;\n        var index;\n        var length = indices.length;\n\n        var westGeometryIndexMap = [];\n        westGeometryIndexMap.length = positions.length / 3;\n\n        var eastGeometryIndexMap = [];\n        eastGeometryIndexMap.length = positions.length / 3;\n\n        for (i = 0; i < westGeometryIndexMap.length; ++i) {\n            westGeometryIndexMap[i] = -1;\n            eastGeometryIndexMap[i] = -1;\n        }\n\n        for (i = 0; i < length; i += 2) {\n            var i0 = indices[i];\n            var i1 = indices[i + 1];\n\n            var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n            var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n\n            if (Math.abs(p0.y) < CesiumMath.EPSILON6){\n                if (p0.y < 0.0) {\n                    p0.y = -CesiumMath.EPSILON6;\n                } else {\n                    p0.y = CesiumMath.EPSILON6;\n                }\n            }\n\n            if (Math.abs(p1.y) < CesiumMath.EPSILON6){\n                if (p1.y < 0.0) {\n                    p1.y = -CesiumMath.EPSILON6;\n                } else {\n                    p1.y = CesiumMath.EPSILON6;\n                }\n            }\n\n            var p0Attributes = eastGeometry.attributes;\n            var p0Indices = eastGeometry.indices;\n            var p0IndexMap = eastGeometryIndexMap;\n            var p1Attributes = westGeometry.attributes;\n            var p1Indices = westGeometry.indices;\n            var p1IndexMap = westGeometryIndexMap;\n\n            var intersection = IntersectionTests.lineSegmentPlane(p0, p1, xzPlane, p2Scratch);\n            if (defined(intersection)) {\n                // move point on the xz-plane slightly away from the plane\n                var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5.0 * CesiumMath.EPSILON9, offsetScratch);\n                if (p0.y < 0.0) {\n                    Cartesian3.negate(offset, offset);\n\n                    p0Attributes = westGeometry.attributes;\n                    p0Indices = westGeometry.indices;\n                    p0IndexMap = westGeometryIndexMap;\n                    p1Attributes = eastGeometry.attributes;\n                    p1Indices = eastGeometry.indices;\n                    p1IndexMap = eastGeometryIndexMap;\n                }\n\n                var offsetPoint = Cartesian3.add(intersection, offset, offsetPointScratch);\n                insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, i, p0);\n                insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, -1, offsetPoint);\n\n                Cartesian3.negate(offset, offset);\n                Cartesian3.add(intersection, offset, offsetPoint);\n                insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, -1, offsetPoint);\n                insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, i + 1, p1);\n            } else {\n                var currentAttributes;\n                var currentIndices;\n                var currentIndexMap;\n\n                if (p0.y < 0.0) {\n                    currentAttributes = westGeometry.attributes;\n                    currentIndices = westGeometry.indices;\n                    currentIndexMap = westGeometryIndexMap;\n                } else {\n                    currentAttributes = eastGeometry.attributes;\n                    currentIndices = eastGeometry.indices;\n                    currentIndexMap = eastGeometryIndexMap;\n                }\n\n                insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);\n                insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);\n            }\n        }\n\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n    }\n\n    var cartesian2Scratch0 = new Cartesian2();\n    var cartesian2Scratch1 = new Cartesian2();\n\n    var cartesian3Scratch0 = new Cartesian3();\n    var cartesian3Scratch1 = new Cartesian3();\n    var cartesian3Scratch2 = new Cartesian3();\n    var cartesian3Scratch3 = new Cartesian3();\n    var cartesian3Scratch4 = new Cartesian3();\n    var cartesian3Scratch5 = new Cartesian3();\n    var cartesian3Scratch6 = new Cartesian3();\n\n    var cartesian4Scratch0 = new Cartesian4();\n    var cartesian4Scratch1 = new Cartesian4();\n\n    function splitLongitudePolyline(instance) {\n        var geometry = instance.geometry;\n        var attributes = geometry.attributes;\n        var positions = attributes.position.values;\n        var prevPositions = attributes.prevPosition.values;\n        var nextPositions = attributes.nextPosition.values;\n        var expandAndWidths = attributes.expandAndWidth.values;\n        var indices = geometry.indices;\n\n        var texCoords = (defined(attributes.st)) ? attributes.st.values : undefined;\n        var colors = (defined(attributes.color)) ? attributes.color.values : undefined;\n\n        var eastGeometry = copyGeometryForSplit(geometry);\n        var westGeometry = copyGeometryForSplit(geometry);\n\n        var i;\n        var j;\n        var index;\n\n        var length = positions.length / 3;\n        for (i = 0; i < length; i += 4) {\n            var i0 = i;\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var i3 = i + 3;\n\n            var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n            var p1 = Cartesian3.fromArray(positions, i1 * 3, cartesian3Scratch1);\n            var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n            var p3 = Cartesian3.fromArray(positions, i3 * 3, cartesian3Scratch3);\n\n            if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n                p0.y = CesiumMath.EPSILON6 * (p2.y < 0.0 ? -1.0 : 1.0);\n                p1.y = p0.y;\n            }\n\n            if (Math.abs(p2.y) < CesiumMath.EPSILON6) {\n                p2.y = CesiumMath.EPSILON6 * (p0.y < 0.0 ? -1.0 : 1.0);\n                p3.y = p2.y;\n            }\n\n            var p0Attributes = eastGeometry.attributes;\n            var p0Indices = eastGeometry.indices;\n            var p2Attributes = westGeometry.attributes;\n            var p2Indices = westGeometry.indices;\n\n            var intersection = IntersectionTests.lineSegmentPlane(p0, p2, xzPlane, cartesian3Scratch4);\n            if (defined(intersection)) {\n                // move point on the xz-plane slightly away from the plane\n                var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5.0 * CesiumMath.EPSILON9, cartesian3Scratch5);\n                if (p0.y < 0.0) {\n                    Cartesian3.negate(offset, offset);\n                    p0Attributes = westGeometry.attributes;\n                    p0Indices = westGeometry.indices;\n                    p2Attributes = eastGeometry.attributes;\n                    p2Indices = eastGeometry.indices;\n                }\n\n                var offsetPoint = Cartesian3.add(intersection, offset, cartesian3Scratch6);\n                p0Attributes.position.values.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n                p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n                p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n\n                Cartesian3.negate(offset, offset);\n                Cartesian3.add(intersection, offset, offsetPoint);\n                p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n                p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);\n                p2Attributes.position.values.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);\n\n                for (j = i0 * 3; j < i0 * 3 + 2 * 3; ++j) {\n                    p0Attributes.prevPosition.values.push(prevPositions[j]);\n                }\n                p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n                p2Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n                for (j = i2 * 3; j < i2 * 3 + 2 * 3; ++j) {\n                    p2Attributes.prevPosition.values.push(prevPositions[j]);\n                }\n\n                for (j = i0 * 3; j < i0 * 3 + 2 * 3; ++j) {\n                    p0Attributes.nextPosition.values.push(nextPositions[j]);\n                }\n                p0Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n                p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n                for (j = i2 * 3; j < i2 * 3 + 2 * 3; ++j) {\n                    p2Attributes.nextPosition.values.push(nextPositions[j]);\n                }\n\n                var ew0 = Cartesian2.fromArray(expandAndWidths, i0 * 2, cartesian2Scratch0);\n                var width = Math.abs(ew0.y);\n\n                p0Attributes.expandAndWidth.values.push(-1,  width, 1,  width);\n                p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n                p2Attributes.expandAndWidth.values.push(-1,  width, 1,  width);\n                p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n                var t = Cartesian3.magnitudeSquared(Cartesian3.subtract(intersection, p0, cartesian3Scratch3));\n                t /= Cartesian3.magnitudeSquared(Cartesian3.subtract(p2, p0, cartesian3Scratch3));\n\n                if (defined(colors)) {\n                    var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n                    var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n                    var r = CesiumMath.lerp(c0.x, c2.x, t);\n                    var g = CesiumMath.lerp(c0.y, c2.y, t);\n                    var b = CesiumMath.lerp(c0.z, c2.z, t);\n                    var a = CesiumMath.lerp(c0.w, c2.w, t);\n\n                    for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n                        p0Attributes.color.values.push(colors[j]);\n                    }\n                    p0Attributes.color.values.push(r, g, b, a);\n                    p0Attributes.color.values.push(r, g, b, a);\n                    p2Attributes.color.values.push(r, g, b, a);\n                    p2Attributes.color.values.push(r, g, b, a);\n                    for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n                        p2Attributes.color.values.push(colors[j]);\n                    }\n                }\n\n                if (defined(texCoords)) {\n                    var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n                    var s3 = Cartesian2.fromArray(texCoords, (i + 3) * 2, cartesian2Scratch1);\n\n                    var sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n                    for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n                        p0Attributes.st.values.push(texCoords[j]);\n                    }\n                    p0Attributes.st.values.push(sx, s0.y);\n                    p0Attributes.st.values.push(sx, s3.y);\n                    p2Attributes.st.values.push(sx, s0.y);\n                    p2Attributes.st.values.push(sx, s3.y);\n                    for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n                        p2Attributes.st.values.push(texCoords[j]);\n                    }\n                }\n\n                index = p0Attributes.position.values.length / 3 - 4;\n                p0Indices.push(index, index + 2, index + 1);\n                p0Indices.push(index + 1, index + 2, index + 3);\n\n                index = p2Attributes.position.values.length / 3 - 4;\n                p2Indices.push(index, index + 2, index + 1);\n                p2Indices.push(index + 1, index + 2, index + 3);\n            } else {\n                var currentAttributes;\n                var currentIndices;\n\n                if (p0.y < 0.0) {\n                    currentAttributes = westGeometry.attributes;\n                    currentIndices = westGeometry.indices;\n                } else {\n                    currentAttributes = eastGeometry.attributes;\n                    currentIndices = eastGeometry.indices;\n                }\n\n                currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n                currentAttributes.position.values.push(p1.x, p1.y, p1.z);\n                currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n                currentAttributes.position.values.push(p3.x, p3.y, p3.z);\n\n                for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n                    currentAttributes.prevPosition.values.push(prevPositions[j]);\n                    currentAttributes.nextPosition.values.push(nextPositions[j]);\n                }\n\n                for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n                    currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n                    if (defined(texCoords)) {\n                        currentAttributes.st.values.push(texCoords[j]);\n                    }\n                }\n\n                if (defined(colors)) {\n                    for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n                        currentAttributes.color.values.push(colors[j]);\n                    }\n                }\n\n                index = currentAttributes.position.values.length / 3 - 4;\n                currentIndices.push(index, index + 2, index + 1);\n                currentIndices.push(index + 1, index + 2, index + 3);\n            }\n        }\n\n        updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n    }\n\n    /**\n     * Splits the instances's geometry, by introducing new vertices and indices,that\n     * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n     * -180/180 degrees.  This is not required for 3D drawing, but is required for\n     * correcting drawing in 2D and Columbus view.\n     *\n     * @private\n     *\n     * @param {GeometryInstance} instance The instance to modify.\n     * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n     *\n     * @example\n     * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n     */\n    GeometryPipeline.splitLongitude = function(instance) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(instance)) {\n            throw new DeveloperError('instance is required.');\n        }\n        //>>includeEnd('debug');\n\n        var geometry = instance.geometry;\n        var boundingSphere = geometry.boundingSphere;\n        if (defined(boundingSphere)) {\n            var minX = boundingSphere.center.x - boundingSphere.radius;\n            if (minX > 0 || BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n                return instance;\n            }\n        }\n\n        if (geometry.geometryType !== GeometryType.NONE) {\n            switch (geometry.geometryType) {\n            case GeometryType.POLYLINES:\n                splitLongitudePolyline(instance);\n                break;\n            case GeometryType.TRIANGLES:\n                splitLongitudeTriangles(instance);\n                break;\n            case GeometryType.LINES:\n                splitLongitudeLines(instance);\n                break;\n            }\n        } else {\n            indexPrimitive(geometry);\n            if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n                splitLongitudeTriangles(instance);\n            } else if (geometry.primitiveType === PrimitiveType.LINES) {\n                splitLongitudeLines(instance);\n            }\n        }\n\n        return instance;\n    };\n\n    return GeometryPipeline;\n});\n",
    "\n/*global define*/\ndefine('Core/Matrix2',[\n        './Cartesian2',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject'\n    ], function(\n        Cartesian2,\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * A 2x2 matrix, indexable as a column-major order array.\n     * Constructor parameters are in row-major order for code readability.\n     * @alias Matrix2\n     * @constructor\n     *\n     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n     *\n     * @see Matrix2.fromColumnMajorArray\n     * @see Matrix2.fromRowMajorArray\n     * @see Matrix2.fromScale\n     * @see Matrix2.fromUniformScale\n     * @see Matrix3\n     * @see Matrix4\n     */\n    var Matrix2 = function(column0Row0, column1Row0, column0Row1, column1Row1) {\n        this[0] = defaultValue(column0Row0, 0.0);\n        this[1] = defaultValue(column0Row1, 0.0);\n        this[2] = defaultValue(column1Row0, 0.0);\n        this[3] = defaultValue(column1Row1, 0.0);\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Matrix2.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Matrix2} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Matrix2.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value[0];\n        array[startingIndex++] = value[1];\n        array[startingIndex++] = value[2];\n        array[startingIndex++] = value[3];\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Matrix2} [result] The object into which to store the result.\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n     */\n    Matrix2.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Matrix2();\n        }\n\n        result[0] = array[startingIndex++];\n        result[1] = array[startingIndex++];\n        result[2] = array[startingIndex++];\n        result[3] = array[startingIndex++];\n        return result;\n    };\n\n    /**\n     * Duplicates a Matrix2 instance.\n     *\n     * @param {Matrix2} matrix The matrix to duplicate.\n     * @param {Matrix2} [result] The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n     */\n    Matrix2.clone = function(values, result) {\n        if (!defined(values)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new Matrix2(values[0], values[2],\n                               values[1], values[3]);\n        }\n        result[0] = values[0];\n        result[1] = values[1];\n        result[2] = values[2];\n        result[3] = values[3];\n        return result;\n    };\n\n    /**\n     * Creates a Matrix2 from 4 consecutive elements in an array.\n     *\n     * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n     * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n     * @param {Matrix2} [result] The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n     *\n     * @example\n     * // Create the Matrix2:\n     * // [1.0, 2.0]\n     * // [1.0, 2.0]\n     *\n     * var v = [1.0, 1.0, 2.0, 2.0];\n     * var m = Cesium.Matrix2.fromArray(v);\n     *\n     * // Create same Matrix2 with using an offset into an array\n     * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n     * var m2 = Cesium.Matrix2.fromArray(v2, 2);\n     */\n    Matrix2.fromArray = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Matrix2();\n        }\n\n        result[0] = array[startingIndex];\n        result[1] = array[startingIndex + 1];\n        result[2] = array[startingIndex + 2];\n        result[3] = array[startingIndex + 3];\n        return result;\n    };\n\n    /**\n     * Creates a Matrix2 instance from a column-major order array.\n     *\n     * @param {Number[]} values The column-major order array.\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n     */\n    Matrix2.fromColumnMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values parameter is required');\n        }\n        //>>includeEnd('debug');\n\n        return Matrix2.clone(values, result);\n    };\n\n    /**\n     * Creates a Matrix2 instance from a row-major order array.\n     * The resulting matrix will be in column-major order.\n     *\n     * @param {Number[]} values The row-major order array.\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n     */\n    Matrix2.fromRowMajorArray = function(values, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(values)) {\n            throw new DeveloperError('values is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix2(values[0], values[1],\n                               values[2], values[3]);\n        }\n        result[0] = values[0];\n        result[1] = values[2];\n        result[2] = values[1];\n        result[3] = values[3];\n        return result;\n    };\n\n    /**\n     * Computes a Matrix2 instance representing a non-uniform scale.\n     *\n     * @param {Cartesian2} scale The x and y scale factors.\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [7.0, 0.0]\n     * //   [0.0, 8.0]\n     * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n     */\n    Matrix2.fromScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix2(\n                scale.x, 0.0,\n                0.0,     scale.y);\n        }\n\n        result[0] = scale.x;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = scale.y;\n        return result;\n    };\n\n    /**\n     * Computes a Matrix2 instance representing a uniform scale.\n     *\n     * @param {Number} scale The uniform scale factor.\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n     *\n     * @example\n     * // Creates\n     * //   [2.0, 0.0]\n     * //   [0.0, 2.0]\n     * var m = Cesium.Matrix2.fromUniformScale(2.0);\n     */\n    Matrix2.fromUniformScale = function(scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof scale !== 'number') {\n            throw new DeveloperError('scale is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return new Matrix2(\n                scale, 0.0,\n                0.0,   scale);\n        }\n\n        result[0] = scale;\n        result[1] = 0.0;\n        result[2] = 0.0;\n        result[3] = scale;\n        return result;\n    };\n\n    /**\n     * Creates a rotation matrix.\n     *\n     * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n     *\n     * @example\n     * // Rotate a point 45 degrees counterclockwise.\n     * var p = new Cesium.Cartesian2(5, 6);\n     * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n     * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n     */\n    Matrix2.fromRotation = function(angle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(angle)) {\n            throw new DeveloperError('angle is required.');\n        }\n        //>>includeEnd('debug');\n\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n\n        if (!defined(result)) {\n            return new Matrix2(\n                cosAngle, -sinAngle,\n                sinAngle, cosAngle);\n        }\n        result[0] = cosAngle;\n        result[1] = sinAngle;\n        result[2] = -sinAngle;\n        result[3] = cosAngle;\n        return result;\n    };\n\n    /**\n     * Creates an Array from the provided Matrix2 instance.\n     * The array will be in column-major order.\n     *\n     * @param {Matrix2} matrix The matrix to use..\n     * @param {Number[]} [result] The Array onto which to store the result.\n     * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n     */\n    Matrix2.toArray = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            return [matrix[0], matrix[1], matrix[2], matrix[3]];\n        }\n        result[0] = matrix[0];\n        result[1] = matrix[1];\n        result[2] = matrix[2];\n        result[3] = matrix[3];\n        return result;\n    };\n\n    /**\n     * Computes the array index of the element at the provided row and column.\n     *\n     * @param {Number} row The zero-based index of the row.\n     * @param {Number} column The zero-based index of the column.\n     * @returns {Number} The index of the element at the provided row and column.\n     *\n     * @exception {DeveloperError} row must be 0 or 1.\n     * @exception {DeveloperError} column must be 0 or 1.\n     *\n     * @example\n     * var myMatrix = new Cesium.Matrix2();\n     * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n     * var column1Row0 = myMatrix[column1Row0Index]\n     * myMatrix[column1Row0Index] = 10.0;\n     */\n    Matrix2.getElementIndex = function(column, row) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof row !== 'number' || row < 0 || row > 1) {\n            throw new DeveloperError('row must be 0 or 1.');\n        }\n        if (typeof column !== 'number' || column < 0 || column > 1) {\n            throw new DeveloperError('column must be 0 or 1.');\n        }\n        //>>includeEnd('debug');\n\n        return column * 2 + row;\n    };\n\n    /**\n     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n     *\n     * @param {Matrix2} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to retrieve.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0 or 1.\n     */\n    Matrix2.getColumn = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 1) {\n            throw new DeveloperError('index must be 0 or 1.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var startIndex = index * 2;\n        var x = matrix[startIndex];\n        var y = matrix[startIndex + 1];\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n     *\n     * @param {Matrix2} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the column to set.\n     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0 or 1.\n     */\n    Matrix2.setColumn = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 1) {\n            throw new DeveloperError('index must be 0 or 1.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix2.clone(matrix, result);\n        var startIndex = index * 2;\n        result[startIndex] = cartesian.x;\n        result[startIndex + 1] = cartesian.y;\n        return result;\n    };\n\n    /**\n     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n     *\n     * @param {Matrix2} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to retrieve.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0 or 1.\n     */\n    Matrix2.getRow = function(matrix, index, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 1) {\n            throw new DeveloperError('index must be 0 or 1.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = matrix[index];\n        var y = matrix[index + 2];\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n     *\n     * @param {Matrix2} matrix The matrix to use.\n     * @param {Number} index The zero-based index of the row to set.\n     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     *\n     * @exception {DeveloperError} index must be 0 or 1.\n     */\n    Matrix2.setRow = function(matrix, index, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (typeof index !== 'number' || index < 0 || index > 1) {\n            throw new DeveloperError('index must be 0 or 1.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result = Matrix2.clone(matrix, result);\n        result[index] = cartesian.x;\n        result[index + 2] = cartesian.y;\n        return result;\n    };\n\n    var scratchColumn = new Cartesian2();\n\n    /**\n     * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n     *\n     * @param {Matrix2} matrix The matrix.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Matrix2.getScale = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = Cartesian2.magnitude(Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn));\n        result.y = Cartesian2.magnitude(Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn));\n        return result;\n    };\n\n    var scratchScale = new Cartesian2();\n\n    /**\n     * Computes the maximum scale assuming the matrix is an affine transformation.\n     * The maximum scale is the maximum length of the column vectors.\n     *\n     * @param {Matrix2} matrix The matrix.\n     * @returns {Number} The maximum scale.\n     */\n    Matrix2.getMaximumScale = function(matrix) {\n        Matrix2.getScale(matrix, scratchScale);\n        return Cartesian2.maximumComponent(scratchScale);\n    };\n\n    /**\n     * Computes the product of two matrices.\n     *\n     * @param {Matrix2} left The first matrix.\n     * @param {Matrix2} right The second matrix.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.multiply = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = left[0] * right[0] + left[2] * right[1];\n        var column1Row0 = left[0] * right[2] + left[2] * right[3];\n        var column0Row1 = left[1] * right[0] + left[3] * right[1];\n        var column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column1Row0;\n        result[3] = column1Row1;\n        return result;\n    };\n\n    /**\n     * Computes the sum of two matrices.\n     *\n     * @param {Matrix2} left The first matrix.\n     * @param {Matrix2} right The second matrix.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] + right[0];\n        result[1] = left[1] + right[1];\n        result[2] = left[2] + right[2];\n        result[3] = left[3] + right[3];\n        return result;\n    };\n\n    /**\n     * Computes the difference of two matrices.\n     *\n     * @param {Matrix2} left The first matrix.\n     * @param {Matrix2} right The second matrix.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = left[0] - right[0];\n        result[1] = left[1] - right[1];\n        result[2] = left[2] - right[2];\n        result[3] = left[3] - right[3];\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a column vector.\n     *\n     * @param {Matrix2} matrix The matrix.\n     * @param {Cartesian2} cartesian The column.\n     * @param {Cartesian2} result The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter.\n     */\n    Matrix2.multiplyByVector = function(matrix, cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n        var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix and a scalar.\n     *\n     * @param {Matrix2} matrix The matrix.\n     * @param {Number} scalar The number to multiply by.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.multiplyByScalar = function(matrix, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0] * scalar;\n        result[1] = matrix[1] * scalar;\n        result[2] = matrix[2] * scalar;\n        result[3] = matrix[3] * scalar;\n        return result;\n    };\n\n    /**\n     * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n     *\n     * @param {Matrix2} matrix The matrix on the left-hand side.\n     * @param {Cartesian2} scale The non-uniform scale on the right-hand side.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     *\n     * @see Matrix2.fromScale\n     * @see Matrix2.multiplyByUniformScale\n     *\n     * @example\n     * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n     * Cesium.Matrix2.multiplyByScale(m, scale, m);\n     */\n    Matrix2.multiplyByScale = function(matrix, scale, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(scale)) {\n            throw new DeveloperError('scale is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = matrix[0] * scale.x;\n        result[1] = matrix[1] * scale.x;\n        result[2] = matrix[2] * scale.y;\n        result[3] = matrix[3] * scale.y;\n        return result;\n    };\n\n    /**\n     * Creates a negated copy of the provided matrix.\n     *\n     * @param {Matrix2} matrix The matrix to negate.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.negate = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = -matrix[0];\n        result[1] = -matrix[1];\n        result[2] = -matrix[2];\n        result[3] = -matrix[3];\n        return result;\n    };\n\n    /**\n     * Computes the transpose of the provided matrix.\n     *\n     * @param {Matrix2} matrix The matrix to transpose.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.transpose = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var column0Row0 = matrix[0];\n        var column0Row1 = matrix[2];\n        var column1Row0 = matrix[1];\n        var column1Row1 = matrix[3];\n\n        result[0] = column0Row0;\n        result[1] = column0Row1;\n        result[2] = column1Row0;\n        result[3] = column1Row1;\n        return result;\n    };\n\n    /**\n     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n     *\n     * @param {Matrix2} matrix The matrix with signed elements.\n     * @param {Matrix2} result The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter.\n     */\n    Matrix2.abs = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result[0] = Math.abs(matrix[0]);\n        result[1] = Math.abs(matrix[1]);\n        result[2] = Math.abs(matrix[2]);\n        result[3] = Math.abs(matrix[3]);\n\n        return result;\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix2} [left] The first matrix.\n     * @param {Matrix2} [right] The second matrix.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Matrix2.equals = function(left, right) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                left[0] === right[0] &&\n                left[1] === right[1] &&\n                left[2] === right[2] &&\n                left[3] === right[3]);\n    };\n\n    /**\n     * @private\n     */\n    Matrix2.equalsArray = function(matrix, array, offset) {\n        return matrix[0] === array[offset] &&\n               matrix[1] === array[offset + 1] &&\n               matrix[2] === array[offset + 2] &&\n               matrix[3] === array[offset + 3];\n    };\n\n    /**\n     * Compares the provided matrices componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix2} [left] The first matrix.\n     * @param {Matrix2} [right] The second matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Matrix2.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon must be a number');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n                (defined(left) &&\n                defined(right) &&\n                Math.abs(left[0] - right[0]) <= epsilon &&\n                Math.abs(left[1] - right[1]) <= epsilon &&\n                Math.abs(left[2] - right[2]) <= epsilon &&\n                Math.abs(left[3] - right[3]) <= epsilon);\n    };\n\n    /**\n     * An immutable Matrix2 instance initialized to the identity matrix.\n     *\n     * @type {Matrix2}\n     * @constant\n     */\n    Matrix2.IDENTITY = freezeObject(new Matrix2(1.0, 0.0,\n                                                0.0, 1.0));\n\n    /**\n     * An immutable Matrix2 instance initialized to the zero matrix.\n     *\n     * @type {Matrix2}\n     * @constant\n     */\n    Matrix2.ZERO = freezeObject(new Matrix2(0.0, 0.0,\n                                            0.0, 0.0));\n\n    /**\n     * The index into Matrix2 for column 0, row 0.\n     *\n     * @type {Number}\n     * @constant\n     *\n     * @example\n     * var matrix = new Cesium.Matrix2();\n     * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n     */\n    Matrix2.COLUMN0ROW0 = 0;\n\n    /**\n     * The index into Matrix2 for column 0, row 1.\n     *\n     * @type {Number}\n     * @constant\n     *\n     * @example\n     * var matrix = new Cesium.Matrix2();\n     * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n     */\n    Matrix2.COLUMN0ROW1 = 1;\n\n    /**\n     * The index into Matrix2 for column 1, row 0.\n     *\n     * @type {Number}\n     * @constant\n     *\n     * @example\n     * var matrix = new Cesium.Matrix2();\n     * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n     */\n    Matrix2.COLUMN1ROW0 = 2;\n\n    /**\n     * The index into Matrix2 for column 1, row 1.\n     *\n     * @type {Number}\n     * @constant\n     *\n     * @example\n     * var matrix = new Cesium.Matrix2();\n     * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n     */\n    Matrix2.COLUMN1ROW1 = 3;\n\n    /**\n     * Duplicates the provided Matrix2 instance.\n     *\n     * @param {Matrix2} [result] The object onto which to store the result.\n     * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n     */\n    Matrix2.prototype.clone = function(result) {\n        return Matrix2.clone(this, result);\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Matrix2} [right] The right hand side matrix.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    Matrix2.prototype.equals = function(right) {\n        return Matrix2.equals(this, right);\n    };\n\n    /**\n     * Compares this matrix to the provided matrix componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Matrix2} [right] The right hand side matrix.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Matrix2.prototype.equalsEpsilon = function(right, epsilon) {\n        return Matrix2.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Creates a string representing this Matrix with each row being\n     * on a separate line and in the format '(column0, column1)'.\n     *\n     * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n     */\n    Matrix2.prototype.toString = function() {\n        return '(' + this[0] + ', ' + this[2] + ')\\n' +\n               '(' + this[1] + ', ' + this[3] + ')';\n    };\n\n    return Matrix2;\n});\n",
    "\n/*global define*/\ndefine('Core/AxisAlignedBoundingBox',[\n        './Cartesian3',\n        './defaultValue',\n        './defined',\n        './deprecationWarning',\n        './DeveloperError',\n        './Intersect',\n        './Plane'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        deprecationWarning,\n        DeveloperError,\n        Intersect,\n        Plane) {\n    \"use strict\";\n\n    /**\n     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n     * @alias AxisAlignedBoundingBox\n     * @constructor\n     *\n     * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n     * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n     * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n     *\n     * @see BoundingSphere\n     * @see BoundingRectangle\n     */\n    var AxisAlignedBoundingBox = function(minimum, maximum, center) {\n        /**\n         * The minimum point defining the bounding box.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));\n\n        /**\n         * The maximum point defining the bounding box.\n         * @type {Cartesian3}\n         * @default {@link Cartesian3.ZERO}\n         */\n        this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));\n\n        //If center was not defined, compute it.\n        if (!defined(center)) {\n            center = Cartesian3.add(this.minimum, this.maximum, new Cartesian3());\n            Cartesian3.multiplyByScalar(center, 0.5, center);\n        } else {\n            center = Cartesian3.clone(center);\n        }\n\n        /**\n         * The center point of the bounding box.\n         * @type {Cartesian3}\n         */\n        this.center = center;\n    };\n\n    /**\n     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n     * finding the points spaced the farthest apart on the x, y, and z axes.\n     *\n     * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n     *\n     * @example\n     * // Compute an axis aligned bounding box enclosing two points.\n     * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n     */\n    AxisAlignedBoundingBox.fromPoints = function(positions, result) {\n        if (!defined(result)) {\n            result = new AxisAlignedBoundingBox();\n        }\n\n        if (!defined(positions) || positions.length === 0) {\n            result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);\n            result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);\n            result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n            return result;\n        }\n\n        var minimumX = positions[0].x;\n        var minimumY = positions[0].y;\n        var minimumZ = positions[0].z;\n\n        var maximumX = positions[0].x;\n        var maximumY = positions[0].y;\n        var maximumZ = positions[0].z;\n\n        var length = positions.length;\n        for ( var i = 1; i < length; i++) {\n            var p = positions[i];\n            var x = p.x;\n            var y = p.y;\n            var z = p.z;\n\n            minimumX = Math.min(x, minimumX);\n            maximumX = Math.max(x, maximumX);\n            minimumY = Math.min(y, minimumY);\n            maximumY = Math.max(y, maximumY);\n            minimumZ = Math.min(z, minimumZ);\n            maximumZ = Math.max(z, maximumZ);\n        }\n\n        var minimum = result.minimum;\n        minimum.x = minimumX;\n        minimum.y = minimumY;\n        minimum.z = minimumZ;\n\n        var maximum = result.maximum;\n        maximum.x = maximumX;\n        maximum.y = maximumY;\n        maximum.z = maximumZ;\n\n        var center = Cartesian3.add(minimum, maximum, result.center);\n        Cartesian3.multiplyByScalar(center, 0.5, center);\n\n        return result;\n    };\n\n    /**\n     * Duplicates a AxisAlignedBoundingBox instance.\n     *\n     * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n     */\n    AxisAlignedBoundingBox.clone = function(box, result) {\n        if (!defined(box)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new AxisAlignedBoundingBox(box.minimum, box.maximum);\n        }\n\n        result.minimum = Cartesian3.clone(box.minimum, result.minimum);\n        result.maximum = Cartesian3.clone(box.maximum, result.maximum);\n        result.center = Cartesian3.clone(box.center, result.center);\n        return result;\n    };\n\n    /**\n     * Compares the provided AxisAlignedBoundingBox componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    AxisAlignedBoundingBox.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                Cartesian3.equals(left.center, right.center) &&\n                Cartesian3.equals(left.minimum, right.minimum) &&\n                Cartesian3.equals(left.maximum, right.maximum));\n    };\n\n    var intersectScratch = new Cartesian3();\n    /**\n     * Determines which side of a plane a box is located.\n     *\n     * @param {AxisAlignedBoundingBox} box The bounding box to test.\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n     *                      intersects the plane.\n     */\n    AxisAlignedBoundingBox.intersectPlane = function(box, plane) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(box)) {\n            throw new DeveloperError('box is required.');\n        }\n        if (!defined(plane)) {\n            throw new DeveloperError('plane is required.');\n        }\n        //>>includeEnd('debug');\n\n        intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);\n        var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n        var normal = plane.normal;\n        var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n        var s = Cartesian3.dot(box.center, normal) + plane.distance; //signed distance from center\n\n        if (s - e > 0) {\n            return Intersect.INSIDE;\n        }\n\n        if (s + e < 0) {\n            //Not in front because normals point inward\n            return Intersect.OUTSIDE;\n        }\n\n        return Intersect.INTERSECTING;\n    };\n\n    /**\n     * Duplicates this AxisAlignedBoundingBox instance.\n     *\n     * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n     * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n     */\n    AxisAlignedBoundingBox.prototype.clone = function(result) {\n        return AxisAlignedBoundingBox.clone(this, result);\n    };\n\n    /**\n     * Determines which side of a plane this box is located.\n     *\n     * @param {Plane} plane The plane to test against.\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n     *                      intersects the plane.\n     */\n    AxisAlignedBoundingBox.prototype.intersectPlane = function(plane) {\n        return AxisAlignedBoundingBox.intersectPlane(this, plane);\n    };\n\n    /**\n     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    AxisAlignedBoundingBox.prototype.equals = function(right) {\n        return AxisAlignedBoundingBox.equals(this, right);\n    };\n\n    return AxisAlignedBoundingBox;\n});\n",
    "\n/**\n  @license\n  when.js - https://github.com/cujojs/when\n\n  MIT License (c) copyright B Cavalier & J Hann\n\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @version 1.7.1\n */\n\n(function(define) { 'use strict';\ndefine('ThirdParty/when',[],function () {\n\tvar reduceArray, slice, undef;\n\n\t//\n\t// Public API\n\t//\n\n\twhen.defer     = defer;     // Create a deferred\n\twhen.resolve   = resolve;   // Create a resolved promise\n\twhen.reject    = reject;    // Create a rejected promise\n\n\twhen.join      = join;      // Join 2 or more promises\n\n\twhen.all       = all;       // Resolve a list of promises\n\twhen.map       = map;       // Array.map() for promises\n\twhen.reduce    = reduce;    // Array.reduce() for promises\n\n\twhen.any       = any;       // One-winner race\n\twhen.some      = some;      // Multi-winner race\n\n\twhen.chain     = chain;     // Make a promise trigger another resolver\n\n\twhen.isPromise = isPromise; // Determine if a thing is a promise\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if\n\t * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}\n\t * whose value is promiseOrValue if promiseOrValue is an immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}\n\t *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}\n\t *   whose resolution value is:\n\t *   * the resolution value of promiseOrValue if it's a foreign promise, or\n\t *   * promiseOrValue if it's a value\n\t */\n\tfunction resolve(promiseOrValue) {\n\t\tvar promise, deferred;\n\n\t\tif(promiseOrValue instanceof Promise) {\n\t\t\t// It's a when.js promise, so we trust it\n\t\t\tpromise = promiseOrValue;\n\n\t\t} else {\n\t\t\t// It's not a when.js promise. See if it's a foreign promise or a value.\n\t\t\tif(isPromise(promiseOrValue)) {\n\t\t\t\t// It's a thenable, but we don't know where it came from, so don't trust\n\t\t\t\t// its implementation entirely.  Introduce a trusted middleman when.js promise\n\t\t\t\tdeferred = defer();\n\n\t\t\t\t// IMPORTANT: This is the only place when.js should ever call .then() on an\n\t\t\t\t// untrusted promise. Don't expose the return value to the untrusted promise\n\t\t\t\tpromiseOrValue.then(\n\t\t\t\t\tfunction(value)  { deferred.resolve(value); },\n\t\t\t\t\tfunction(reason) { deferred.reject(reason); },\n\t\t\t\t\tfunction(update) { deferred.progress(update); }\n\t\t\t\t);\n\n\t\t\t\tpromise = deferred.promise;\n\n\t\t\t} else {\n\t\t\t\t// It's a value, not a promise.  Create a resolved promise for it.\n\t\t\t\tpromise = fulfilled(promiseOrValue);\n\t\t\t}\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @returns {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then) {\n\t\tthis.then = then;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a callback that will be called when a promise is\n\t\t * fulfilled or rejected.  Optionally also register a progress handler.\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)\n\t\t * @param {function?} [onFulfilledOrRejected]\n\t\t * @param {function?} [onProgress]\n\t\t * @returns {Promise}\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t},\n\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @returns {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @returns {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tyield: function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.spread(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @returns {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Create an already-resolved promise for the supplied value\n\t * @private\n\t *\n\t * @param {*} value\n\t * @returns {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar p = new Promise(function(onFulfilled) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled\n\t\t\ttry {\n\t\t\t\treturn resolve(onFulfilled ? onFulfilled(value) : value);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Create an already-rejected {@link Promise} with the supplied\n\t * rejection reason.\n\t * @private\n\t *\n\t * @param {*} reason\n\t * @returns {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar p = new Promise(function(_, onRejected) {\n\t\t\t// TODO: Promises/A+ check typeof onRejected\n\t\t\ttry {\n\t\t\t\treturn onRejected ? resolve(onRejected(reason)) : rejected(reason);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Creates a new, Deferred with fully isolated resolver and promise parts,\n\t * either or both of which may be given out safely to consumers.\n\t * The Deferred itself has the full API: resolve, reject, progress, and\n\t * then. The resolver has resolve, reject, and progress.  The promise\n\t * only has then.\n\t *\n\t * @returns {Deferred}\n\t */\n\tfunction defer() {\n\t\tvar deferred, promise, handlers, progressHandlers,\n\t\t\t_then, _progress, _resolve;\n\n\t\t/**\n\t\t * The promise for the new deferred\n\t\t * @type {Promise}\n\t\t */\n\t\tpromise = new Promise(then);\n\n\t\t/**\n\t\t * The full Deferred object, with {@link Promise} and {@link Resolver} parts\n\t\t * @class Deferred\n\t\t * @name Deferred\n\t\t */\n\t\tdeferred = {\n\t\t\tthen:     then, // DEPRECATED: use deferred.promise.then\n\t\t\tresolve:  promiseResolve,\n\t\t\treject:   promiseReject,\n\t\t\t// TODO: Consider renaming progress() to notify()\n\t\t\tprogress: promiseProgress,\n\n\t\t\tpromise:  promise,\n\n\t\t\tresolver: {\n\t\t\t\tresolve:  promiseResolve,\n\t\t\t\treject:   promiseReject,\n\t\t\t\tprogress: promiseProgress\n\t\t\t}\n\t\t};\n\n\t\thandlers = [];\n\t\tprogressHandlers = [];\n\n\t\t/**\n\t\t * Pre-resolution then() that adds the supplied callback, errback, and progback\n\t\t * functions to the registered listeners\n\t\t * @private\n\t\t *\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t */\n\t\t_then = function(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\tvar deferred, progressHandler;\n\n\t\t\tdeferred = defer();\n\n\t\t\tprogressHandler = typeof onProgress === 'function'\n\t\t\t\t? function(update) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Allow progress handler to transform progress event\n\t\t\t\t\t\tdeferred.progress(onProgress(update));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// Use caught value as progress\n\t\t\t\t\t\tdeferred.progress(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t: function(update) { deferred.progress(update); };\n\n\t\t\thandlers.push(function(promise) {\n\t\t\t\tpromise.then(onFulfilled, onRejected)\n\t\t\t\t\t.then(deferred.resolve, deferred.reject, progressHandler);\n\t\t\t});\n\n\t\t\tprogressHandlers.push(progressHandler);\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @private\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\t_progress = function(update) {\n\t\t\tprocessQueue(progressHandlers, update);\n\t\t\treturn update;\n\t\t};\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the resolution or rejection\n\t\t * @private\n\t\t * @param {*} value the value of this deferred\n\t\t */\n\t\t_resolve = function(value) {\n\t\t\tvalue = resolve(value);\n\n\t\t\t// Replace _then with one that directly notifies with the result.\n\t\t\t_then = value.then;\n\t\t\t// Replace _resolve so that this Deferred can only be resolved once\n\t\t\t_resolve = resolve;\n\t\t\t// Make _progress a noop, to disallow progress for the resolved promise.\n\t\t\t_progress = noop;\n\n\t\t\t// Notify handlers\n\t\t\tprocessQueue(handlers, value);\n\n\t\t\t// Free progressHandlers array since we'll never issue progress events\n\t\t\tprogressHandlers = handlers = undef;\n\n\t\t\treturn value;\n\t\t};\n\n\t\treturn deferred;\n\n\t\t/**\n\t\t * Wrapper to allow _then to be replaced safely\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\treturn _then(onFulfilled, onRejected, onProgress);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _resolve to be replaced\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\treturn _resolve(val);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _reject to be replaced\n\t\t */\n\t\tfunction promiseReject(err) {\n\t\t\treturn _resolve(rejected(err));\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _progress to be replaced\n\t\t */\n\t\tfunction promiseProgress(update) {\n\t\t\treturn _progress(update);\n\t\t}\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not.  Uses the feature\n\t * test from http://wiki.commonjs.org/wiki/Promises/A to determine if\n\t * promiseOrValue is a promise.\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1\n\t * rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\tcheckCallbacks(2, arguments);\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\tvar toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;\n\n\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\tvalues = [];\n\n\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\treasons = [];\n\n\t\t\tdeferred = defer();\n\n\t\t\t// No items in the input, resolve immediately\n\t\t\tif (!toResolve) {\n\t\t\t\tdeferred.resolve(values);\n\n\t\t\t} else {\n\t\t\t\tprogress = deferred.progress;\n\n\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\treasons.push(reason);\n\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.reject(reasons);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t// Another strategy would be to use the original position of\n\t\t\t\t\t// the corresponding promise.\n\t\t\t\t\tvalues.push(val);\n\n\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.resolve(values);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, progress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn deferred.then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction rejecter(reason) {\n\t\t\t\trejectOne(reason);\n\t\t\t}\n\n\t\t\tfunction fulfiller(val) {\n\t\t\t\tfulfillOne(val);\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\tcheckCallbacks(1, arguments);\n\t\treturn map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @returns {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn map(arguments, identity);\n\t}\n\n\t/**\n\t * Traditional map function, similar to `Array.prototype.map()`, but allows\n\t * input to contain {@link Promise}s and/or values, and mapFunc may return\n\t * either a value or a {@link Promise}\n\t *\n\t * @param {Array|Promise} promise array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function} mapFunc mapping function mapFunc(value) which may return\n\t *      either a {@link Promise} or value\n\t * @returns {Promise} a {@link Promise} that will resolve to an array containing\n\t *      the mapped output values.\n\t */\n\tfunction map(promise, mapFunc) {\n\t\treturn when(promise, function(array) {\n\t\t\tvar results, len, toResolve, resolve, i, d;\n\n\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t// array to avoid array expansions.\n\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\tresults = [];\n\t\t\td = defer();\n\n\t\t\tif(!toResolve) {\n\t\t\t\td.resolve(results);\n\t\t\t} else {\n\n\t\t\t\tresolve = function resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\td.resolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, d.reject);\n\t\t\t\t};\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolve(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn d.promise;\n\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = slice.call(arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t/**\n\t * Ensure that resolution of promiseOrValue will trigger resolver with the\n\t * value or reason of promiseOrValue, or instead with resolveValue if it is provided.\n\t *\n\t * @param promiseOrValue\n\t * @param {Object} resolver\n\t * @param {function} resolver.resolve\n\t * @param {function} resolver.reject\n\t * @param {*} [resolveValue]\n\t * @returns {Promise}\n\t */\n\tfunction chain(promiseOrValue, resolver, resolveValue) {\n\t\tvar useResolveValue = arguments.length > 2;\n\n\t\treturn when(promiseOrValue,\n\t\t\tfunction(val) {\n\t\t\t\tval = useResolveValue ? resolveValue : val;\n\t\t\t\tresolver.resolve(val);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tfunction(reason) {\n\t\t\t\tresolver.reject(reason);\n\t\t\t\treturn rejected(reason);\n\t\t\t},\n\t\t\tresolver.progress\n\t\t);\n\t}\n\n\t//\n\t// Utility functions\n\t//\n\n\t/**\n\t * Apply all functions in queue to value\n\t * @param {Array} queue array of functions to execute\n\t * @param {*} value argument passed to each function\n\t */\n\tfunction processQueue(queue, value) {\n\t\tvar handler, i = 0;\n\n\t\twhile (handler = queue[i++]) {\n\t\t\thandler(value);\n\t\t}\n\t}\n\n\t/**\n\t * Helper that checks arrayOfCallbacks to ensure that each element is either\n\t * a function, or null or undefined.\n\t * @private\n\t * @param {number} start index at which to start checking items in arrayOfCallbacks\n\t * @param {Array} arrayOfCallbacks array to check\n\t * @throws {Error} if any element of arrayOfCallbacks is something other than\n\t * a functions, null, or undefined.\n\t */\n\tfunction checkCallbacks(start, arrayOfCallbacks) {\n\t\t// TODO: Promises/A+ update type checking and docs\n\t\tvar arg, i = arrayOfCallbacks.length;\n\n\t\twhile(i > start) {\n\t\t\targ = arrayOfCallbacks[--i];\n\n\t\t\tif (arg != null && typeof arg != 'function') {\n\t\t\t\tthrow new Error('arg '+i+' must be a function');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * No-Op function used in method replacement\n\t * @private\n\t */\n\tfunction noop() {}\n\n\tslice = [].slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.\n\treduceArray = [].reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\n\t\t\t// ES5 dictates that reduce.length === 1\n\n\t\t\t// This implementation deviates from ES5 spec in the following ways:\n\t\t\t// 1. It does not check if reduceFunc is a Callable\n\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\t// This generates a jshint warning, despite being valid\n\t\t\t// \"Missing 'new' prefix when invoking a constructor.\"\n\t\t\t// See https://github.com/jshint/jshint/issues/392\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\t// Skip holes\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(typeof define == 'function' && define.amd\n\t? define\n\t: function (factory) { typeof exports === 'object'\n\t\t? (module.exports = factory())\n\t\t: (this.when      = factory());\n\t}\n\t// Boilerplate for AMD, Node, and browser global\n);",
    "\n/*global define*/\ndefine('Core/binarySearch',[\n        './defined',\n        './DeveloperError'\n    ], function(\n        defined,\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Finds an item in a sorted array.\n     *\n     * @exports binarySearch\n     *\n     * @param {Array} array The sorted array to search.\n     * @param {Object} itemToFind The item to find in the array.\n     * @param {binarySearch~Comparator} comparator The function to use to compare the item to\n     *        elements in the array.\n     * @returns {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>\n     *        does not exist, the return value is a negative number which is the bitwise complement (~)\n     *        of the index before which the itemToFind should be inserted in order to maintain the\n     *        sorted order of the array.\n     *\n     * @example\n     * // Create a comparator function to search through an array of numbers.\n     * var comparator = function(a, b) {\n     *     return a - b;\n     * };\n     * var numbers = [0, 2, 4, 6, 8];\n     * var index = Cesium.binarySearch(numbers, 6, comparator); // 3\n     */\n    var binarySearch = function(array, itemToFind, comparator) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required.');\n        }\n        if (!defined(itemToFind)) {\n            throw new DeveloperError('itemToFind is required.');\n        }\n        if (!defined(comparator)) {\n            throw new DeveloperError('comparator is required.');\n        }\n        //>>includeEnd('debug');\n\n        var low = 0;\n        var high = array.length - 1;\n        var i;\n        var comparison;\n\n        while (low <= high) {\n            i = ~~((low + high) / 2);\n            comparison = comparator(array[i], itemToFind);\n            if (comparison < 0) {\n                low = i + 1;\n                continue;\n            }\n            if (comparison > 0) {\n                high = i - 1;\n                continue;\n            }\n            return i;\n        }\n        return ~(high + 1);\n    };\n\n    /**\n     * A function used to compare two items while performing a binary search.\n     * @callback binarySearch~Comparator\n     *\n     * @param {Object} a An item in the array.\n     * @param {Object} b The item being searched for.\n     * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n     *          a positive value if <code>a</code> is greater than <code>b</code>, or\n     *          0 if <code>a</code> is equal to <code>b</code>.\n     *\n     * @example\n     * function compareNumbers(a, b) {\n     *     return a - b;\n     * }\n     */\n\n    return binarySearch;\n});",
    "\n/*global define*/\ndefine('Core/EarthOrientationParametersSample',[],function() {\n    \"use strict\";\n\n    /**\n     * A set of Earth Orientation Parameters (EOP) sampled at a time.\n     *\n     * @alias EarthOrientationParametersSample\n     * @constructor\n     *\n     * @param {Number} xPoleWander The pole wander about the X axis, in radians.\n     * @param {Number} yPoleWander The pole wander about the Y axis, in radians.\n     * @param {Number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n     * @param {Number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n     * @param {Number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.\n     *\n     * @private\n     */\n    var EarthOrientationParametersSample = function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {\n        /**\n         * The pole wander about the X axis, in radians.\n         * @type {Number}\n         */\n        this.xPoleWander = xPoleWander;\n\n        /**\n         * The pole wander about the Y axis, in radians.\n         * @type {Number}\n         */\n        this.yPoleWander = yPoleWander;\n\n        /**\n         * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n         * @type {Number}\n         */\n        this.xPoleOffset = xPoleOffset;\n\n        /**\n         * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n         * @type {Number}\n         */\n        this.yPoleOffset = yPoleOffset;\n\n        /**\n         * The difference in time standards, UT1 - UTC, in seconds.\n         * @type {Number}\n         */\n        this.ut1MinusUtc = ut1MinusUtc;\n    };\n\n    return EarthOrientationParametersSample;\n});",
    "\n/**\n@license\nsprintf.js from the php.js project - https://github.com/kvz/phpjs\nDirectly from https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js\n\nphp.js is copyright 2012 Kevin van Zonneveld.\n\nPortions copyright Brett Zamir (http://brett-zamir.me), Kevin van Zonneveld\n(http://kevin.vanzonneveld.net), Onno Marsman, Theriault, Michael White\n(http://getsprink.com), Waldo Malqui Silva, Paulo Freitas, Jack, Jonas\nRaoni Soares Silva (http://www.jsfromhell.com), Philip Peterson, Legaev\nAndrey, Ates Goral (http://magnetiq.com), Alex, Ratheous, Martijn Wieringa,\nRafa? Kukawski (http://blog.kukawski.pl), lmeyrick\n(https://sourceforge.net/projects/bcmath-js/), Nate, Philippe Baumann,\nEnrique Gonzalez, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R.\nL. Rodrigues (http://www.jsfromhell.com), Ash Searle\n(http://hexmen.com/blog/), Jani Hartikainen, travc, Ole Vrijenhoek,\nErkekjetter, Michael Grier, Rafa? Kukawski (http://kukawski.pl), Johnny\nMast (http://www.phpvrouwen.nl), T.Wild, d3x,\nhttp://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript,\nRafa? Kukawski (http://blog.kukawski.pl/), stag019, pilus, WebDevHobo\n(http://webdevhobo.blogspot.com/), marrtins, GeekFG\n(http://geekfg.blogspot.com), Andrea Giammarchi\n(http://webreflection.blogspot.com), Arpad Ray (mailto:arpad@php.net),\ngorthaur, Paul Smith, Tim de Koning (http://www.kingsquare.nl), Joris, Oleg\nEremeev, Steve Hilder, majak, gettimeofday, KELAN, Josh Fraser\n(http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),\nMarc Palau, Martin\n(http://www.erlenwiese.de/), Breaking Par Consulting Inc\n(http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),\nChris, Mirek Slugen, saulius, Alfonso Jimenez\n(http://www.alfonsojimenez.com), Diplom@t (http://difane.com/), felix,\nMailfaker (http://www.weedem.fr/), Tyler Akins (http://rumkin.com), Caio\nAriede (http://caioariede.com), Robin, Kankrelune\n(http://www.webfaktory.info/), Karol Kowalski, Imgen Tata\n(http://www.myipdf.com/), mdsjack (http://www.mdsjack.bo.it), Dreamer,\nFelix Geisendoerfer (http://www.debuggable.com/felix), Lars Fischer, AJ,\nDavid, Aman Gupta, Michael White, Public Domain\n(http://www.json.org/json2.js), Steven Levithan\n(http://blog.stevenlevithan.com), Sakimori, Pellentesque Malesuada,\nThunder.m, Dj (http://phpjs.org/functions/htmlentities:425#comment_134018),\nSteve Clay, David James, Francois, class_exists, nobbler, T. Wild, Itsacon\n(http://www.itsacon.net/), date, Ole Vrijenhoek (http://www.nervous.nl/),\nFox, Raphael (Ao RUDLER), Marco, noname, Mateusz \"loonquawl\" Zalega, Frank\nForte, Arno, ger, mktime, john (http://www.jd-tech.net), Nick Kolosov\n(http://sammy.ru), marc andreu, Scott Cariss, Douglas Crockford\n(http://javascript.crockford.com), madipta, Slawomir Kaniecki,\nReverseSyntax, Nathan, Alex Wilson, kenneth, Bayron Guevara, Adam Wallner\n(http://web2.bitbaro.hu/), paulo kuong, jmweb, Lincoln Ramsay, djmix,\nPyerre, Jon Hohle, Thiago Mata (http://thiagomata.blog.com), lmeyrick\n(https://sourceforge.net/projects/bcmath-js/this.), Linuxworld, duncan,\nGilbert, Sanjoy Roy, Shingo, sankai, Oskar Larsson H?gfeldt\n(http://oskar-lh.name/), Denny Wardhana, 0m3r, Everlasto, Subhasis Deb,\njosh, jd, Pier Paolo Ramon (http://www.mastersoup.com/), P, merabi, Soren\nHansen, Eugene Bulkin (http://doubleaw.com/), Der Simon\n(http://innerdom.sourceforge.net/), echo is bad, Ozh, XoraX\n(http://www.xorax.info), EdorFaus, JB, J A R, Marc Jansen, Francesco, LH,\nStoyan Kyosev (http://www.svest.org/), nord_ua, omid\n(http://phpjs.org/functions/380:380#comment_137122), Brad Touesnard, MeEtc\n(http://yass.meetcweb.com), Peter-Paul Koch\n(http://www.quirksmode.org/js/beat.html), Olivier Louvignes\n(http://mg-crea.com/), T0bsn, Tim Wiel, Bryan Elliott, Jalal Berrami,\nMartin, JT, David Randall, Thomas Beaucourt (http://www.webapp.fr), taith,\nvlado houba, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian Nucleair\nResearch Centre), Martin Pool, Kirk Strobeck, Rick Waldron, Brant Messenger\n(http://www.brantmessenger.com/), Devan Penner-Woelk, Saulo Vallory, Wagner\nB. Soares, Artur Tchernychev, Valentina De Rosa, Jason Wong\n(http://carrot.org/), Christoph, Daniel Esteban, strftime, Mick@el, rezna,\nSimon Willison (http://simonwillison.net), Anton Ongson, Gabriel Paderni,\nMarco van Oort, penutbutterjelly, Philipp Lenssen, Bjorn Roesbeke\n(http://www.bjornroesbeke.be/), Bug?, Eric Nagel, Tomasz Wesolowski,\nEvertjan Garretsen, Bobby Drake, Blues (http://tech.bluesmoon.info/), Luke\nGodfrey, Pul, uestla, Alan C, Ulrich, Rafal Kukawski, Yves Sucaet,\nsowberry, Norman \"zEh\" Fuchs, hitwork, Zahlii, johnrembo, Nick Callen,\nSteven Levithan (stevenlevithan.com), ejsanders, Scott Baker, Brian Tafoya\n(http://www.premasolutions.com/), Philippe Jausions\n(http://pear.php.net/user/jausions), Aidan Lister\n(http://aidanlister.com/), Rob, e-mike, HKM, ChaosNo1, metjay, strcasecmp,\nstrcmp, Taras Bogach, jpfle, Alexander Ermolaev\n(http://snippets.dzone.com/user/AlexanderErmolaev), DxGx, kilops, Orlando,\ndptr1988, Le Torbi, James (http://www.james-bell.co.uk/), Pedro Tainha\n(http://www.pedrotainha.com), James, Arnout Kazemier\n(http://www.3rd-Eden.com), Chris McMacken, gabriel paderni, Yannoo,\nFGFEmperor, baris ozdil, Tod Gentille, Greg Frazier, jakes, 3D-GRAF, Allan\nJensen (http://www.winternet.no), Howard Yeend, Benjamin Lupton, davook,\ndaniel airton wermann (http://wermann.com.br), Atli T¨®r, Maximusya, Ryan\nW Tenney (http://ryan.10e.us), Alexander M Beedie, fearphage\n(http://http/my.opera.com/fearphage/), Nathan Sepulveda, Victor, Matteo,\nBilly, stensi, Cord, Manish, T.J. Leahy, Riddler\n(http://www.frontierwebdev.com/), Rafa? Kukawski, FremyCompany, Matt\nBradley, Tim de Koning, Luis Salazar (http://www.freaky-media.com/), Diogo\nResende, Rival, Andrej Pavlovic, Garagoth, Le Torbi\n(http://www.letorbi.de/), Dino, Josep Sanz (http://www.ws3.es/), rem,\nRussell Walker (http://www.nbill.co.uk/), Jamie Beck\n(http://www.terabit.ca/), setcookie, Michael, YUI Library:\nhttp://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Blues at\nhttp://hacks.bluesmoon.info/strftime/strftime.js, Ben\n(http://benblume.co.uk/), DtTvB\n(http://dt.in.th/2008-09-16.string-length-in-bytes.html), Andreas, William,\nmeo, incidence, Cagri Ekin, Amirouche, Amir Habibi\n(http://www.residence-mixte.com/), Luke Smith (http://lucassmith.name),\nKheang Hok Chin (http://www.distantia.ca/), Jay Klehr, Lorenzo Pisani,\nTony, Yen-Wei Liu, Greenseed, mk.keck, Leslie Hoare, dude, booeyOH, Ben\nBryan\n\nLicensed under the MIT (MIT-LICENSE.txt) license.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES\nOR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*global define*/\ndefine('ThirdParty/sprintf',[],function() {\n\nfunction sprintf () {\n  // http://kevin.vanzonneveld.net\n  // +   original by: Ash Searle (http://hexmen.com/blog/)\n  // + namespaced by: Michael White (http://getsprink.com)\n  // +    tweaked by: Jack\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +      input by: Paulo Freitas\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +      input by: Brett Zamir (http://brett-zamir.me)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +   improved by: Dj\n  // +   improved by: Allidylls\n  // *     example 1: sprintf(\"%01.2f\", 123.1);\n  // *     returns 1: 123.10\n  // *     example 2: sprintf(\"[%10s]\", 'monkey');\n  // *     returns 2: '[    monkey]'\n  // *     example 3: sprintf(\"[%'#10s]\", 'monkey');\n  // *     returns 3: '[####monkey]'\n  // *     example 4: sprintf(\"%d\", 123456789012345);\n  // *     returns 4: '123456789012345'\n  var regex = /%%|%(\\d+\\$)?([-+\\'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g;\n  var a = arguments,\n    i = 0,\n    format = a[i++];\n\n  // pad()\n  var pad = function (str, len, chr, leftJustify) {\n    if (!chr) {\n      chr = ' ';\n    }\n    var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\n    return leftJustify ? str + padding : padding + str;\n  };\n\n  // justify()\n  var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {\n    var diff = minWidth - value.length;\n    if (diff > 0) {\n      if (leftJustify || !zeroPad) {\n        value = pad(value, minWidth, customPadChar, leftJustify);\n      } else {\n        value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\n      }\n    }\n    return value;\n  };\n\n  // formatBaseX()\n  var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\n    // Note: casts negative numbers to positive ones\n    var number = value >>> 0;\n    prefix = prefix && number && {\n      '2': '0b',\n      '8': '0',\n      '16': '0x'\n    }[base] || '';\n    value = prefix + pad(number.toString(base), precision || 0, '0', false);\n    return justify(value, prefix, leftJustify, minWidth, zeroPad);\n  };\n\n  // formatString()\n  var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {\n    if (precision != null) {\n      value = value.slice(0, precision);\n    }\n    return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);\n  };\n\n  // doFormat()\n  var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {\n    var number;\n    var prefix;\n    var method;\n    var textTransform;\n    var value;\n\n    if (substring == '%%') {\n      return '%';\n    }\n\n    // parse flags\n    var leftJustify = false,\n      positivePrefix = '',\n      zeroPad = false,\n      prefixBaseX = false,\n      customPadChar = ' ';\n    var flagsl = flags.length;\n    for (var j = 0; flags && j < flagsl; j++) {\n      switch (flags.charAt(j)) {\n      case ' ':\n        positivePrefix = ' ';\n        break;\n      case '+':\n        positivePrefix = '+';\n        break;\n      case '-':\n        leftJustify = true;\n        break;\n      case \"'\":\n        customPadChar = flags.charAt(j + 1);\n        break;\n      case '0':\n        zeroPad = true;\n        break;\n      case '#':\n        prefixBaseX = true;\n        break;\n      }\n    }\n\n    // parameters may be null, undefined, empty-string or real valued\n    // we want to ignore null, undefined and empty-string values\n    if (!minWidth) {\n      minWidth = 0;\n    } else if (minWidth == '*') {\n      minWidth = +a[i++];\n    } else if (minWidth.charAt(0) == '*') {\n      minWidth = +a[minWidth.slice(1, -1)];\n    } else {\n      minWidth = +minWidth;\n    }\n\n    // Note: undocumented perl feature:\n    if (minWidth < 0) {\n      minWidth = -minWidth;\n      leftJustify = true;\n    }\n\n    if (!isFinite(minWidth)) {\n      throw new Error('sprintf: (minimum-)width must be finite');\n    }\n\n    if (!precision) {\n      precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;\n    } else if (precision == '*') {\n      precision = +a[i++];\n    } else if (precision.charAt(0) == '*') {\n      precision = +a[precision.slice(1, -1)];\n    } else {\n      precision = +precision;\n    }\n\n    // grab value using valueIndex if required?\n    value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\n\n    switch (type) {\n    case 's':\n      return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);\n    case 'c':\n      return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\n    case 'b':\n      return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n    case 'o':\n      return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n    case 'x':\n      return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n    case 'X':\n      return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\n    case 'u':\n      return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\n    case 'i':\n    case 'd':\n      number = +value || 0;\n      number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate\n      prefix = number < 0 ? '-' : positivePrefix;\n      value = prefix + pad(String(Math.abs(number)), precision, '0', false);\n      return justify(value, prefix, leftJustify, minWidth, zeroPad);\n    case 'e':\n    case 'E':\n    case 'f': // Should handle locales (as per setlocale)\n    case 'F':\n    case 'g':\n    case 'G':\n      number = +value;\n      prefix = number < 0 ? '-' : positivePrefix;\n      method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\n      textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\n      value = prefix + Math.abs(number)[method](precision);\n      return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\n    default:\n      return substring;\n    }\n  };\n\n  return format.replace(regex, doFormat);\n}\n\nreturn sprintf;\n});",
    "\n/*global define*/\ndefine('Core/GregorianDate',[],function() {\n    \"use strict\";\n\n    /**\n     * Represents a Gregorian date in a more precise format than the JavaScript Date object.\n     * In addition to submillisecond precision, this object can also represent leap seconds.\n     * @alias GregorianDate\n     * @constructor\n     *\n     * @see JulianDate#toGregorianDate\n     */\n    var GregorianDate = function(year, month, day, hour, minute, second, millisecond, isLeapSecond) {\n        /**\n         * Gets or sets the year as a whole number.\n         * @type {Number}\n         */\n        this.year = year;\n        /**\n         * Gets or sets the month as a whole number with range [1, 12].\n         * @type {Number}\n         */\n        this.month = month;\n        /**\n         * Gets or sets the day of the month as a whole number starting at 1.\n         * @type {Number}\n         */\n        this.day = day;\n        /**\n         * Gets or sets the hour as a whole number with range [0, 23].\n         * @type {Number}\n         */\n        this.hour = hour;\n        /**\n         * Gets or sets the minute of the hour as a whole number with range [0, 59].\n         * @type {Number}\n         */\n        this.minute = minute;\n        /**\n         * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n         * @type {Number}\n         */\n        this.second = second;\n        /**\n         * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).\n         * @type {Number}\n         */\n        this.millisecond = millisecond;\n        /**\n         * Gets or sets whether this time is during a leap second.\n         * @type {Boolean}\n         */\n        this.isLeapSecond = isLeapSecond;\n    };\n\n    return GregorianDate;\n});",
    "\n/*global define*/\ndefine('Core/isLeapYear',[\n        './DeveloperError'\n    ], function(\n        DeveloperError) {\n    \"use strict\";\n\n    /**\n     * Determines if a given date is a leap year.\n     *\n     * @exports isLeapYear\n     *\n     * @param {Number} year The year to be tested.\n     * @returns {Boolean} True if <code>year</code> is a leap year.\n     *\n     * @example\n     * var leapYear = Cesium.isLeapYear(2000); // true\n     */\n    function isLeapYear(year) {\n        //>>includeStart('debug', pragmas.debug);\n        if (year === null || isNaN(year)) {\n            throw new DeveloperError('year is required and must be a number.');\n        }\n        //>>includeEnd('debug');\n\n        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n    }\n\n    return isLeapYear;\n});\n",
    "\n/*global define*/\ndefine('Core/LeapSecond',[],function() {\n    \"use strict\";\n\n    /**\n     * Describes a single leap second, which is constructed from a {@link JulianDate} and a\n     * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.\n     * @alias LeapSecond\n     * @constructor\n     *\n     * @param {JulianDate} [date] A Julian date representing the time of the leap second.\n     * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.\n     */\n    var LeapSecond = function(date, offset) {\n        /**\n         * Gets or sets the date at which this leap second occurs.\n         * @type {JulianDate}\n         */\n        this.julianDate = date;\n\n        /**\n         * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time\n         * of this leap second.\n         * @type {Number}\n         */\n        this.offset = offset;\n    };\n\n    return LeapSecond;\n});",
    "\n/*global define*/\ndefine('Core/TimeConstants',[\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * Constants for time conversions like those done by {@link JulianDate}.\n     *\n     * @namespace\n     * @alias TimeConstants\n     *\n     * @see JulianDate\n     *\n     * @private\n     */\n    var TimeConstants = {\n        /**\n         * The number of seconds in one millisecond: <code>0.001</code>\n         * @type {Number}\n         * @constant\n         */\n        SECONDS_PER_MILLISECOND : 0.001,\n\n        /**\n         * The number of seconds in one minute: <code>60</code>.\n         * @type {Number}\n         * @constant\n         */\n        SECONDS_PER_MINUTE : 60.0,\n\n        /**\n         * The number of minutes in one hour: <code>60</code>.\n         * @type {Number}\n         * @constant\n         */\n        MINUTES_PER_HOUR : 60.0,\n\n        /**\n         * The number of hours in one day: <code>24</code>.\n         * @type {Number}\n         * @constant\n         */\n        HOURS_PER_DAY : 24.0,\n\n        /**\n         * The number of seconds in one hour: <code>3600</code>.\n         * @type {Number}\n         * @constant\n         */\n        SECONDS_PER_HOUR : 3600.0,\n\n        /**\n         * The number of minutes in one day: <code>1440</code>.\n         * @type {Number}\n         * @constant\n         */\n        MINUTES_PER_DAY : 1440.0,\n\n        /**\n         * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.\n         * @type {Number}\n         * @constant\n         */\n        SECONDS_PER_DAY : 86400.0,\n\n        /**\n         * The number of days in one Julian century: <code>36525</code>.\n         * @type {Number}\n         * @constant\n         */\n        DAYS_PER_JULIAN_CENTURY : 36525.0,\n\n        /**\n         * One trillionth of a second.\n         * @type {Number}\n         * @constant\n         */\n        PICOSECOND : 0.000000001,\n\n        /**\n         * The number of days to subtract from a Julian date to determine the\n         * modified Julian date, which gives the number of days since midnight\n         * on November 17, 1858.\n         * @type {Number}\n         * @constant\n         */\n        MODIFIED_JULIAN_DATE_DIFFERENCE : 2400000.5\n    };\n\n    return freezeObject(TimeConstants);\n});\n",
    "\n/*global define*/\ndefine('Core/TimeStandard',[\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * Provides the type of time standards which JulianDate can take as input.\n     *\n     * @namespace\n     * @alias TimeStandard\n     *\n     * @see JulianDate\n     */\n    var TimeStandard = {\n        /**\n         * Represents the coordinated Universal Time (UTC) time standard.\n         *\n         * UTC is related to TAI according to the relationship\n         * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap\n         * seconds which have been introduced as of the time in TAI.\n         *\n         */\n        UTC : 0,\n\n        /**\n         * Represents the International Atomic Time (TAI) time standard.\n         * TAI is the principal time standard to which the other time standards are related.\n         */\n        TAI : 1\n    };\n\n    return freezeObject(TimeStandard);\n});",
    "\n/*global define*/\ndefine('Core/JulianDate',[\n        '../ThirdParty/sprintf',\n        './binarySearch',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './GregorianDate',\n        './isLeapYear',\n        './LeapSecond',\n        './TimeConstants',\n        './TimeStandard'\n    ], function(\n        sprintf,\n        binarySearch,\n        defaultValue,\n        defined,\n        DeveloperError,\n        GregorianDate,\n        isLeapYear,\n        LeapSecond,\n        TimeConstants,\n        TimeStandard) {\n    \"use strict\";\n\n    var gregorianDateScratch = new GregorianDate();\n    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var daysInLeapFeburary = 29;\n\n    function compareLeapSecondDates(leapSecond, dateToFind) {\n        return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n    }\n\n    // we don't really need a leap second instance, anything with a julianDate property will do\n    var binarySearchScratchLeapSecond = new LeapSecond();\n\n    function convertUtcToTai(julianDate) {\n        //Even though julianDate is in UTC, we'll treat it as TAI and\n        //search the leap second table for it.\n        binarySearchScratchLeapSecond.julianDate = julianDate;\n        var leapSeconds = JulianDate.leapSeconds;\n        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n\n        if (index < 0) {\n            index = ~index;\n        }\n\n        if (index >= leapSeconds.length) {\n            index = leapSeconds.length - 1;\n        }\n\n        var offset = leapSeconds[index].offset;\n        if (index > 0) {\n            //Now we have the index of the closest leap second that comes on or after our UTC time.\n            //However, if the difference between the UTC date being converted and the TAI\n            //defined leap second is greater than the offset, we are off by one and need to use\n            //the previous leap second.\n            var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n            if (difference > offset) {\n                index--;\n                offset = leapSeconds[index].offset;\n            }\n        }\n\n        JulianDate.addSeconds(julianDate, offset, julianDate);\n    }\n\n    function convertTaiToUtc(julianDate, result) {\n        binarySearchScratchLeapSecond.julianDate = julianDate;\n        var leapSeconds = JulianDate.leapSeconds;\n        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n        if (index < 0) {\n            index = ~index;\n        }\n\n        //All times before our first leap second get the first offset.\n        if (index === 0) {\n            return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n        }\n\n        //All times after our leap second get the last offset.\n        if (index >= leapSeconds.length) {\n            return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);\n        }\n\n        //Compute the difference between the found leap second and the time we are converting.\n        var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);\n\n        if (difference === 0) {\n            //The date is in our leap second table.\n            return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);\n        }\n\n        if (difference <= 1.0) {\n            //The requested date is during the moment of a leap second, then we cannot convert to UTC\n            return undefined;\n        }\n\n        //The time is in between two leap seconds, index is the leap second after the date\n        //we're converting, so we subtract one to get the correct LeapSecond instance.\n        return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);\n    }\n\n    function setComponents(wholeDays, secondsOfDay, julianDate) {\n        var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;\n        wholeDays += extraDays;\n        secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n        if (secondsOfDay < 0) {\n            wholeDays--;\n            secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n        }\n\n        julianDate.dayNumber = wholeDays;\n        julianDate.secondsOfDay = secondsOfDay;\n        return julianDate;\n    }\n\n    function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {\n        // Algorithm from page 604 of the Explanatory Supplement to the\n        // Astronomical Almanac (Seidelmann 1992).\n\n        var a = ((month - 14) / 12) | 0;\n        var b = year + 4800 + a;\n        var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * (((b + 100) / 100) | 0)) / 4) | 0) + day - 32075;\n\n        // JulianDates are noon-based\n        hour = hour - 12;\n        if (hour < 0) {\n            hour += 24;\n        }\n\n        var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));\n\n        if (secondsOfDay >= 43200.0) {\n            dayNumber -= 1;\n        }\n\n        return [dayNumber, secondsOfDay];\n    }\n\n    //Regular expressions used for ISO8601 date parsing.\n    //YYYY\n    var matchCalendarYear = /^(\\d{4})$/;\n    //YYYY-MM (YYYYMM is invalid)\n    var matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n    //YYYY-DDD or YYYYDDD\n    var matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n    //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\n    var matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n    //YYYY-MM-DD or YYYYMMDD\n    var matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n    // Match utc offset\n    var utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n    // Match hours HH or HH.xxxxx\n    var matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n    // Match hours/minutes HH:MM HHMM.xxxxx\n    var matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n    // Match hours/minutes HH:MM:SS HHMMSS.xxxxx\n    var matchHoursMinutesSeconds = /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\n    var iso8601ErrorMessage = 'Invalid ISO 8601 date.';\n\n    /**\n     * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n     * For increased precision, this class stores the whole number part of the date and the seconds\n     * part of the date in separate components.  In order to be safe for arithmetic and represent\n     * leap seconds, the date is always stored in the International Atomic Time standard\n     * {@link TimeStandard.TAI}.\n     * @alias JulianDate\n     * @constructor\n     *\n     * @param {Number} julianDayNumber The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n     * @param {Number} secondsOfDay The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n     * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n     */\n    var JulianDate = function(julianDayNumber, secondsOfDay, timeStandard) {\n        /**\n         * Gets or sets the number of whole days.\n         * @type {Number}\n         */\n        this.dayNumber = undefined;\n\n        /**\n         * Gets or sets the number of seconds into the current day.\n         * @type {Number}\n         */\n        this.secondsOfDay = undefined;\n\n        julianDayNumber = defaultValue(julianDayNumber, 0.0);\n        secondsOfDay = defaultValue(secondsOfDay, 0.0);\n        timeStandard = defaultValue(timeStandard, TimeStandard.UTC);\n\n        //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n        var wholeDays = julianDayNumber | 0;\n        secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n\n        setComponents(wholeDays, secondsOfDay, this);\n\n        if (timeStandard === TimeStandard.UTC) {\n            convertUtcToTai(this);\n        }\n    };\n\n    /**\n     * Creates a new instance from a JavaScript Date.\n     *\n     * @param {Date} date A JavaScript Date.\n     * @param {JulianDate} [result] An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n     *\n     * @exception {DeveloperError} date must be a valid JavaScript Date.\n     */\n    JulianDate.fromDate = function(date, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!(date instanceof Date) || isNaN(date.getTime())) {\n            throw new DeveloperError('date must be a valid JavaScript Date.');\n        }\n        //>>includeEnd('debug');\n\n        var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());\n        if (!defined(result)) {\n            return new JulianDate(components[0], components[1], TimeStandard.UTC);\n        }\n        setComponents(components[0], components[1], result);\n        convertUtcToTai(result);\n        return result;\n    };\n\n    /**\n     * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n     * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n     * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n     *\n     * @param {String} iso8601String An ISO 8601 date.\n     * @param {JulianDate} [result] An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n     *\n     * @exception {DeveloperError} Invalid ISO 8601 date.\n     */\n    JulianDate.fromIso8601 = function(iso8601String, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof iso8601String !== 'string') {\n            throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug');\n\n        //Comma and decimal point both indicate a fractional number according to ISO 8601,\n        //start out by blanket replacing , with . which is the only valid such symbol in JS.\n        iso8601String = iso8601String.replace(',', '.');\n\n        //Split the string into its date and time components, denoted by a mandatory T\n        var tokens = iso8601String.split('T');\n        var year;\n        var month = 1;\n        var day = 1;\n        var hour = 0;\n        var minute = 0;\n        var second = 0;\n        var millisecond = 0;\n\n        //Lacking a time is okay, but a missing date is illegal.\n        var date = tokens[0];\n        var time = tokens[1];\n        var tmp;\n        var inLeapYear;\n        if (!defined(date)) {\n            throw new DeveloperError(iso8601ErrorMessage);\n        }\n\n        var dashCount;\n\n        //First match the date against possible regular expressions.\n        tokens = date.match(matchCalendarDate);\n        if (tokens !== null) {\n            dashCount = date.split('-').length - 1;\n            if (dashCount > 0 && dashCount !== 2) {\n                throw new DeveloperError(iso8601ErrorMessage);\n            }\n            year = +tokens[1];\n            month = +tokens[2];\n            day = +tokens[3];\n        } else {\n            tokens = date.match(matchCalendarMonth);\n            if (tokens !== null) {\n                year = +tokens[1];\n                month = +tokens[2];\n            } else {\n                tokens = date.match(matchCalendarYear);\n                if (tokens !== null) {\n                    year = +tokens[1];\n                } else {\n                    //Not a year/month/day so it must be an ordinal date.\n                    var dayOfYear;\n                    tokens = date.match(matchOrdinalDate);\n                    if (tokens !== null) {\n\n                        year = +tokens[1];\n                        dayOfYear = +tokens[2];\n                        inLeapYear = isLeapYear(year);\n\n                        //This validation is only applicable for this format.\n                        if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {\n                            throw new DeveloperError(iso8601ErrorMessage);\n                        }\n                    } else {\n                        tokens = date.match(matchWeekDate);\n                        if (tokens !== null) {\n                            //ISO week date to ordinal date from\n                            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n                            year = +tokens[1];\n                            var weekNumber = +tokens[2];\n                            var dayOfWeek = +tokens[3] || 0;\n\n                            dashCount = date.split('-').length - 1;\n                            if (dashCount > 0 &&\n                               ((!defined(tokens[3]) && dashCount !== 1) ||\n                               (defined(tokens[3]) && dashCount !== 2))) {\n                                throw new DeveloperError(iso8601ErrorMessage);\n                            }\n\n                            var january4 = new Date(Date.UTC(year, 0, 4));\n                            dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;\n                        } else {\n                            //None of our regular expressions succeeded in parsing the date properly.\n                            throw new DeveloperError(iso8601ErrorMessage);\n                        }\n                    }\n                    //Split an ordinal date into month/day.\n                    tmp = new Date(Date.UTC(year, 0, 1));\n                    tmp.setUTCDate(dayOfYear);\n                    month = tmp.getUTCMonth() + 1;\n                    day = tmp.getUTCDate();\n                }\n            }\n        }\n\n        //Now that we have all of the date components, validate them to make sure nothing is out of range.\n        inLeapYear = isLeapYear(year);\n        if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {\n            throw new DeveloperError(iso8601ErrorMessage);\n        }\n\n        //Not move onto the time string, which is much simpler.\n        var offsetIndex;\n        if (defined(time)) {\n            tokens = time.match(matchHoursMinutesSeconds);\n            if (tokens !== null) {\n                dashCount = time.split(':').length - 1;\n                if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n                    throw new DeveloperError(iso8601ErrorMessage);\n                }\n\n                hour = +tokens[1];\n                minute = +tokens[2];\n                second = +tokens[3];\n                millisecond = +(tokens[4] || 0) * 1000.0;\n                offsetIndex = 5;\n            } else {\n                tokens = time.match(matchHoursMinutes);\n                if (tokens !== null) {\n                    dashCount = time.split(':').length - 1;\n                    if (dashCount > 0 && dashCount !== 1) {\n                        throw new DeveloperError(iso8601ErrorMessage);\n                    }\n\n                    hour = +tokens[1];\n                    minute = +tokens[2];\n                    second = +(tokens[3] || 0) * 60.0;\n                    offsetIndex = 4;\n                } else {\n                    tokens = time.match(matchHours);\n                    if (tokens !== null) {\n                        hour = +tokens[1];\n                        minute = +(tokens[2] || 0) * 60.0;\n                        offsetIndex = 3;\n                    } else {\n                        throw new DeveloperError(iso8601ErrorMessage);\n                    }\n                }\n            }\n\n            //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n            if (minute >= 60 || second >= 61 || hour > 24 || (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))) {\n                throw new DeveloperError(iso8601ErrorMessage);\n            }\n\n            //Check the UTC offset value, if no value exists, use local time\n            //a Z indicates UTC, + or - are offsets.\n            var offset = tokens[offsetIndex];\n            var offsetHours = +(tokens[offsetIndex + 1]);\n            var offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n            switch (offset) {\n            case '+':\n                hour = hour - offsetHours;\n                minute = minute - offsetMinutes;\n                break;\n            case '-':\n                hour = hour + offsetHours;\n                minute = minute + offsetMinutes;\n                break;\n            case 'Z':\n                break;\n            default:\n                minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();\n                break;\n            }\n        } else {\n            //If no time is specified, it is considered the beginning of the day, local time.\n            minute = minute + new Date(year, month - 1, day).getTimezoneOffset();\n        }\n\n        //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n        //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n        //Then we add it back in after converting to TAI.\n        var isLeapSecond = second === 60;\n        if (isLeapSecond) {\n            second--;\n        }\n\n        //Even if we successfully parsed the string into its components, after applying UTC offset or\n        //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n        //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n        while (minute >= 60) {\n            minute -= 60;\n            hour++;\n        }\n\n        while (hour >= 24) {\n            hour -= 24;\n            day++;\n        }\n\n        tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];\n        while (day > tmp) {\n            day -= tmp;\n            month++;\n\n            if (month > 12) {\n                month -= 12;\n                year++;\n            }\n\n            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];\n        }\n\n        //If UTC offset is at the beginning/end of the day, minutes can be negative.\n        while (minute < 0) {\n            minute += 60;\n            hour--;\n        }\n\n        while (hour < 0) {\n            hour += 24;\n            day--;\n        }\n\n        while (day < 1) {\n            month--;\n            if (month < 1) {\n                month += 12;\n                year--;\n            }\n\n            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];\n            day += tmp;\n        }\n\n        //Now create the JulianDate components from the Gregorian date and actually create our instance.\n        var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);\n\n        if (!defined(result)) {\n            result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n        } else {\n            setComponents(components[0], components[1], result);\n            convertUtcToTai(result);\n        }\n\n        //If we were on a leap second, add it back.\n        if (isLeapSecond) {\n            JulianDate.addSeconds(result, 1, result);\n        }\n\n        return result;\n    };\n\n    /**\n     * Creates a new instance that represents the current system time.\n     * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n     *\n     * @param {JulianDate} [result] An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n     */\n    JulianDate.now = function(result) {\n        return JulianDate.fromDate(new Date(), result);\n    };\n\n    var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n    /**\n     * Creates a {@link GregorianDate} from the provided instance.\n     *\n     * @param {JulianDate} julianDate The date to be converted.\n     * @param {GregorianDate} [result] An existing instance to use for the result.\n     * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n     */\n    JulianDate.toGregorianDate = function(julianDate, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        //>>includeEnd('debug');\n\n        var isLeapSecond = false;\n        var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n        if (!defined(thisUtc)) {\n            //Conversion to UTC will fail if we are during a leap second.\n            //If that's the case, subtract a second and convert again.\n            //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n            JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n            thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n            isLeapSecond = true;\n        }\n\n        var julianDayNumber = thisUtc.dayNumber;\n        var secondsOfDay = thisUtc.secondsOfDay;\n\n        if (secondsOfDay >= 43200.0) {\n            julianDayNumber += 1;\n        }\n\n        // Algorithm from page 604 of the Explanatory Supplement to the\n        // Astronomical Almanac (Seidelmann 1992).\n        var L = (julianDayNumber + 68569) | 0;\n        var N = (4 * L / 146097) | 0;\n        L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n        var I = ((4000 * (L + 1)) / 1461001) | 0;\n        L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n        var J = ((80 * L) / 2447) | 0;\n        var day = (L - (((2447 * J) / 80) | 0)) | 0;\n        L = (J / 11) | 0;\n        var month = (J + 2 - 12 * L) | 0;\n        var year = (100 * (N - 49) + I + L) | 0;\n\n        var hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;\n        var remainingSeconds = secondsOfDay - (hour * TimeConstants.SECONDS_PER_HOUR);\n        var minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;\n        remainingSeconds = remainingSeconds - (minute * TimeConstants.SECONDS_PER_MINUTE);\n        var second = remainingSeconds | 0;\n        var millisecond = ((remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND);\n\n        // JulianDates are noon-based\n        hour += 12;\n        if (hour > 23) {\n            hour -= 24;\n        }\n\n        //If we were on a leap second, add it back.\n        if (isLeapSecond) {\n            second += 1;\n        }\n\n        if (!defined(result)) {\n            return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);\n        }\n\n        result.year = year;\n        result.month = month;\n        result.day = day;\n        result.hour = hour;\n        result.minute = minute;\n        result.second = second;\n        result.millisecond = millisecond;\n        result.isLeapSecond = isLeapSecond;\n        return result;\n    };\n\n    /**\n     * Creates a JavaScript Date from the provided instance.\n     * Since JavaScript dates are only accurate to the nearest millisecond and\n     * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n     * If the provided JulianDate is during a leap second, the previous second is used.\n     *\n     * @param {JulianDate} julianDate The date to be converted.\n     * @returns {Date} A new instance representing the provided date.\n     */\n    JulianDate.toDate = function(julianDate) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        //>>includeEnd('debug');\n\n        var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n        var second = gDate.second;\n        if (gDate.isLeapSecond) {\n            second -= 1;\n        }\n        return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));\n    };\n\n    /**\n     * Creates an ISO8601 representation of the provided date.\n     *\n     * @param {JulianDate} julianDate The date to be converted.\n     * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n     * @returns {String} The ISO8601 representation of the provided date.\n     */\n    JulianDate.toIso8601 = function(julianDate, precision) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        //>>includeEnd('debug');\n\n        var gDate = JulianDate.toGregorianDate(julianDate, gDate);\n        var millisecondStr;\n\n        if (!defined(precision) && gDate.millisecond !== 0) {\n            //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n            millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');\n            return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);\n        }\n\n        //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n        if (!defined(precision) || precision === 0) {\n            return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02dZ\", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);\n        }\n\n        //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n        millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);\n        return sprintf(\"%04d-%02d-%02dT%02d:%02d:%02d.%sZ\", gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);\n    };\n\n    /**\n     * Duplicates a JulianDate instance.\n     *\n     * @param {JulianDate} julianDate The date to duplicate.\n     * @param {JulianDate} [result] An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n     */\n    JulianDate.clone = function(julianDate, result) {\n        if (!defined(julianDate)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);\n        }\n        result.dayNumber = julianDate.dayNumber;\n        result.secondsOfDay = julianDate.secondsOfDay;\n        return result;\n    };\n\n    /**\n     * Compares two instances.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n     */\n    JulianDate.compare = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        //>>includeEnd('debug');\n\n        var julianDayNumberDifference = left.dayNumber - right.dayNumber;\n        if (julianDayNumberDifference !== 0) {\n            return julianDayNumberDifference;\n        }\n        return left.secondsOfDay - right.secondsOfDay;\n    };\n\n    /**\n     * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} [left] The first instance.\n     * @param {JulianDate} [right] The second instance.\n     * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n     */\n    JulianDate.equals = function(left, right) {\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                left.dayNumber === right.dayNumber &&\n                left.secondsOfDay === right.secondsOfDay);\n    };\n\n    /**\n     * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n     * each other.  That is, in order for the dates to be considered equal (and for\n     * this function to return <code>true</code>), the absolute value of the difference between them, in\n     * seconds, must be less than <code>epsilon</code>.\n     *\n     * @param {JulianDate} [left] The first instance.\n     * @param {JulianDate} [right] The second instance.\n     * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n     * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n     */\n    JulianDate.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(epsilon)) {\n            throw new DeveloperError('epsilon is required.');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n               (defined(left) &&\n                defined(right) &&\n                Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon);\n    };\n\n    /**\n     * Computes the total number of whole and fractional days represented by the provided instance.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @returns {Number} The Julian date as single floating point number.\n     */\n    JulianDate.totalDays = function(julianDate) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        //>>includeEnd('debug');\n        return julianDate.dayNumber + (julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY);\n    };\n\n    /**\n     * Computes the difference in seconds between the provided instance.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n     */\n    JulianDate.secondsDifference = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        //>>includeEnd('debug');\n\n        var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n        return (dayDifference + (left.secondsOfDay - right.secondsOfDay));\n    };\n\n    /**\n     * Computes the difference in days between the provided instance.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n     */\n    JulianDate.daysDifference = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required.');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required.');\n        }\n        //>>includeEnd('debug');\n\n        var dayDifference = (left.dayNumber - right.dayNumber);\n        var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n        return dayDifference + secondDifference;\n    };\n\n    /**\n     * Computes the number of seconds the provided instance is ahead of UTC.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @returns {Number} The number of seconds the provided instance is ahead of UTC\n     */\n    JulianDate.computeTaiMinusUtc = function(julianDate) {\n        binarySearchScratchLeapSecond.julianDate = julianDate;\n        var leapSeconds = JulianDate.leapSeconds;\n        var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);\n        if (index < 0) {\n            index = ~index;\n            --index;\n            if (index < 0) {\n                index = 0;\n            }\n        }\n        return leapSeconds[index].offset;\n    };\n\n    /**\n     * Adds the provided number of seconds to the provided date instance.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @param {Number} seconds The number of seconds to add or subtract.\n     * @param {JulianDate} result An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter.\n     */\n    JulianDate.addSeconds = function(julianDate, seconds, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        if (!defined(seconds)) {\n            throw new DeveloperError('seconds is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);\n    };\n\n    /**\n     * Adds the provided number of minutes to the provided date instance.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @param {Number} minutes The number of minutes to add or subtract.\n     * @param {JulianDate} result An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter.\n     */\n    JulianDate.addMinutes = function(julianDate, minutes, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        if (!defined(minutes)) {\n            throw new DeveloperError('minutes is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var newSecondsOfDay = julianDate.secondsOfDay + (minutes * TimeConstants.SECONDS_PER_MINUTE);\n        return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n    };\n\n    /**\n     * Adds the provided number of hours to the provided date instance.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @param {Number} hours The number of hours to add or subtract.\n     * @param {JulianDate} result An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter.\n     */\n    JulianDate.addHours = function(julianDate, hours, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        if (!defined(hours)) {\n            throw new DeveloperError('hours is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var newSecondsOfDay = julianDate.secondsOfDay + (hours * TimeConstants.SECONDS_PER_HOUR);\n        return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n    };\n\n    /**\n     * Adds the provided number of days to the provided date instance.\n     *\n     * @param {JulianDate} julianDate The date.\n     * @param {Number} days The number of days to add or subtract.\n     * @param {JulianDate} result An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter.\n     */\n    JulianDate.addDays = function(julianDate, days, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(julianDate)) {\n            throw new DeveloperError('julianDate is required.');\n        }\n        if (!defined(days)) {\n            throw new DeveloperError('days is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required.');\n        }\n        //>>includeEnd('debug');\n\n        var newJulianDayNumber = julianDate.dayNumber + days;\n        return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n    };\n\n    /**\n     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n     */\n    JulianDate.lessThan = function(left, right) {\n        return JulianDate.compare(left, right) < 0;\n    };\n\n    /**\n     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n     */\n    JulianDate.lessThanOrEquals = function(left, right) {\n        return JulianDate.compare(left, right) <= 0;\n    };\n\n    /**\n     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n     */\n    JulianDate.greaterThan = function(left, right) {\n        return JulianDate.compare(left, right) > 0;\n    };\n\n    /**\n     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} left The first instance.\n     * @param {JulianDate} right The second instance.\n     * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n     */\n    JulianDate.greaterThanOrEquals = function(left, right) {\n        return JulianDate.compare(left, right) >= 0;\n    };\n\n    /**\n     * Duplicates this instance.\n     *\n     * @param {JulianDate} [result] An existing instance to use for the result.\n     * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n     */\n    JulianDate.prototype.clone = function(result) {\n        return JulianDate.clone(this, result);\n    };\n\n    /**\n     * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {JulianDate} [right] The second instance.\n     * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n     */\n    JulianDate.prototype.equals = function(right) {\n        return JulianDate.equals(this, right);\n    };\n\n    /**\n     * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n     * each other.  That is, in order for the dates to be considered equal (and for\n     * this function to return <code>true</code>), the absolute value of the difference between them, in\n     * seconds, must be less than <code>epsilon</code>.\n     *\n     * @param {JulianDate} [right] The second instance.\n     * @param {Number} epsilon The maximum number of seconds that should separate the two instances.\n     * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n     */\n    JulianDate.prototype.equalsEpsilon = function(right, epsilon) {\n        return JulianDate.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Creates a string representing this date in ISO8601 format.\n     *\n     * @returns {String} A string representing this date in ISO8601 format.\n     */\n    JulianDate.prototype.toString = function() {\n        return JulianDate.toIso8601(this);\n    };\n\n    /**\n     * Gets or sets the list of leap seconds used throughout Cesium.\n     * @memberof JulianDate\n     * @type {LeapSecond[]}\n     */\n    JulianDate.leapSeconds = [\n                               new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n                               new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36)  // July 1, 2015 00:00:00 UTC\n                             ];\n\n    return JulianDate;\n});\n",
    "\n/*global define*/\ndefine('Core/clone',[\n        './defaultValue'\n    ], function(\n        defaultValue) {\n    \"use strict\";\n\n    /**\n     * Clones an object, returning a new object containing the same properties.\n     *\n     * @exports clone\n     *\n     * @param {Object} object The object to clone.\n     * @param {Boolean} [deep=false] If true, all properties will be deep cloned recursively.\n     * @returns {Object} The cloned object.\n     */\n    var clone = function(object, deep) {\n        if (object === null || typeof object !== 'object') {\n            return object;\n        }\n\n        deep = defaultValue(deep, false);\n\n        var result = new object.constructor();\n        for ( var propertyName in object) {\n            if (object.hasOwnProperty(propertyName)) {\n                var value = object[propertyName];\n                if (deep) {\n                    value = clone(value, deep);\n                }\n                result[propertyName] = value;\n            }\n        }\n\n        return result;\n    };\n\n    return clone;\n});\n",
    "\n/*global define*/\ndefine('Core/parseResponseHeaders',[], function() {\n    \"use strict\";\n\n    /**\n     * Parses the result of XMLHttpRequest's getAllResponseHeaders() method into\n     * a dictionary.\n     *\n     * @exports parseResponseHeaders\n     *\n     * @param {String} headerString The header string returned by getAllResponseHeaders().  The format is\n     *                 described here: http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method\n     * @returns {Object} A dictionary of key/value pairs, where each key is the name of a header and the corresponding value\n     *                   is that header's value.\n     * \n     * @private\n     */\n    var parseResponseHeaders = function(headerString) {\n        var headers = {};\n\n        if (!headerString) {\n          return headers;\n        }\n\n        var headerPairs = headerString.split('\\u000d\\u000a');\n\n        for (var i = 0; i < headerPairs.length; ++i) {\n          var headerPair = headerPairs[i];\n          // Can't use split() here because it does the wrong thing\n          // if the header value has the string \": \" in it.\n          var index = headerPair.indexOf('\\u003a\\u0020');\n          if (index > 0) {\n            var key = headerPair.substring(0, index);\n            var val = headerPair.substring(index + 2);\n            headers[key] = val;\n          }\n        }\n\n        return headers;\n    };\n\n    return parseResponseHeaders;\n});\n",
    "\n/*global define*/\ndefine('Core/RequestErrorEvent',[\n        './defined',\n        './parseResponseHeaders'\n    ], function(\n        defined,\n        parseResponseHeaders) {\n    \"use strict\";\n\n    /**\n     * An event that is raised when a request encounters an error.\n     *\n     * @constructor\n     * @alias RequestErrorEvent\n     *\n     * @param {Number} [statusCode] The HTTP error status code, such as 404.\n     * @param {Object} [response] The response included along with the error.\n     * @param {String|Object} [responseHeaders] The response headers, represented either as an object literal or as a\n     *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.\n     */\n    var RequestErrorEvent = function RequestErrorEvent(statusCode, response, responseHeaders) {\n        /**\n         * The HTTP error status code, such as 404.  If the error does not have a particular\n         * HTTP code, this property will be undefined.\n         *\n         * @type {Number}\n         */\n        this.statusCode = statusCode;\n\n        /**\n         * The response included along with the error.  If the error does not include a response,\n         * this property will be undefined.\n         *\n         * @type {Object}\n         */\n        this.response = response;\n\n        /**\n         * The headers included in the response, represented as an object literal of key/value pairs.\n         * If the error does not include any headers, this property will be undefined.\n         *\n         * @type {Object}\n         */\n        this.responseHeaders = responseHeaders;\n\n        if (typeof this.responseHeaders === 'string') {\n            this.responseHeaders = parseResponseHeaders(this.responseHeaders);\n        }\n    };\n\n    /**\n     * Creates a string representing this RequestErrorEvent.\n     * @memberof RequestErrorEvent\n     *\n     * @returns {String} A string representing the provided RequestErrorEvent.\n     */\n    RequestErrorEvent.prototype.toString = function() {\n        var str = 'Request has failed.';\n        if (defined(this.statusCode)) {\n            str += ' Status Code: ' + this.statusCode;\n        }\n        return str;\n    };\n\n    return RequestErrorEvent;\n});",
    "\n/*global define*/\ndefine('Core/loadWithXhr',[\n        '../ThirdParty/when',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './RequestErrorEvent',\n        './RuntimeError'\n    ], function(\n        when,\n        defaultValue,\n        defined,\n        DeveloperError,\n        RequestErrorEvent,\n        RuntimeError) {\n    \"use strict\";\n\n    /**\n     * Asynchronously loads the given URL.  Returns a promise that will resolve to\n     * the result once loaded, or reject if the URL failed to load.  The data is loaded\n     * using XMLHttpRequest, which means that in order to make requests to another origin,\n     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n     *\n     * @exports loadWithXhr\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {String|Promise.<String>} options.url The URL of the data, or a promise for the URL.\n     * @param {String} [options.responseType] The type of response.  This controls the type of item returned.\n     * @param {String} [options.method='GET'] The HTTP method to use.\n     * @param {String} [options.data] The data to send with the request, if any.\n     * @param {Object} [options.headers] HTTP headers to send with the request, if any.\n     * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.\n     * @returns {Promise.<Object>} a promise that will resolve to the requested data when loaded.\n     *\n     * @see loadArrayBuffer\n     * @see loadBlob\n     * @see loadJson\n     * @see loadText\n     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n     *\n     * @example\n     * // Load a single URL asynchronously. In real code, you should use loadBlob instead.\n     * Cesium.loadWithXhr({\n     *     url : 'some/url',\n     *     responseType : 'blob'\n     * }).then(function(blob) {\n     *     // use the data\n     * }).otherwise(function(error) {\n     *     // an error occurred\n     * });\n     */\n    var loadWithXhr = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(options.url)) {\n            throw new DeveloperError('options.url is required.');\n        }\n        //>>includeEnd('debug');\n\n        var responseType = options.responseType;\n        var method = defaultValue(options.method, 'GET');\n        var data = options.data;\n        var headers = options.headers;\n        var overrideMimeType = options.overrideMimeType;\n\n        return when(options.url, function(url) {\n            var deferred = when.defer();\n\n            loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType);\n\n            return deferred.promise;\n        });\n    };\n\n    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\n    function decodeDataUriText(isBase64, data) {\n        var result = decodeURIComponent(data);\n        if (isBase64) {\n            return atob(result);\n        }\n        return result;\n    }\n\n    function decodeDataUriArrayBuffer(isBase64, data) {\n        var byteString = decodeDataUriText(isBase64, data);\n        var buffer = new ArrayBuffer(byteString.length);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < byteString.length; i++) {\n            view[i] = byteString.charCodeAt(i);\n        }\n        return buffer;\n    }\n\n    function decodeDataUri(dataUriRegexResult, responseType) {\n        responseType = defaultValue(responseType, '');\n        var mimeType = dataUriRegexResult[1];\n        var isBase64 = !!dataUriRegexResult[2];\n        var data = dataUriRegexResult[3];\n\n        switch (responseType) {\n        case '':\n        case 'text':\n            return decodeDataUriText(isBase64, data);\n        case 'arraybuffer':\n            return decodeDataUriArrayBuffer(isBase64, data);\n        case 'blob':\n            var buffer = decodeDataUriArrayBuffer(isBase64, data);\n            return new Blob([buffer], {\n                type : mimeType\n            });\n        case 'document':\n            var parser = new DOMParser();\n            return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);\n        case 'json':\n            return JSON.parse(decodeDataUriText(isBase64, data));\n        default:\n            throw new DeveloperError('Unhandled responseType: ' + responseType);\n        }\n    }\n\n    // This is broken out into a separate function so that it can be mocked for testing purposes.\n    loadWithXhr.load = function(url, responseType, method, data, headers, deferred, overrideMimeType) {\n        var dataUriRegexResult = dataUriRegex.exec(url);\n        if (dataUriRegexResult !== null) {\n            deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));\n            return;\n        }\n\n        var xhr = new XMLHttpRequest();\n\n        if (defined(overrideMimeType) && defined(xhr.overrideMimeType)) {\n            xhr.overrideMimeType(overrideMimeType);\n        }\n\n        xhr.open(method, url, true);\n\n        if (defined(headers)) {\n            for ( var key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        }\n\n        if (defined(responseType)) {\n            xhr.responseType = responseType;\n        }\n\n        xhr.onload = function() {\n            if (xhr.status === 200) {\n                if (defined(xhr.response)) {\n                    deferred.resolve(xhr.response);\n                } else {\n                    // busted old browsers.\n                    if (defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {\n                        deferred.resolve(xhr.responseXML);\n                    } else if (defined(xhr.responseText)) {\n                        deferred.resolve(xhr.responseText);\n                    } else {\n                        deferred.reject(new RuntimeError('unknown XMLHttpRequest response type.'));\n                    }\n                }\n            } else {\n                deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));\n            }\n        };\n\n        xhr.onerror = function(e) {\n            deferred.reject(new RequestErrorEvent());\n        };\n\n        xhr.send(data);\n    };\n\n    loadWithXhr.defaultLoad = loadWithXhr.load;\n\n    return loadWithXhr;\n});\n",
    "\n/*global define*/\ndefine('Core/loadText',[\n        './loadWithXhr'\n    ], function(\n        loadWithXhr) {\n    \"use strict\";\n\n    /**\n     * Asynchronously loads the given URL as text.  Returns a promise that will resolve to\n     * a String once loaded, or reject if the URL failed to load.  The data is loaded\n     * using XMLHttpRequest, which means that in order to make requests to another origin,\n     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.\n     *\n     * @exports loadText\n     *\n     * @param {String|Promise.<String>} url The URL to request, or a promise for the URL.\n     * @param {Object} [headers] HTTP headers to send with the request.\n     * @returns {Promise.<String>} a promise that will resolve to the requested data when loaded.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}\n     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n     *\n     * @example\n     * // load text from a URL, setting a custom header\n     * Cesium.loadText('http://someUrl.com/someJson.txt', {\n     *   'X-Custom-Header' : 'some value'\n     * }).then(function(text) {\n     *     // Do something with the text\n     * }).otherwise(function(error) {\n     *     // an error occurred\n     * });\n     */\n    var loadText = function(url, headers) {\n        return loadWithXhr({\n            url : url,\n            headers : headers\n        });\n    };\n\n    return loadText;\n});\n",
    "\n/*global define*/\ndefine('Core/loadJson',[\n        './clone',\n        './defined',\n        './DeveloperError',\n        './loadText'\n    ], function(\n        clone,\n        defined,\n        DeveloperError,\n        loadText) {\n    \"use strict\";\n\n    var defaultHeaders = {\n        Accept : 'application/json,*/*;q=0.01'\n    };\n\n    // note: &#42;&#47;&#42; below is */* but that ends the comment block early\n    /**\n     * Asynchronously loads the given URL as JSON.  Returns a promise that will resolve to\n     * a JSON object once loaded, or reject if the URL failed to load.  The data is loaded\n     * using XMLHttpRequest, which means that in order to make requests to another origin,\n     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function\n     * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not\n     * already specified.\n     *\n     * @exports loadJson\n     *\n     * @param {String|Promise.<String>} url The URL to request, or a promise for the URL.\n     * @param {Object} [headers] HTTP headers to send with the request.\n     * 'Accept: application/json,&#42;&#47;&#42;;q=0.01' is added to the request headers automatically\n     * if not specified.\n     * @returns {Promise.<Object>} a promise that will resolve to the requested data when loaded.\n     *\n     * @see loadText\n     * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n     * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}\n     *\n     * @example\n     * Cesium.loadJson('http://someUrl.com/someJson.txt').then(function(jsonData) {\n     *     // Do something with the JSON object\n     * }).otherwise(function(error) {\n     *     // an error occurred\n     * });\n     */\n    var loadJson = function loadJson(url, headers) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(url)) {\n            throw new DeveloperError('url is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(headers)) {\n            headers = defaultHeaders;\n        } else if (!defined(headers.Accept)) {\n            // clone before adding the Accept header\n            headers = clone(headers);\n            headers.Accept = defaultHeaders.Accept;\n        }\n\n        return loadText(url, headers).then(function(value) {\n            return JSON.parse(value);\n        });\n    };\n\n    return loadJson;\n});\n",
    "\n/*global define*/\ndefine('Core/EarthOrientationParameters',[\n        '../ThirdParty/when',\n        './binarySearch',\n        './defaultValue',\n        './defined',\n        './EarthOrientationParametersSample',\n        './freezeObject',\n        './JulianDate',\n        './LeapSecond',\n        './loadJson',\n        './RuntimeError',\n        './TimeConstants',\n        './TimeStandard'\n    ], function(\n        when,\n        binarySearch,\n        defaultValue,\n        defined,\n        EarthOrientationParametersSample,\n        freezeObject,\n        JulianDate,\n        LeapSecond,\n        loadJson,\n        RuntimeError,\n        TimeConstants,\n        TimeStandard) {\n    \"use strict\";\n\n    /**\n     * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n     * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n     * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n     * Reference Frame (ITRF).\n     *\n     * @alias EarthOrientationParameters\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {String} [options.url] The URL from which to obtain EOP data.  If neither this\n     *                 parameter nor options.data is specified, all EOP values are assumed\n     *                 to be 0.0.  If options.data is specified, this parameter is\n     *                 ignored.\n     * @param {Object} [options.data] The actual EOP data.  If neither this\n     *                 parameter nor options.data is specified, all EOP values are assumed\n     *                 to be 0.0.\n     * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n     *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n     *                  should be added to {@link JulianDate.leapSeconds}.  False if\n     *                  new leap seconds should be handled correctly in the context\n     *                  of the EOP data but otherwise ignored.\n     *\n     * @example\n     * // An example EOP data file, EOP.json:\n     * {\n     *   \"columnNames\" : [\"dateIso8601\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n     *   \"samples\" : [\n     *      \"2011-07-01T00:00:00Z\",2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n     *      \"2011-07-02T00:00:00Z\",2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n     *      \"2011-07-03T00:00:00Z\",2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n     *   ]\n     * }\n     *\n     * @example\n     * // Loading the EOP data\n     * var eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });\n     * Cesium.Transforms.earthOrientationParameters = eop;\n     *\n     * @private\n     */\n    var EarthOrientationParameters = function EarthOrientationParameters(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._dates = undefined;\n        this._samples = undefined;\n\n        this._dateColumn = -1;\n        this._xPoleWanderRadiansColumn = -1;\n        this._yPoleWanderRadiansColumn = -1;\n        this._ut1MinusUtcSecondsColumn = -1;\n        this._xCelestialPoleOffsetRadiansColumn = -1;\n        this._yCelestialPoleOffsetRadiansColumn = -1;\n        this._taiMinusUtcSecondsColumn = -1;\n\n        this._columnCount = 0;\n        this._lastIndex = -1;\n\n        this._downloadPromise = undefined;\n        this._dataError = undefined;\n\n        this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n\n        if (defined(options.data)) {\n            // Use supplied EOP data.\n            onDataReady(this, options.data);\n        } else if (defined(options.url)) {\n            // Download EOP data.\n            var that = this;\n            this._downloadPromise = when(loadJson(options.url), function(eopData) {\n                onDataReady(that, eopData);\n            }, function() {\n                that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';\n            });\n        } else {\n            // Use all zeros for EOP data.\n            onDataReady(this, {\n                'columnNames' : ['dateIso8601', 'modifiedJulianDateUtc', 'xPoleWanderRadians', 'yPoleWanderRadians', 'ut1MinusUtcSeconds', 'lengthOfDayCorrectionSeconds', 'xCelestialPoleOffsetRadians', 'yCelestialPoleOffsetRadians', 'taiMinusUtcSeconds'],\n                'samples' : []\n            });\n        }\n    };\n\n    /**\n     * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n     */\n    EarthOrientationParameters.NONE = freezeObject({\n            getPromiseToLoad : function() {\n                return when();\n            },\n            compute : function(date, result) {\n                if (!defined(result)) {\n                    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n                } else {\n                    result.xPoleWander = 0.0;\n                    result.yPoleWander = 0.0;\n                    result.xPoleOffset = 0.0;\n                    result.yPoleOffset = 0.0;\n                    result.ut1MinusUtc = 0.0;\n                }\n                return result;\n            }\n    });\n\n    /**\n     * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is\n     * ready to use.\n     *\n     * @returns {Promise.<undefined>} The promise.\n     *\n     * @see when\n     */\n    EarthOrientationParameters.prototype.getPromiseToLoad = function() {\n        return when(this._downloadPromise);\n    };\n\n    /**\n     * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n     * If the EOP data has not yet been download, this method returns undefined.\n     *\n     * @param {JulianDate} date The date for each to evaluate the EOP.\n     * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n     *        If this parameter is undefined, a new instance is created and returned.\n     * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n     *          undefined if the data necessary to evaluate EOP at the date has not yet been\n     *          downloaded.\n     *\n     * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n     *\n     * @see EarthOrientationParameters#getPromiseToLoad\n     */\n    EarthOrientationParameters.prototype.compute = function(date, result) {\n        // We cannot compute until the samples are available.\n        if (!defined(this._samples)) {\n            if (defined(this._dataError)) {\n                throw new RuntimeError(this._dataError);\n            }\n\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n        }\n\n        if (this._samples.length === 0) {\n            result.xPoleWander = 0.0;\n            result.yPoleWander = 0.0;\n            result.xPoleOffset = 0.0;\n            result.yPoleOffset = 0.0;\n            result.ut1MinusUtc = 0.0;\n            return result;\n        }\n\n        var dates = this._dates;\n        var lastIndex = this._lastIndex;\n\n        var before = 0;\n        var after = 0;\n        if (defined(lastIndex)) {\n            var previousIndexDate = dates[lastIndex];\n            var nextIndexDate = dates[lastIndex + 1];\n            var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);\n            var isAfterLastSample = !defined(nextIndexDate);\n            var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n            if (isAfterPrevious && isBeforeNext) {\n                before = lastIndex;\n\n                if (!isAfterLastSample && nextIndexDate.equals(date)) {\n                    ++before;\n                }\n                after = before + 1;\n\n                interpolate(this, dates, this._samples, date, before, after, result);\n                return result;\n            }\n        }\n\n        var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n        if (index >= 0) {\n            // If the next entry is the same date, use the later entry.  This way, if two entries\n            // describe the same moment, one before a leap second and the other after, then we will use\n            // the post-leap second data.\n            if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n                ++index;\n            }\n            before = index;\n            after = index;\n        } else {\n            after = ~index;\n            before = after - 1;\n\n            // Use the first entry if the date requested is before the beginning of the data.\n            if (before < 0) {\n                before = 0;\n            }\n        }\n\n        this._lastIndex = before;\n\n        interpolate(this, dates, this._samples, date, before, after, result);\n        return result;\n    };\n\n    function compareLeapSecondDates(leapSecond, dateToFind) {\n        return JulianDate.compare(leapSecond.julianDate, dateToFind);\n    }\n\n    function onDataReady(eop, eopData) {\n        if (!defined(eopData.columnNames)) {\n            eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';\n            return;\n        }\n\n        if (!defined(eopData.samples)) {\n            eop._dataError = 'Error in loaded EOP data: The samples property is required.';\n            return;\n        }\n\n        var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');\n        var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');\n        var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');\n        var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');\n        var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');\n        var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');\n        var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');\n\n        if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {\n            eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';\n            return;\n        }\n\n        var samples = eop._samples = eopData.samples;\n        var dates = eop._dates = [];\n\n        eop._dateColumn = dateColumn;\n        eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n        eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n        eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n        eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n        eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n        eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n        eop._columnCount = eopData.columnNames.length;\n        eop._lastIndex = undefined;\n\n        var lastTaiMinusUtc;\n\n        var addNewLeapSeconds = eop._addNewLeapSeconds;\n\n        // Convert the ISO8601 dates to JulianDates.\n        for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {\n            var mjd = samples[i + dateColumn];\n            var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n            var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n            var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n            dates.push(date);\n\n            if (addNewLeapSeconds) {\n                if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n                    // We crossed a leap second boundary, so add the leap second\n                    // if it does not already exist.\n                    var leapSeconds = JulianDate.leapSeconds;\n                    var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);\n                    if (leapSecondIndex < 0) {\n                        var leapSecond = new LeapSecond(date, taiMinusUtc);\n                        leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n                    }\n                }\n                lastTaiMinusUtc = taiMinusUtc;\n            }\n        }\n    }\n\n    function fillResultFromIndex(eop, samples, index, columnCount, result) {\n        var start = index * columnCount;\n        result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n        result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n        result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n        result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n        result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n    }\n\n    function linearInterp(dx, y1, y2) {\n        return y1 + dx * (y2 - y1);\n    }\n\n    function interpolate(eop, dates, samples, date, before, after, result) {\n        var columnCount = eop._columnCount;\n\n        // First check the bounds on the EOP data\n        // If we are after the bounds of the data, return zeros.\n        // The 'before' index should never be less than zero.\n        if (after > dates.length - 1) {\n            result.xPoleWander = 0;\n            result.yPoleWander = 0;\n            result.xPoleOffset = 0;\n            result.yPoleOffset = 0;\n            result.ut1MinusUtc = 0;\n            return result;\n        }\n\n        var beforeDate = dates[before];\n        var afterDate = dates[after];\n        if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n            fillResultFromIndex(eop, samples, before, columnCount, result);\n            return result;\n        } else if (date.equals(afterDate)) {\n            fillResultFromIndex(eop, samples, after, columnCount, result);\n            return result;\n        }\n\n        var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);\n\n        var startBefore = before * columnCount;\n        var startAfter = after * columnCount;\n\n        // Handle UT1 leap second edge case\n        var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n        var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n        var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n        if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n            // The absolute difference between the values is more than 0.5, so we may have\n            // crossed a leap second.  Check if this is the case and, if so, adjust the\n            // afterValue to account for the leap second.  This way, our interpolation will\n            // produce reasonable results.\n            var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];\n            var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];\n            if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n                if (afterDate.equals(date)) {\n                    // If we are at the end of the leap second interval, take the second value\n                    // Otherwise, the interpolation below will yield the wrong side of the\n                    // discontinuity\n                    // At the end of the leap second, we need to start accounting for the jump\n                    beforeUt1MinusUtc = afterUt1MinusUtc;\n                } else {\n                    // Otherwise, remove the leap second so that the interpolation is correct\n                    afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n                }\n            }\n        }\n\n        result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);\n        result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);\n        result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);\n        result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);\n        result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);\n        return result;\n    }\n\n    return EarthOrientationParameters;\n});\n",
    "\n/**\n * @license\n *\n * Grauw URI utilities\n *\n * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js\n *\n * @author Laurens Holst (http://www.grauw.nl/)\n *\n *   Copyright 2012 Laurens Holst\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n *\n */\n/*global define*/\ndefine('ThirdParty/Uri',[],function() {\n\n\t/**\n\t * Constructs a URI object.\n\t * @constructor\n\t * @class Implementation of URI parsing and base URI resolving algorithm in RFC 3986.\n\t * @param {string|URI} uri A string or URI object to create the object from.\n\t */\n\tfunction URI(uri) {\n\t\tif (uri instanceof URI) {  // copy constructor\n\t\t\tthis.scheme = uri.scheme;\n\t\t\tthis.authority = uri.authority;\n\t\t\tthis.path = uri.path;\n\t\t\tthis.query = uri.query;\n\t\t\tthis.fragment = uri.fragment;\n\t\t} else if (uri) {  // uri is URI string or cast to string\n\t\t\tvar c = parseRegex.exec(uri);\n\t\t\tthis.scheme = c[1];\n\t\t\tthis.authority = c[2];\n\t\t\tthis.path = c[3];\n\t\t\tthis.query = c[4];\n\t\t\tthis.fragment = c[5];\n\t\t}\n\t};\n\n\t// Initial values on the prototype\n\tURI.prototype.scheme    = null;\n\tURI.prototype.authority = null;\n\tURI.prototype.path      = '';\n\tURI.prototype.query     = null;\n\tURI.prototype.fragment  = null;\n\n\t// Regular expression from RFC 3986 appendix B\n\tvar parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\\\?([^#]*))?(?:#(.*))?$');\n\n\t/**\n\t * Returns the scheme part of the URI.\n\t * In \"http://example.com:80/a/b?x#y\" this is \"http\".\n\t */\n\tURI.prototype.getScheme = function() {\n\t\treturn this.scheme;\n\t};\n\n\t/**\n\t * Returns the authority part of the URI.\n\t * In \"http://example.com:80/a/b?x#y\" this is \"example.com:80\".\n\t */\n\tURI.prototype.getAuthority = function() {\n\t\treturn this.authority;\n\t};\n\n\t/**\n\t * Returns the path part of the URI.\n\t * In \"http://example.com:80/a/b?x#y\" this is \"/a/b\".\n\t * In \"mailto:mike@example.com\" this is \"mike@example.com\".\n\t */\n\tURI.prototype.getPath = function() {\n\t\treturn this.path;\n\t};\n\n\t/**\n\t * Returns the query part of the URI.\n\t * In \"http://example.com:80/a/b?x#y\" this is \"x\".\n\t */\n\tURI.prototype.getQuery = function() {\n\t\treturn this.query;\n\t};\n\n\t/**\n\t * Returns the fragment part of the URI.\n\t * In \"http://example.com:80/a/b?x#y\" this is \"y\".\n\t */\n\tURI.prototype.getFragment = function() {\n\t\treturn this.fragment;\n\t};\n\n\t/**\n\t * Tests whether the URI is an absolute URI.\n\t * See RFC 3986 section 4.3.\n\t */\n\tURI.prototype.isAbsolute = function() {\n\t\treturn !!this.scheme && !this.fragment;\n\t};\n\n\t///**\n\t//* Extensive validation of the URI against the ABNF in RFC 3986\n\t//*/\n\t//URI.prototype.validate\n\n\t/**\n\t * Tests whether the URI is a same-document reference.\n\t * See RFC 3986 section 4.4.\n\t *\n\t * To perform more thorough comparison, you can normalise the URI objects.\n\t */\n\tURI.prototype.isSameDocumentAs = function(uri) {\n\t\treturn uri.scheme == this.scheme &&\n\t\t    uri.authority == this.authority &&\n\t\t         uri.path == this.path &&\n\t\t        uri.query == this.query;\n\t};\n\n\t/**\n\t * Simple String Comparison of two URIs.\n\t * See RFC 3986 section 6.2.1.\n\t *\n\t * To perform more thorough comparison, you can normalise the URI objects.\n\t */\n\tURI.prototype.equals = function(uri) {\n\t\treturn this.isSameDocumentAs(uri) && uri.fragment == this.fragment;\n\t};\n\n\t/**\n\t * Normalizes the URI using syntax-based normalization.\n\t * This includes case normalization, percent-encoding normalization and path segment normalization.\n\t * XXX: Percent-encoding normalization does not escape characters that need to be escaped.\n\t *      (Although that would not be a valid URI in the first place. See validate().)\n\t * See RFC 3986 section 6.2.2.\n\t */\n\tURI.prototype.normalize = function() {\n\t\tthis.removeDotSegments();\n\t\tif (this.scheme)\n\t\t\tthis.scheme = this.scheme.toLowerCase();\n\t\tif (this.authority)\n\t\t\tthis.authority = this.authority.replace(authorityRegex, replaceAuthority).\n\t\t\t\t\t\t\t\t\treplace(caseRegex, replaceCase);\n\t\tif (this.path)\n\t\t\tthis.path = this.path.replace(caseRegex, replaceCase);\n\t\tif (this.query)\n\t\t\tthis.query = this.query.replace(caseRegex, replaceCase);\n\t\tif (this.fragment)\n\t\t\tthis.fragment = this.fragment.replace(caseRegex, replaceCase);\n\t};\n\n\tvar caseRegex = /%[0-9a-z]{2}/gi;\n\tvar percentRegex = /[a-zA-Z0-9\\-\\._~]/;\n\tvar authorityRegex = /(.*@)?([^@:]*)(:.*)?/;\n\n\tfunction replaceCase(str) {\n\t\tvar dec = unescape(str);\n\t\treturn percentRegex.test(dec) ? dec : str.toUpperCase();\n\t}\n\n\tfunction replaceAuthority(str, p1, p2, p3) {\n\t\treturn (p1 || '') + p2.toLowerCase() + (p3 || '');\n\t}\n\n\t/**\n\t * Resolve a relative URI (this) against a base URI.\n\t * The base URI must be an absolute URI.\n\t * See RFC 3986 section 5.2\n\t */\n\tURI.prototype.resolve = function(baseURI) {\n\t\tvar uri = new URI();\n\t\tif (this.scheme) {\n\t\t\turi.scheme = this.scheme;\n\t\t\turi.authority = this.authority;\n\t\t\turi.path = this.path;\n\t\t\turi.query = this.query;\n\t\t} else {\n\t\t\turi.scheme = baseURI.scheme;\n\t\t\tif (this.authority) {\n\t\t\t\turi.authority = this.authority;\n\t\t\t\turi.path = this.path;\n\t\t\t\turi.query = this.query;\n\t\t\t} else {\n\t\t\t\turi.authority = baseURI.authority;\n\t\t\t\tif (this.path == '') {\n\t\t\t\t\turi.path = baseURI.path;\n\t\t\t\t\turi.query = this.query || baseURI.query;\n\t\t\t\t} else {\n\t\t\t\t\tif (this.path.charAt(0) == '/') {\n\t\t\t\t\t\turi.path = this.path;\n\t\t\t\t\t\turi.removeDotSegments();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (baseURI.authority && baseURI.path == '') {\n\t\t\t\t\t\t\turi.path = '/' + this.path;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turi.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;\n\t\t\t\t\t\t}\n\t\t\t\t\t\turi.removeDotSegments();\n\t\t\t\t\t}\n\t\t\t\t\turi.query = this.query;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\turi.fragment = this.fragment;\n\t\treturn uri;\n\t};\n\n\t/**\n\t * Remove dot segments from path.\n\t * See RFC 3986 section 5.2.4\n\t * @private\n\t */\n\tURI.prototype.removeDotSegments = function() {\n\t\tvar input = this.path.split('/'),\n\t\t\toutput = [],\n\t\t\tsegment,\n\t\t\tabsPath = input[0] == '';\n\t\tif (absPath)\n\t\t\tinput.shift();\n\t\tvar sFirst = input[0] == '' ? input.shift() : null;\n\t\twhile (input.length) {\n\t\t\tsegment = input.shift();\n\t\t\tif (segment == '..') {\n\t\t\t\toutput.pop();\n\t\t\t} else if (segment != '.') {\n\t\t\t\toutput.push(segment);\n\t\t\t}\n\t\t}\n\t\tif (segment == '.' || segment == '..')\n\t\t\toutput.push('');\n\t\tif (absPath)\n\t\t\toutput.unshift('');\n\t\tthis.path = output.join('/');\n\t};\n\n\t// We don't like this function because it builds up a cache that is never cleared.\n//\t/**\n//\t * Resolves a relative URI against an absolute base URI.\n//\t * Convenience method.\n//\t * @param {String} uri the relative URI to resolve\n//\t * @param {String} baseURI the base URI (must be absolute) to resolve against\n//\t */\n//\tURI.resolve = function(sURI, sBaseURI) {\n//\t\tvar uri = cache[sURI] || (cache[sURI] = new URI(sURI));\n//\t\tvar baseURI = cache[sBaseURI] || (cache[sBaseURI] = new URI(sBaseURI));\n//\t\treturn uri.resolve(baseURI).toString();\n//\t};\n\n//\tvar cache = {};\n\n\t/**\n\t * Serialises the URI to a string.\n\t */\n\tURI.prototype.toString = function() {\n\t\tvar result = '';\n\t\tif (this.scheme)\n\t\t\tresult += this.scheme + ':';\n\t\tif (this.authority)\n\t\t\tresult += '//' + this.authority;\n\t\tresult += this.path;\n\t\tif (this.query)\n\t\t\tresult += '?' + this.query;\n\t\tif (this.fragment)\n\t\t\tresult += '#' + this.fragment;\n\t\treturn result;\n\t};\n\nreturn URI;\n});\n",
    "\n/*global define*/\ndefine('Core/buildModuleUrl',[\n        '../ThirdParty/Uri',\n        './defined',\n        './DeveloperError',\n        'require'\n    ], function(\n        Uri,\n        defined,\n        DeveloperError,\n        require) {\n    \"use strict\";\n    /*global CESIUM_BASE_URL*/\n\n    var cesiumScriptRegex = /((?:.*\\/)|^)cesium[\\w-]*\\.js(?:\\W|$)/i;\n    function getBaseUrlFromCesiumScript() {\n        var scripts = document.getElementsByTagName('script');\n        for ( var i = 0, len = scripts.length; i < len; ++i) {\n            var src = scripts[i].getAttribute('src');\n            var result = cesiumScriptRegex.exec(src);\n            if (result !== null) {\n                return result[1];\n            }\n        }\n        return undefined;\n    }\n\n    var baseUrl;\n    function getCesiumBaseUrl() {\n        if (defined(baseUrl)) {\n            return baseUrl;\n        }\n\n        var baseUrlString;\n        if (typeof CESIUM_BASE_URL !== 'undefined') {\n            baseUrlString = CESIUM_BASE_URL;\n        } else {\n            baseUrlString = getBaseUrlFromCesiumScript();\n        }\n\n        if (!defined(baseUrlString)) {\n            throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');\n        }\n\n        baseUrl = new Uri(baseUrlString).resolve(new Uri(document.location.href));\n\n        return baseUrl;\n    }\n\n    function buildModuleUrlFromRequireToUrl(moduleID) {\n        //moduleID will be non-relative, so require it relative to this module, in Core.\n        return require.toUrl('../' + moduleID);\n    }\n\n    function buildModuleUrlFromBaseUrl(moduleID) {\n        return new Uri(moduleID).resolve(getCesiumBaseUrl()).toString();\n    }\n\n    var implementation;\n    var a;\n\n    /**\n     * Given a non-relative moduleID, returns an absolute URL to the file represented by that module ID,\n     * using, in order of preference, require.toUrl, the value of a global CESIUM_BASE_URL, or\n     * the base URL of the Cesium.js script.\n     *\n     * @private\n     */\n    var buildModuleUrl = function(moduleID) {\n        if (!defined(implementation)) {\n            //select implementation\n            if (defined(require.toUrl)) {\n                implementation = buildModuleUrlFromRequireToUrl;\n            } else {\n                implementation = buildModuleUrlFromBaseUrl;\n            }\n        }\n\n        if (!defined(a)) {\n            a = document.createElement('a');\n        }\n\n        var url = implementation(moduleID);\n\n        a.href = url;\n        a.href = a.href; // IE only absolutizes href on get, not set\n\n        return a.href;\n    };\n\n    // exposed for testing\n    buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;\n\n    /**\n     * Sets the base URL for resolving modules.\n     * @param {String} value The new base URL.\n     */\n    buildModuleUrl.setBaseUrl = function(value) {\n        baseUrl = new Uri(value).resolve(new Uri(document.location.href));\n    };\n\n    return buildModuleUrl;\n});",
    "\n/*global define*/\ndefine('Core/Iau2006XysSample',[],function() {\n    \"use strict\";\n\n    /**\n     * An IAU 2006 XYS value sampled at a particular time.\n     *\n     * @alias Iau2006XysSample\n     * @constructor\n     *\n     * @param {Number} x The X value.\n     * @param {Number} y The Y value.\n     * @param {Number} s The S value.\n     *\n     * @private\n     */\n    var Iau2006XysSample = function Iau2006XysSample(x, y, s) {\n        /**\n         * The X value.\n         * @type {Number}\n         */\n        this.x = x;\n\n        /**\n         * The Y value.\n         * @type {Number}\n         */\n        this.y = y;\n\n        /**\n         * The S value.\n         * @type {Number}\n         */\n        this.s = s;\n    };\n\n    return Iau2006XysSample;\n});",
    "\n/*global define*/\ndefine('Core/Iau2006XysData',[\n        '../ThirdParty/when',\n        './buildModuleUrl',\n        './defaultValue',\n        './defined',\n        './Iau2006XysSample',\n        './JulianDate',\n        './loadJson',\n        './TimeStandard'\n    ], function(\n        when,\n        buildModuleUrl,\n        defaultValue,\n        defined,\n        Iau2006XysSample,\n        JulianDate,\n        loadJson,\n        TimeStandard) {\n    \"use strict\";\n\n    /**\n     * A set of IAU2006 XYS data that is used to evaluate the transformation between the International\n     * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).\n     *\n     * @alias Iau2006XysData\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {String} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,\n     *                 `{0}` will be replaced with the file index.\n     * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.\n     * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the\n     *                 first XYS sample.\n     * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.\n     * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.\n     * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.\n     *\n     * @private\n     */\n    var Iau2006XysData = function Iau2006XysData(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._xysFileUrlTemplate = options.xysFileUrlTemplate;\n        this._interpolationOrder = defaultValue(options.interpolationOrder, 9);\n        this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);\n        this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0.0, TimeStandard.TAI);\n        this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);\n        this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);\n        this._totalSamples = defaultValue(options.totalSamples, 27426);\n        this._samples = new Array(this._totalSamples * 3);\n        this._chunkDownloadsInProgress = [];\n\n        var order = this._interpolationOrder;\n\n        // Compute denominators and X values for interpolation.\n        var denom = this._denominators = new Array(order + 1);\n        var xTable = this._xTable = new Array(order + 1);\n\n        var stepN = Math.pow(this._stepSizeDays, order);\n\n        for ( var i = 0; i <= order; ++i) {\n            denom[i] = stepN;\n            xTable[i] = i * this._stepSizeDays;\n\n            for ( var j = 0; j <= order; ++j) {\n                if (j !== i) {\n                    denom[i] *= (i - j);\n                }\n            }\n\n            denom[i] = 1.0 / denom[i];\n        }\n\n        // Allocate scratch arrays for interpolation.\n        this._work = new Array(order + 1);\n        this._coef = new Array(order + 1);\n    };\n\n    var julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);\n\n    function getDaysSinceEpoch(xys, dayTT, secondTT) {\n        var dateTT = julianDateScratch;\n        dateTT.dayNumber = dayTT;\n        dateTT.secondsOfDay = secondTT;\n        return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);\n    }\n\n    /**\n     * Preloads XYS data for a specified date range.\n     *\n     * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @returns {Promise.<undefined>} A promise that, when resolved, indicates that the requested interval has been\n     *                    preloaded.\n     */\n    Iau2006XysData.prototype.preload = function(startDayTT, startSecondTT, stopDayTT, stopSecondTT) {\n        var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);\n        var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);\n\n        var startIndex = (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0;\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n\n        var stopIndex = (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) | 0 + this._interpolationOrder;\n        if (stopIndex >= this._totalSamples) {\n            stopIndex = this._totalSamples - 1;\n        }\n\n        var startChunk = (startIndex / this._samplesPerXysFile) | 0;\n        var stopChunk = (stopIndex / this._samplesPerXysFile) | 0;\n\n        var promises = [];\n        for ( var i = startChunk; i <= stopChunk; ++i) {\n            promises.push(requestXysChunk(this, i));\n        }\n\n        return when.all(promises);\n    };\n\n    /**\n     * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,\n     * this method will return undefined.\n     *\n     * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in\n     *                 the Terrestrial Time (TT) time standard.\n     * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter\n     *                           is undefined, a new instance is allocated and returned.\n     * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this\n     *                             computation has not yet been downloaded.\n     *\n     * @see Iau2006XysData#preload\n     */\n    Iau2006XysData.prototype.computeXysRadians = function(dayTT, secondTT, result) {\n        var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);\n        if (daysSinceEpoch < 0.0) {\n            // Can't evaluate prior to the epoch of the data.\n            return undefined;\n        }\n\n        var centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;\n        if (centerIndex >= this._totalSamples) {\n            // Can't evaluate after the last sample in the data.\n            return undefined;\n        }\n\n        var degree = this._interpolationOrder;\n\n        var firstIndex = centerIndex - ((degree / 2) | 0);\n        if (firstIndex < 0) {\n            firstIndex = 0;\n        }\n        var lastIndex = firstIndex + degree;\n        if (lastIndex >= this._totalSamples) {\n            lastIndex = this._totalSamples - 1;\n            firstIndex = lastIndex - degree;\n            if (firstIndex < 0) {\n                firstIndex = 0;\n            }\n        }\n\n        // Are all the samples we need present?\n        // We can assume so if the first and last are present\n        var isDataMissing = false;\n        var samples = this._samples;\n        if (!defined(samples[firstIndex * 3])) {\n            requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);\n            isDataMissing = true;\n        }\n\n        if (!defined(samples[lastIndex * 3])) {\n            requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);\n            isDataMissing = true;\n        }\n\n        if (isDataMissing) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            result = new Iau2006XysSample(0.0, 0.0, 0.0);\n        } else {\n            result.x = 0.0;\n            result.y = 0.0;\n            result.s = 0.0;\n        }\n\n        var x = daysSinceEpoch - firstIndex * this._stepSizeDays;\n\n        var work = this._work;\n        var denom = this._denominators;\n        var coef = this._coef;\n        var xTable = this._xTable;\n\n        var i, j;\n        for (i = 0; i <= degree; ++i) {\n            work[i] = x - xTable[i];\n        }\n\n        for (i = 0; i <= degree; ++i) {\n            coef[i] = 1.0;\n\n            for (j = 0; j <= degree; ++j) {\n                if (j !== i) {\n                    coef[i] *= work[j];\n                }\n            }\n\n            coef[i] *= denom[i];\n\n            var sampleIndex = (firstIndex + i) * 3;\n            result.x += coef[i] * samples[sampleIndex++];\n            result.y += coef[i] * samples[sampleIndex++];\n            result.s += coef[i] * samples[sampleIndex];\n        }\n\n        return result;\n    };\n\n    function requestXysChunk(xysData, chunkIndex) {\n        if (xysData._chunkDownloadsInProgress[chunkIndex]) {\n            // Chunk has already been requested.\n            return xysData._chunkDownloadsInProgress[chunkIndex];\n        }\n\n        var deferred = when.defer();\n\n        xysData._chunkDownloadsInProgress[chunkIndex] = deferred;\n\n        var chunkUrl;\n        var xysFileUrlTemplate = xysData._xysFileUrlTemplate;\n        if (defined(xysFileUrlTemplate)) {\n            chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);\n        } else {\n            chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');\n        }\n\n        when(loadJson(chunkUrl), function(chunk) {\n            xysData._chunkDownloadsInProgress[chunkIndex] = false;\n\n            var samples = xysData._samples;\n            var newSamples = chunk.samples;\n            var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;\n\n            for ( var i = 0, len = newSamples.length; i < len; ++i) {\n                samples[startIndex + i] = newSamples[i];\n            }\n\n            deferred.resolve();\n        });\n\n        return deferred.promise;\n    }\n\n    return Iau2006XysData;\n});\n",
    "\n/*global define*/\ndefine('Core/Quaternion',[\n        './Cartesian3',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './FeatureDetection',\n        './freezeObject',\n        './Math',\n        './Matrix3'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        DeveloperError,\n        FeatureDetection,\n        freezeObject,\n        CesiumMath,\n        Matrix3) {\n    \"use strict\";\n\n    /**\n     * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n     * @alias Quaternion\n     * @constructor\n     *\n     * @param {Number} [x=0.0] The X component.\n     * @param {Number} [y=0.0] The Y component.\n     * @param {Number} [z=0.0] The Z component.\n     * @param {Number} [w=0.0] The W component.\n     *\n     * @see PackableForInterpolation\n     */\n    var Quaternion = function(x, y, z, w) {\n        /**\n         * The X component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.x = defaultValue(x, 0.0);\n\n        /**\n         * The Y component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.y = defaultValue(y, 0.0);\n\n        /**\n         * The Z component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.z = defaultValue(z, 0.0);\n\n        /**\n         * The W component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.w = defaultValue(w, 0.0);\n    };\n\n    var fromAxisAngleScratch = new Cartesian3();\n\n    /**\n     * Computes a quaternion representing a rotation around an axis.\n     *\n     * @param {Cartesian3} axis The axis of rotation.\n     * @param {Number} angle The angle in radians to rotate around the axis.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n     */\n    Quaternion.fromAxisAngle = function(axis, angle, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(axis)) {\n            throw new DeveloperError('axis is required.');\n        }\n        if (typeof angle !== 'number') {\n            throw new DeveloperError('angle is required and must be a number.');\n        }\n        //>>includeEnd('debug');\n\n        var halfAngle = angle / 2.0;\n        var s = Math.sin(halfAngle);\n        fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n        var x = fromAxisAngleScratch.x * s;\n        var y = fromAxisAngleScratch.y * s;\n        var z = fromAxisAngleScratch.z * s;\n        var w = Math.cos(halfAngle);\n        if (!defined(result)) {\n            return new Quaternion(x, y, z, w);\n        }\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    var fromRotationMatrixNext = [1, 2, 0];\n    var fromRotationMatrixQuat = new Array(3);\n    /**\n     * Computes a Quaternion from the provided Matrix3 instance.\n     *\n     * @param {Matrix3} matrix The rotation matrix.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n     *\n     * @see Matrix3.fromQuaternion\n     */\n    Quaternion.fromRotationMatrix = function(matrix, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(matrix)) {\n            throw new DeveloperError('matrix is required.');\n        }\n        //>>includeEnd('debug');\n\n        var root;\n        var x;\n        var y;\n        var z;\n        var w;\n\n        var m00 = matrix[Matrix3.COLUMN0ROW0];\n        var m11 = matrix[Matrix3.COLUMN1ROW1];\n        var m22 = matrix[Matrix3.COLUMN2ROW2];\n        var trace = m00 + m11 + m22;\n\n        if (trace > 0.0) {\n            // |w| > 1/2, may as well choose w > 1/2\n            root = Math.sqrt(trace + 1.0); // 2w\n            w = 0.5 * root;\n            root = 0.5 / root; // 1/(4w)\n\n            x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n            y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n            z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n        } else {\n            // |w| <= 1/2\n            var next = fromRotationMatrixNext;\n\n            var i = 0;\n            if (m11 > m00) {\n                i = 1;\n            }\n            if (m22 > m00 && m22 > m11) {\n                i = 2;\n            }\n            var j = next[i];\n            var k = next[j];\n\n            root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1.0);\n\n            var quat = fromRotationMatrixQuat;\n            quat[i] = 0.5 * root;\n            root = 0.5 / root;\n            w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;\n            quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;\n            quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;\n\n            x = -quat[0];\n            y = -quat[1];\n            z = -quat[2];\n        }\n\n        if (!defined(result)) {\n            return new Quaternion(x, y, z, w);\n        }\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    var scratchHPRQuaternion = new Quaternion();\n\n    /**\n     * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n     * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n     * the positive x axis.\n     *\n     * @param {Number} heading The heading angle in radians.\n     * @param {Number} pitch The pitch angle in radians.\n     * @param {Number} roll The roll angle in radians.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n     */\n    Quaternion.fromHeadingPitchRoll = function(heading, pitch, roll, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(heading)) {\n            throw new DeveloperError('heading is required.');\n        }\n        if (!defined(pitch)) {\n            throw new DeveloperError('pitch is required.');\n        }\n        if (!defined(roll)) {\n            throw new DeveloperError('roll is required.');\n        }\n        //>>includeEnd('debug');\n\n        var rollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, roll, scratchHPRQuaternion);\n        var pitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, result);\n        result = Quaternion.multiply(pitchQuaternion, rollQuaternion, pitchQuaternion);\n        var headingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchHPRQuaternion);\n        return Quaternion.multiply(headingQuaternion, result, result);\n    };\n\n    var sampledQuaternionAxis = new Cartesian3();\n    var sampledQuaternionRotation = new Cartesian3();\n    var sampledQuaternionTempQuaternion = new Quaternion();\n    var sampledQuaternionQuaternion0 = new Quaternion();\n    var sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    Quaternion.packedLength = 4;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {Quaternion} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    Quaternion.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.x;\n        array[startingIndex++] = value.y;\n        array[startingIndex++] = value.z;\n        array[startingIndex] = value.w;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {Quaternion} [result] The object into which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n     */\n    Quaternion.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new Quaternion();\n        }\n        result.x = array[startingIndex];\n        result.y = array[startingIndex + 1];\n        result.z = array[startingIndex + 2];\n        result.w = array[startingIndex + 3];\n        return result;\n    };\n\n    /**\n     * The number of elements used to store the object into an array in its interpolatable form.\n     * @type {Number}\n     */\n    Quaternion.packedInterpolationLength = 3;\n\n    /**\n     * Converts a packed array into a form suitable for interpolation.\n     *\n     * @param {Number[]} packedArray The packed array.\n     * @param {Number} [startingIndex=0] The index of the first element to be converted.\n     * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n     * @param {Number[]} result The object into which to store the result.\n     */\n    Quaternion.convertPackedArrayForInterpolation = function(packedArray, startingIndex, lastIndex, result) {\n        Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);\n        Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);\n\n        for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n            var offset = i * 3;\n            Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);\n\n            Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);\n\n            if (sampledQuaternionTempQuaternion.w < 0) {\n                Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);\n            }\n\n            Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);\n            var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n            result[offset] = sampledQuaternionAxis.x * angle;\n            result[offset + 1] = sampledQuaternionAxis.y * angle;\n            result[offset + 2] = sampledQuaternionAxis.z * angle;\n        }\n    };\n\n    /**\n     * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n     *\n     * @param {Number[]} array The array previously packed for interpolation.\n     * @param {Number[]} sourceArray The original packed array.\n     * @param {Number} [startingIndex=0] The startingIndex used to convert the array.\n     * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n     * @param {Quaternion} [result] The object into which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n     */\n    Quaternion.unpackInterpolationResult = function(array, sourceArray, firstIndex, lastIndex, result) {\n        if (!defined(result)) {\n            result = new Quaternion();\n        }\n        Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n        var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n\n        Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n        if (magnitude === 0) {\n            Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n        } else {\n            Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);\n        }\n\n        return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);\n    };\n\n    /**\n     * Duplicates a Quaternion instance.\n     *\n     * @param {Quaternion} quaternion The quaternion to duplicate.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n     */\n    Quaternion.clone = function(quaternion, result) {\n        if (!defined(quaternion)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        }\n\n        result.x = quaternion.x;\n        result.y = quaternion.y;\n        result.z = quaternion.z;\n        result.w = quaternion.w;\n        return result;\n    };\n\n    /**\n     * Computes the conjugate of the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to conjugate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.conjugate = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = -quaternion.x;\n        result.y = -quaternion.y;\n        result.z = -quaternion.z;\n        result.w = quaternion.w;\n        return result;\n    };\n\n    /**\n     * Computes magnitude squared for the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to conjugate.\n     * @returns {Number} The magnitude squared.\n     */\n    Quaternion.magnitudeSquared = function(quaternion) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        //>>includeEnd('debug');\n\n        return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;\n    };\n\n    /**\n     * Computes magnitude for the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to conjugate.\n     * @returns {Number} The magnitude.\n     */\n    Quaternion.magnitude = function(quaternion) {\n        return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n    };\n\n    /**\n     * Computes the normalized form of the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to normalize.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.normalize = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n        var x = quaternion.x * inverseMagnitude;\n        var y = quaternion.y * inverseMagnitude;\n        var z = quaternion.z * inverseMagnitude;\n        var w = quaternion.w * inverseMagnitude;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Computes the inverse of the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to normalize.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.inverse = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n        result = Quaternion.conjugate(quaternion, result);\n        return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n    };\n\n    /**\n     * Computes the componentwise sum of two quaternions.\n     *\n     * @param {Quaternion} left The first quaternion.\n     * @param {Quaternion} right The second quaternion.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.add = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x + right.x;\n        result.y = left.y + right.y;\n        result.z = left.z + right.z;\n        result.w = left.w + right.w;\n        return result;\n    };\n\n    /**\n     * Computes the componentwise difference of two quaternions.\n     *\n     * @param {Quaternion} left The first quaternion.\n     * @param {Quaternion} right The second quaternion.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.subtract = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = left.x - right.x;\n        result.y = left.y - right.y;\n        result.z = left.z - right.z;\n        result.w = left.w - right.w;\n        return result;\n    };\n\n    /**\n     * Negates the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to be negated.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.negate = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = -quaternion.x;\n        result.y = -quaternion.y;\n        result.z = -quaternion.z;\n        result.w = -quaternion.w;\n        return result;\n    };\n\n    /**\n     * Computes the dot (scalar) product of two quaternions.\n     *\n     * @param {Quaternion} left The first quaternion.\n     * @param {Quaternion} right The second quaternion.\n     * @returns {Number} The dot product.\n     */\n    Quaternion.dot = function(left, right) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        //>>includeEnd('debug');\n\n        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n    };\n\n    /**\n     * Computes the product of two quaternions.\n     *\n     * @param {Quaternion} left The first quaternion.\n     * @param {Quaternion} right The second quaternion.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.multiply = function(left, right, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(left)) {\n            throw new DeveloperError('left is required');\n        }\n        if (!defined(right)) {\n            throw new DeveloperError('right is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var leftX = left.x;\n        var leftY = left.y;\n        var leftZ = left.z;\n        var leftW = left.w;\n\n        var rightX = right.x;\n        var rightY = right.y;\n        var rightZ = right.z;\n        var rightW = right.w;\n\n        var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n        var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n        var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n        var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n        return result;\n    };\n\n    /**\n     * Multiplies the provided quaternion componentwise by the provided scalar.\n     *\n     * @param {Quaternion} quaternion The quaternion to be scaled.\n     * @param {Number} scalar The scalar to multiply with.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.multiplyByScalar = function(quaternion, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = quaternion.x * scalar;\n        result.y = quaternion.y * scalar;\n        result.z = quaternion.z * scalar;\n        result.w = quaternion.w * scalar;\n        return result;\n    };\n\n    /**\n     * Divides the provided quaternion componentwise by the provided scalar.\n     *\n     * @param {Quaternion} quaternion The quaternion to be divided.\n     * @param {Number} scalar The scalar to divide by.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.divideByScalar = function(quaternion, scalar, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        if (typeof scalar !== 'number') {\n            throw new DeveloperError('scalar is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        result.x = quaternion.x / scalar;\n        result.y = quaternion.y / scalar;\n        result.z = quaternion.z / scalar;\n        result.w = quaternion.w / scalar;\n        return result;\n    };\n\n    /**\n     * Computes the axis of rotation of the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to use.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Quaternion.computeAxis = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var w = quaternion.w;\n        if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {\n            result.x = result.y = result.z = 0;\n            return result;\n        }\n\n        var scalar = 1.0 / Math.sqrt(1.0 - (w * w));\n\n        result.x = quaternion.x * scalar;\n        result.y = quaternion.y * scalar;\n        result.z = quaternion.z * scalar;\n        return result;\n    };\n\n    /**\n     * Computes the angle of rotation of the provided quaternion.\n     *\n     * @param {Quaternion} quaternion The quaternion to use.\n     * @returns {Number} The angle of rotation.\n     */\n    Quaternion.computeAngle = function(quaternion) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required');\n        }\n        //>>includeEnd('debug');\n\n        if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n            return 0.0;\n        }\n        return 2.0 * Math.acos(quaternion.w);\n    };\n\n    var lerpScratch = new Quaternion();\n    /**\n     * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n     *\n     * @param {Quaternion} start The value corresponding to t at 0.0.\n     * @param {Quaternion} end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.lerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n        result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n        return Quaternion.add(lerpScratch, result, result);\n    };\n\n    var slerpEndNegated = new Quaternion();\n    var slerpScaledP = new Quaternion();\n    var slerpScaledR = new Quaternion();\n    /**\n     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n     *\n     * @param {Quaternion} start The value corresponding to t at 0.0.\n     * @param {Quaternion} end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     *\n     * @see Quaternion#fastSlerp\n     */\n    Quaternion.slerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var dot = Quaternion.dot(start, end);\n\n        // The angle between start must be acute. Since q and -q represent\n        // the same rotation, negate q to get the acute angle.\n        var r = end;\n        if (dot < 0.0) {\n            dot = -dot;\n            r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n        }\n\n        // dot > 0, as the dot product approaches 1, the angle between the\n        // quaternions vanishes. use linear interpolation.\n        if (1.0 - dot < CesiumMath.EPSILON6) {\n            return Quaternion.lerp(start, r, t, result);\n        }\n\n        var theta = Math.acos(dot);\n        slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);\n        slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);\n        result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n        return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n    };\n\n    /**\n     * The logarithmic quaternion function.\n     *\n     * @param {Quaternion} quaternion The unit quaternion.\n     * @param {Cartesian3} result The object onto which to store the result.\n     * @returns {Cartesian3} The modified result parameter.\n     */\n    Quaternion.log = function(quaternion, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(quaternion)) {\n            throw new DeveloperError('quaternion is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var theta = CesiumMath.acosClamped(quaternion.w);\n        var thetaOverSinTheta = 0.0;\n\n        if (theta !== 0.0) {\n            thetaOverSinTheta = theta / Math.sin(theta);\n        }\n\n        return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n    };\n\n    /**\n     * The exponential quaternion function.\n     *\n     * @param {Cartesian3} cartesian The cartesian.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     */\n    Quaternion.exp = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var theta = Cartesian3.magnitude(cartesian);\n        var sinThetaOverTheta = 0.0;\n\n        if (theta !== 0.0) {\n            sinThetaOverTheta = Math.sin(theta) / theta;\n        }\n\n        result.x = cartesian.x * sinThetaOverTheta;\n        result.y = cartesian.y * sinThetaOverTheta;\n        result.z = cartesian.z * sinThetaOverTheta;\n        result.w = Math.cos(theta);\n\n        return result;\n    };\n\n    var squadScratchCartesian0 = new Cartesian3();\n    var squadScratchCartesian1 = new Cartesian3();\n    var squadScratchQuaternion0 = new Quaternion();\n    var squadScratchQuaternion1 = new Quaternion();\n\n    /**\n     * Computes an inner quadrangle point.\n     * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n     *\n     * @param {Quaternion} q0 The first quaternion.\n     * @param {Quaternion} q1 The second quaternion.\n     * @param {Quaternion} q2 The third quaternion.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     *\n     * @see Quaternion#squad\n     */\n    Quaternion.computeInnerQuadrangle = function(q0, q1, q2, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(q0) || !defined(q1) || !defined(q2)) {\n            throw new DeveloperError('q0, q1, and q2 are required.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n        Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n        var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n        Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n        var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n        Cartesian3.add(cart0, cart1, cart0);\n        Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n        Cartesian3.negate(cart0, cart0);\n        Quaternion.exp(cart0, squadScratchQuaternion0);\n\n        return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n    };\n\n    /**\n     * Computes the spherical quadrangle interpolation between quaternions.\n     *\n     * @param {Quaternion} q0 The first quaternion.\n     * @param {Quaternion} q1 The second quaternion.\n     * @param {Quaternion} s0 The first inner quadrangle.\n     * @param {Quaternion} s1 The second inner quadrangle.\n     * @param {Number} t The time in [0,1] used to interpolate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     *\n     * @see Quaternion#computeInnerQuadrangle\n     *\n     * @example\n     * // 1. compute the squad interpolation between two quaternions on a curve\n     * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n     * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n     * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n     *\n     * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n     * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n     * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n     */\n    Quaternion.squad = function(q0, q1, s0, s1, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {\n            throw new DeveloperError('q0, q1, s0, and s1 are required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n        var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n        return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n    };\n\n    var fastSlerpScratchQuaternion = new Quaternion();\n    var opmu = 1.90110745351730037;\n    var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n    var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n    var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n    var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\n    for (var i = 0; i < 7; ++i) {\n        var s = i + 1.0;\n        var t = 2.0 * s + 1.0;\n        u[i] = 1.0 / (s * t);\n        v[i] = s / t;\n    }\n\n    u[7] = opmu / (8.0 * 17.0);\n    v[7] = opmu * 8.0 / 17.0;\n\n    /**\n     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n     * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n     *\n     * @param {Quaternion} start The value corresponding to t at 0.0.\n     * @param {Quaternion} end The value corresponding to t at 1.0.\n     * @param {Number} t The point along t at which to interpolate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter.\n     *\n     * @see Quaternion#slerp\n     */\n    Quaternion.fastSlerp = function(start, end, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start is required.');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end is required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var x = Quaternion.dot(start, end);\n\n        var sign;\n        if (x >= 0) {\n            sign = 1.0;\n        } else {\n            sign = -1.0;\n            x = -x;\n        }\n\n        var xm1 = x - 1.0;\n        var d = 1.0 - t;\n        var sqrT = t * t;\n        var sqrD = d * d;\n\n        for (var i = 7; i >= 0; --i) {\n            bT[i] = (u[i] * sqrT - v[i]) * xm1;\n            bD[i] = (u[i] * sqrD - v[i]) * xm1;\n        }\n\n        var cT = sign * t * (\n            1.0 + bT[0] * (1.0 + bT[1] * (1.0 + bT[2] * (1.0 + bT[3] * (\n            1.0 + bT[4] * (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n        var cD = d * (\n            1.0 + bD[0] * (1.0 + bD[1] * (1.0 + bD[2] * (1.0 + bD[3] * (\n            1.0 + bD[4] * (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n        var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);\n        Quaternion.multiplyByScalar(end, cT, result);\n        return Quaternion.add(temp, result, result);\n    };\n\n    /**\n     * Computes the spherical quadrangle interpolation between quaternions.\n     * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n     *\n     * @param {Quaternion} q0 The first quaternion.\n     * @param {Quaternion} q1 The second quaternion.\n     * @param {Quaternion} s0 The first inner quadrangle.\n     * @param {Quaternion} s1 The second inner quadrangle.\n     * @param {Number} t The time in [0,1] used to interpolate.\n     * @param {Quaternion} result The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n     *\n     * @see Quaternion#squad\n     */\n    Quaternion.fastSquad = function(q0, q1, s0, s1, t, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {\n            throw new DeveloperError('q0, q1, s0, and s1 are required.');\n        }\n        if (typeof t !== 'number') {\n            throw new DeveloperError('t is required and must be a number.');\n        }\n        if (!defined(result)) {\n            throw new DeveloperError('result is required');\n        }\n        //>>includeEnd('debug');\n\n        var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n        var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n        return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n    };\n\n    /**\n     * Compares the provided quaternions componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Quaternion} [left] The first quaternion.\n     * @param {Quaternion} [right] The second quaternion.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Quaternion.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (left.x === right.x) &&\n                (left.y === right.y) &&\n                (left.z === right.z) &&\n                (left.w === right.w));\n    };\n\n    /**\n     * Compares the provided quaternions componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Quaternion} [left] The first quaternion.\n     * @param {Quaternion} [right] The second quaternion.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Quaternion.equalsEpsilon = function(left, right, epsilon) {\n        //>>includeStart('debug', pragmas.debug);\n        if (typeof epsilon !== 'number') {\n            throw new DeveloperError('epsilon is required and must be a number.');\n        }\n        //>>includeEnd('debug');\n\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (Math.abs(left.x - right.x) <= epsilon) &&\n                (Math.abs(left.y - right.y) <= epsilon) &&\n                (Math.abs(left.z - right.z) <= epsilon) &&\n                (Math.abs(left.w - right.w) <= epsilon));\n    };\n\n    /**\n     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n     *\n     * @type {Quaternion}\n     * @constant\n     */\n    Quaternion.ZERO = freezeObject(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n    /**\n     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n     *\n     * @type {Quaternion}\n     * @constant\n     */\n    Quaternion.IDENTITY = freezeObject(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n    /**\n     * Duplicates this Quaternion instance.\n     *\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n     */\n    Quaternion.prototype.clone = function(result) {\n        return Quaternion.clone(this, result);\n    };\n\n    /**\n     * Compares this and the provided quaternion componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Quaternion} [right] The right hand side quaternion.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    Quaternion.prototype.equals = function(right) {\n        return Quaternion.equals(this, right);\n    };\n\n    /**\n     * Compares this and the provided quaternion componentwise and returns\n     * <code>true</code> if they are within the provided epsilon,\n     * <code>false</code> otherwise.\n     *\n     * @param {Quaternion} [right] The right hand side quaternion.\n     * @param {Number} epsilon The epsilon to use for equality testing.\n     * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n     */\n    Quaternion.prototype.equalsEpsilon = function(right, epsilon) {\n        return Quaternion.equalsEpsilon(this, right, epsilon);\n    };\n\n    /**\n     * Returns a string representing this quaternion in the format (x, y, z, w).\n     *\n     * @returns {String} A string representing this Quaternion.\n     */\n    Quaternion.prototype.toString = function() {\n        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';\n    };\n\n    return Quaternion;\n});",
    "\n/*global define*/\ndefine('Core/Transforms',[\n        '../ThirdParty/when',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartesian4',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './EarthOrientationParameters',\n        './EarthOrientationParametersSample',\n        './Ellipsoid',\n        './Iau2006XysData',\n        './Iau2006XysSample',\n        './JulianDate',\n        './Math',\n        './Matrix3',\n        './Matrix4',\n        './Quaternion',\n        './TimeConstants'\n    ], function(\n        when,\n        Cartesian2,\n        Cartesian3,\n        Cartesian4,\n        defaultValue,\n        defined,\n        DeveloperError,\n        EarthOrientationParameters,\n        EarthOrientationParametersSample,\n        Ellipsoid,\n        Iau2006XysData,\n        Iau2006XysSample,\n        JulianDate,\n        CesiumMath,\n        Matrix3,\n        Matrix4,\n        Quaternion,\n        TimeConstants) {\n    \"use strict\";\n\n    /**\n     * Contains functions for transforming positions to various reference frames.\n     *\n     * @namespace\n     * @alias Transforms\n     */\n    var Transforms = {};\n\n    var eastNorthUpToFixedFrameNormal = new Cartesian3();\n    var eastNorthUpToFixedFrameTangent = new Cartesian3();\n    var eastNorthUpToFixedFrameBitangent = new Cartesian3();\n\n    /**\n     * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n     * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n     * The local axes are defined as:\n     * <ul>\n     * <li>The <code>x</code> axis points in the local east direction.</li>\n     * <li>The <code>y</code> axis points in the local north direction.</li>\n     * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n     * </ul>\n     *\n     * @param {Cartesian3} origin The center point of the local reference frame.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n     *\n     * @example\n     * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n     */\n    Transforms.eastNorthUpToFixedFrame = function(origin, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin is required.');\n        }\n        //>>includeEnd('debug');\n\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {\n            var sign = CesiumMath.sign(origin.z);\n            if (!defined(result)) {\n                return new Matrix4(\n                        0.0, -sign,  0.0, origin.x,\n                        1.0,   0.0,  0.0, origin.y,\n                        0.0,   0.0, sign, origin.z,\n                        0.0,   0.0,  0.0, 1.0);\n            }\n            result[0] = 0.0;\n            result[1] = 1.0;\n            result[2] = 0.0;\n            result[3] = 0.0;\n            result[4] = -sign;\n            result[5] = 0.0;\n            result[6] = 0.0;\n            result[7] = 0.0;\n            result[8] = 0.0;\n            result[9] = 0.0;\n            result[10] = sign;\n            result[11] = 0.0;\n            result[12] = origin.x;\n            result[13] = origin.y;\n            result[14] = origin.z;\n            result[15] = 1.0;\n            return result;\n        }\n\n        var normal = eastNorthUpToFixedFrameNormal;\n        var tangent  = eastNorthUpToFixedFrameTangent;\n        var bitangent = eastNorthUpToFixedFrameBitangent;\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, normal);\n\n        tangent.x = -origin.y;\n        tangent.y = origin.x;\n        tangent.z = 0.0;\n        Cartesian3.normalize(tangent, tangent);\n\n        Cartesian3.cross(normal, tangent, bitangent);\n\n        if (!defined(result)) {\n            return new Matrix4(\n                    tangent.x, bitangent.x, normal.x, origin.x,\n                    tangent.y, bitangent.y, normal.y, origin.y,\n                    tangent.z, bitangent.z, normal.z, origin.z,\n                    0.0,       0.0,         0.0,      1.0);\n        }\n        result[0] = tangent.x;\n        result[1] = tangent.y;\n        result[2] = tangent.z;\n        result[3] = 0.0;\n        result[4] = bitangent.x;\n        result[5] = bitangent.y;\n        result[6] = bitangent.z;\n        result[7] = 0.0;\n        result[8] = normal.x;\n        result[9] = normal.y;\n        result[10] = normal.z;\n        result[11] = 0.0;\n        result[12] = origin.x;\n        result[13] = origin.y;\n        result[14] = origin.z;\n        result[15] = 1.0;\n        return result;\n    };\n\n    var northEastDownToFixedFrameNormal = new Cartesian3();\n    var northEastDownToFixedFrameTangent = new Cartesian3();\n    var northEastDownToFixedFrameBitangent = new Cartesian3();\n\n    /**\n     * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n     * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n     * The local axes are defined as:\n     * <ul>\n     * <li>The <code>x</code> axis points in the local north direction.</li>\n     * <li>The <code>y</code> axis points in the local east direction.</li>\n     * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n     * </ul>\n     *\n     * @param {Cartesian3} origin The center point of the local reference frame.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n     *\n     * @example\n     * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.\n     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n     */\n    Transforms.northEastDownToFixedFrame = function(origin, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {\n            // The poles are special cases.  If x and y are zero, assume origin is at a pole.\n            var sign = CesiumMath.sign(origin.z);\n            if (!defined(result)) {\n                return new Matrix4(\n                  -sign, 0.0,   0.0, origin.x,\n                    0.0, 1.0,   0.0, origin.y,\n                    0.0, 0.0, -sign, origin.z,\n                    0.0, 0.0,   0.0, 1.0);\n            }\n            result[0] = -sign;\n            result[1] = 0.0;\n            result[2] = 0.0;\n            result[3] = 0.0;\n            result[4] = 0.0;\n            result[5] = 1.0;\n            result[6] = 0.0;\n            result[7] = 0.0;\n            result[8] = 0.0;\n            result[9] = 0.0;\n            result[10] = -sign;\n            result[11] = 0.0;\n            result[12] = origin.x;\n            result[13] = origin.y;\n            result[14] = origin.z;\n            result[15] = 1.0;\n            return result;\n        }\n\n        var normal = northEastDownToFixedFrameNormal;\n        var tangent = northEastDownToFixedFrameTangent;\n        var bitangent = northEastDownToFixedFrameBitangent;\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, normal);\n\n        tangent.x = -origin.y;\n        tangent.y = origin.x;\n        tangent.z = 0.0;\n        Cartesian3.normalize(tangent, tangent);\n\n        Cartesian3.cross(normal, tangent, bitangent);\n\n        if (!defined(result)) {\n            return new Matrix4(\n                    bitangent.x, tangent.x, -normal.x, origin.x,\n                    bitangent.y, tangent.y, -normal.y, origin.y,\n                    bitangent.z, tangent.z, -normal.z, origin.z,\n                    0.0,       0.0,         0.0,      1.0);\n        }\n        result[0] = bitangent.x;\n        result[1] = bitangent.y;\n        result[2] = bitangent.z;\n        result[3] = 0.0;\n        result[4] = tangent.x;\n        result[5] = tangent.y;\n        result[6] = tangent.z;\n        result[7] = 0.0;\n        result[8] = -normal.x;\n        result[9] = -normal.y;\n        result[10] = -normal.z;\n        result[11] = 0.0;\n        result[12] = origin.x;\n        result[13] = origin.y;\n        result[14] = origin.z;\n        result[15] = 1.0;\n        return result;\n    };\n\n    /**\n     * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n     * centered at the provided origin to the provided ellipsoid's fixed reference frame.\n     * The local axes are defined as:\n     * <ul>\n     * <li>The <code>x</code> axis points in the local north direction.</li>\n     * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n     * <li>The <code>z</code> axis points in the local east direction.</li>\n     * </ul>\n     *\n     * @param {Cartesian3} origin The center point of the local reference frame.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n     *\n     * @example\n     * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.\n     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n     */\n    Transforms.northUpEastToFixedFrame = function(origin, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin is required.');\n        }\n        //>>includeEnd('debug');\n\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        if (CesiumMath.equalsEpsilon(origin.x, 0.0, CesiumMath.EPSILON14) &&\n            CesiumMath.equalsEpsilon(origin.y, 0.0, CesiumMath.EPSILON14)) {\n            var sign = CesiumMath.sign(origin.z);\n            if (!defined(result)) {\n                return new Matrix4(\n                       -sign, 0.0,  0.0, origin.x,\n                        0.0,  0.0,  1.0, origin.y,\n                        0.0,  sign, 0.0, origin.z,\n                        0.0,  0.0,  0.0, 1.0);\n            }\n            result[0] = -sign;\n            result[1] = 0.0;\n            result[2] = 0.0;\n            result[3] = 0.0;\n            result[4] = 0.0;\n            result[5] = 0.0;\n            result[6] = sign;\n            result[7] = 0.0;\n            result[8] = 0.0;\n            result[9] = 1.0;\n            result[10] = 0.0;\n            result[11] = 0.0;\n            result[12] = origin.x;\n            result[13] = origin.y;\n            result[14] = origin.z;\n            result[15] = 1.0;\n            return result;\n        }\n\n        var normal = eastNorthUpToFixedFrameNormal;\n        var tangent  = eastNorthUpToFixedFrameTangent;\n        var bitangent = eastNorthUpToFixedFrameBitangent;\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, normal);\n\n        tangent.x = -origin.y;\n        tangent.y = origin.x;\n        tangent.z = 0.0;\n        Cartesian3.normalize(tangent, tangent);\n\n        Cartesian3.cross(normal, tangent, bitangent);\n\n        if (!defined(result)) {\n            return new Matrix4(\n                    bitangent.x, normal.x, tangent.x, origin.x,\n                    bitangent.y, normal.y, tangent.y, origin.y,\n                    bitangent.z, normal.z, tangent.z, origin.z,\n                    0.0,       0.0,         0.0,      1.0);\n        }\n        result[0] = bitangent.x;\n        result[1] = bitangent.y;\n        result[2] = bitangent.z;\n        result[3] = 0.0;\n        result[4] = normal.x;\n        result[5] = normal.y;\n        result[6] = normal.z;\n        result[7] = 0.0;\n        result[8] = tangent.x;\n        result[9] = tangent.y;\n        result[10] = tangent.z;\n        result[11] = 0.0;\n        result[12] = origin.x;\n        result[13] = origin.y;\n        result[14] = origin.z;\n        result[15] = 1.0;\n        return result;\n    };\n\n    var scratchHPRQuaternion = new Quaternion();\n    var scratchScale = new Cartesian3(1.0, 1.0, 1.0);\n    var scratchHPRMatrix4 = new Matrix4();\n\n    /**\n     * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n     * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north\n     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n     *\n     * @param {Cartesian3} origin The center point of the local reference frame.\n     * @param {Number} heading The heading angle in radians.\n     * @param {Number} pitch The pitch angle in radians.\n     * @param {Number} roll The roll angle in radians.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n     * @param {Matrix4} [result] The object onto which to store the result.\n     * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n     *\n     * @example\n     * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var heading = -Cesium.Math.PI_OVER_TWO;\n     * var pitch = Cesium.Math.PI_OVER_FOUR;\n     * var roll = 0.0;\n     * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, heading, pitch, roll);\n     */\n    Transforms.headingPitchRollToFixedFrame = function(origin, heading, pitch, roll, ellipsoid, result) {\n        // checks for required parameters happen in the called functions\n        var hprQuaternion = Quaternion.fromHeadingPitchRoll(heading, pitch, roll, scratchHPRQuaternion);\n        var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);\n        result = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, result);\n        return Matrix4.multiply(result, hprMatrix, result);\n    };\n\n    var scratchENUMatrix4 = new Matrix4();\n    var scratchHPRMatrix3 = new Matrix3();\n\n    /**\n     * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n     * centered at the provided origin. Heading is the rotation from the local north\n     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n     *\n     * @param {Cartesian3} origin The center point of the local reference frame.\n     * @param {Number} heading The heading angle in radians.\n     * @param {Number} pitch The pitch angle in radians.\n     * @param {Number} roll The roll angle in radians.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n     * @param {Quaternion} [result] The object onto which to store the result.\n     * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n     *\n     * @example\n     * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.\n     * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var heading = -Cesium.Math.PI_OVER_TWO;\n     * var pitch = Cesium.Math.PI_OVER_FOUR;\n     * var roll = 0.0;\n     * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, heading, pitch, roll);\n     */\n    Transforms.headingPitchRollQuaternion = function(origin, heading, pitch, roll, ellipsoid, result) {\n        // checks for required parameters happen in the called functions\n        var transform = Transforms.headingPitchRollToFixedFrame(origin, heading, pitch, roll, ellipsoid, scratchENUMatrix4);\n        var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);\n        return Quaternion.fromRotationMatrix(rotation, result);\n    };\n\n\n    var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\n    var gmstConstant1 = 8640184.812866;\n    var gmstConstant2 = 0.093104;\n    var gmstConstant3 = -6.2E-6;\n    var rateCoef = 1.1772758384668e-19;\n    var wgs84WRPrecessing = 7.2921158553E-5;\n    var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;\n    var dateInUtc = new JulianDate();\n\n    /**\n     * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n     * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n     *\n     * @param {JulianDate} date The time at which to compute the rotation matrix.\n     * @param {Matrix3} [result] The object onto which to store the result.\n     * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n     *\n     * @example\n     * //Set the view to in the inertial frame.\n     * scene.preRender.addEventListener(function(scene, time) {\n     *    var now = Cesium.JulianDate.now();\n     *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n     *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n     *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n     *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n     *    camera.lookAtTransform(transform, offset);\n     * });\n     */\n    Transforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(date)) {\n            throw new DeveloperError('date is required.');\n        }\n        //>>includeEnd('debug');\n\n        // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.\n        // We do not want to use the function like convertTaiToUtc in JulianDate because\n        // we explicitly do not want to fail when inside the leap second.\n\n        dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);\n        var utcDayNumber = dateInUtc.dayNumber;\n        var utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n        var t;\n        var diffDays = utcDayNumber - 2451545;\n        if (utcSecondsIntoDay >= 43200.0) {\n            t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n        } else {\n            t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n        }\n\n        var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n        var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;\n        var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n        var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;\n        var gha = angle + (ratio * secondsSinceMidnight);\n        var cosGha = Math.cos(gha);\n        var sinGha = Math.sin(gha);\n\n        if (!defined(result)) {\n            return new Matrix3(cosGha, sinGha, 0.0,\n                              -sinGha, cosGha, 0.0,\n                                  0.0,    0.0, 1.0);\n        }\n        result[0] = cosGha;\n        result[1] = -sinGha;\n        result[2] = 0.0;\n        result[3] = sinGha;\n        result[4] = cosGha;\n        result[5] = 0.0;\n        result[6] = 0.0;\n        result[7] = 0.0;\n        result[8] = 1.0;\n        return result;\n    };\n\n    /**\n     * The source of IAU 2006 XYS data, used for computing the transformation between the\n     * Fixed and ICRF axes.\n     * @type {Iau2006XysData}\n     *\n     * @see Transforms.computeIcrfToFixedMatrix\n     * @see Transforms.computeFixedToIcrfMatrix\n     *\n     * @private\n     */\n    Transforms.iau2006XysData = new Iau2006XysData();\n\n    /**\n     * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n     * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n     * yielding a reasonable but not completely accurate representation of the ICRF axes.\n     * @type {EarthOrientationParameters}\n     *\n     * @see Transforms.computeIcrfToFixedMatrix\n     * @see Transforms.computeFixedToIcrfMatrix\n     *\n     * @private\n     */\n    Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;\n\n    var ttMinusTai = 32.184;\n    var j2000ttDays = 2451545.0;\n\n    /**\n     * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n     * direction, over a given interval.  This function returns a promise that, when resolved,\n     * indicates that the preload has completed.\n     *\n     * @param {TimeInterval} timeInterval The interval to preload.\n     * @returns {Promise.<undefined>} A promise that, when resolved, indicates that the preload has completed\n     *          and evaluation of the transformation between the fixed and ICRF axes will\n     *          no longer return undefined for a time inside the interval.\n     *\n     * @see Transforms.computeIcrfToFixedMatrix\n     * @see Transforms.computeFixedToIcrfMatrix\n     * @see when\n     *\n     * @example\n     * var interval = new Cesium.TimeInterval(...);\n     * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {\n     *     // the data is now loaded\n     * });\n     */\n    Transforms.preloadIcrfFixed = function(timeInterval) {\n        var startDayTT = timeInterval.start.dayNumber;\n        var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n        var stopDayTT = timeInterval.stop.dayNumber;\n        var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n        var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);\n        var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();\n\n        return when.all([xysPromise, eopPromise]);\n    };\n\n    /**\n     * Computes a rotation matrix to transform a point or vector from the International Celestial\n     * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n     * at a given time.  This function may return undefined if the data necessary to\n     * do the transformation is not yet loaded.\n     *\n     * @param {JulianDate} date The time at which to compute the rotation matrix.\n     * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n     *                  not specified, a new instance is created and returned.\n     * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n     *                   transformation is not yet loaded.\n     *\n     * @see Transforms.preloadIcrfFixed\n     *\n     * @example\n     * scene.preRender.addEventListener(function(scene, time) {\n     *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n     *   if (Cesium.defined(icrfToFixed)) {\n     *     var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n     *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed)\n     *     var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n     *     Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n     *     camera.lookAtTransform(transform, offset);\n     *   }\n     * });\n     */\n    Transforms.computeIcrfToFixedMatrix = function(date, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(date)) {\n            throw new DeveloperError('date is required.');\n        }\n        //>>includeEnd('debug');\n        if (!defined(result)) {\n            result = new Matrix3();\n        }\n\n        var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n        if (!defined(fixedToIcrfMtx)) {\n            return undefined;\n        }\n\n        return Matrix3.transpose(fixedToIcrfMtx, result);\n    };\n\n    var xysScratch = new Iau2006XysSample(0.0, 0.0, 0.0);\n    var eopScratch = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    var rotation1Scratch = new Matrix3();\n    var rotation2Scratch = new Matrix3();\n\n    /**\n     * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n     * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n     * at a given time.  This function may return undefined if the data necessary to\n     * do the transformation is not yet loaded.\n     *\n     * @param {JulianDate} date The time at which to compute the rotation matrix.\n     * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n     *                  not specified, a new instance is created and returned.\n     * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n     *                   transformation is not yet loaded.\n     *\n     * @see Transforms.preloadIcrfFixed\n     *\n     * @example\n     * // Transform a point from the ICRF axes to the Fixed axes.\n     * var now = Cesium.JulianDate.now();\n     * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n     * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);\n     * var pointInInertial = new Cesium.Cartesian3();\n     * if (Cesium.defined(fixedToIcrf)) {\n     *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n     * }\n     */\n    Transforms.computeFixedToIcrfMatrix = function(date, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(date)) {\n            throw new DeveloperError('date is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Matrix3();\n        }\n\n        // Compute pole wander\n        var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n        if (!defined(eop)) {\n            return undefined;\n        }\n\n        // There is no external conversion to Terrestrial Time (TT).\n        // So use International Atomic Time (TAI) and convert using offsets.\n        // Here we are assuming that dayTT and secondTT are positive\n        var dayTT = date.dayNumber;\n        // It's possible here that secondTT could roll over 86400\n        // This does not seem to affect the precision (unit tests check for this)\n        var secondTT = date.secondsOfDay + ttMinusTai;\n\n        var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);\n        if (!defined(xys)) {\n            return undefined;\n        }\n\n        var x = xys.x + eop.xPoleOffset;\n        var y = xys.y + eop.yPoleOffset;\n\n        // Compute XYS rotation\n        var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n        var rotation1 = rotation1Scratch;\n        rotation1[0] = 1.0 - a * x * x;\n        rotation1[3] = -a * x * y;\n        rotation1[6] = x;\n        rotation1[1] = -a * x * y;\n        rotation1[4] = 1 - a * y * y;\n        rotation1[7] = y;\n        rotation1[2] = -x;\n        rotation1[5] = -y;\n        rotation1[8] = 1 - a * (x * x + y * y);\n\n        var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);\n        var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);\n\n        // Similar to TT conversions above\n        // It's possible here that secondTT could roll over 86400\n        // This does not seem to affect the precision (unit tests check for this)\n        var dateUt1day = date.dayNumber;\n        var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n        // Compute Earth rotation angle\n        // The IERS standard for era is\n        //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n        // where\n        //    Tu = JulianDateInUt1 - 2451545.0\n        // However, you get much more precision if you make the following simplification\n        //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n        //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n        //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n        // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n        var daysSinceJ2000 = dateUt1day - 2451545;\n        var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;\n        var era = 0.7790572732640 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n        era = (era % 1.0) * CesiumMath.TWO_PI;\n\n        var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);\n\n        // pseudoFixed to ICRF\n        var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n        // Compute pole wander matrix\n        var cosxp = Math.cos(eop.xPoleWander);\n        var cosyp = Math.cos(eop.yPoleWander);\n        var sinxp = Math.sin(eop.xPoleWander);\n        var sinyp = Math.sin(eop.yPoleWander);\n\n        var ttt = (dayTT - j2000ttDays) + secondTT / TimeConstants.SECONDS_PER_DAY;\n        ttt /= 36525.0;\n\n        // approximate sp value in rad\n        var sp = -47.0e-6 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n        var cossp = Math.cos(sp);\n        var sinsp = Math.sin(sp);\n\n        var fToPfMtx = rotation2Scratch;\n        fToPfMtx[0] = cosxp * cossp;\n        fToPfMtx[1] = cosxp * sinsp;\n        fToPfMtx[2] = sinxp;\n        fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n        fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n        fToPfMtx[5] = -sinyp * cosxp;\n        fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n        fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n        fToPfMtx[8] = cosyp * cosxp;\n\n        return Matrix3.multiply(pfToIcrf, fToPfMtx, result);\n    };\n\n    var pointToWindowCoordinatesTemp = new Cartesian4();\n\n    /**\n     * Transform a point from model coordinates to window coordinates.\n     *\n     * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n     * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n     * @param {Cartesian3} point The point to transform.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n     */\n    Transforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {\n        result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);\n        result.y = 2.0 * viewportTransformation[5] - result.y;\n        return result;\n    };\n\n    /**\n     * @private\n     */\n    Transforms.pointToGLWindowCoordinates = function(modelViewProjectionMatrix, viewportTransformation, point, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(modelViewProjectionMatrix)) {\n            throw new DeveloperError('modelViewProjectionMatrix is required.');\n        }\n\n        if (!defined(viewportTransformation)) {\n            throw new DeveloperError('viewportTransformation is required.');\n        }\n\n        if (!defined(point)) {\n            throw new DeveloperError('point is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian2();\n        }\n\n        var tmp = pointToWindowCoordinatesTemp;\n\n        Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);\n        Cartesian4.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n        Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);\n        return Cartesian2.fromCartesian4(tmp, result);\n    };\n\n    var normalScratch = new Cartesian3();\n    var rightScratch = new Cartesian3();\n    var upScratch = new Cartesian3();\n\n    /**\n     * @private\n     */\n    Transforms.rotationMatrixFromPositionVelocity = function(position, velocity, ellipsoid, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(position)) {\n            throw new DeveloperError('position is required.');\n        }\n\n        if (!defined(velocity)) {\n            throw new DeveloperError('velocity is required.');\n        }\n        //>>includeEnd('debug');\n\n        var normal = defaultValue(ellipsoid, Ellipsoid.WGS84).geodeticSurfaceNormal(position, normalScratch);\n        var right = Cartesian3.cross(velocity, normal, rightScratch);\n        if (Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n            right = Cartesian3.clone(Cartesian3.UNIT_X, right);\n        }\n\n        var up = Cartesian3.cross(right, velocity, upScratch);\n        Cartesian3.cross(velocity, up, right);\n        Cartesian3.negate(right, right);\n\n        if (!defined(result)) {\n            result = new Matrix3();\n        }\n\n        result[0] = velocity.x;\n        result[1] = velocity.y;\n        result[2] = velocity.z;\n        result[3] = right.x;\n        result[4] = right.y;\n        result[5] = right.z;\n        result[6] = up.x;\n        result[7] = up.y;\n        result[8] = up.z;\n\n        return result;\n    };\n\n    return Transforms;\n});\n",
    "\n/*global define*/\ndefine('Core/EllipsoidTangentPlane',[\n        './AxisAlignedBoundingBox',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartesian4',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './Ellipsoid',\n        './IntersectionTests',\n        './Matrix3',\n        './Matrix4',\n        './Plane',\n        './Ray',\n        './Transforms'\n    ], function(\n        AxisAlignedBoundingBox,\n        Cartesian2,\n        Cartesian3,\n        Cartesian4,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        IntersectionTests,\n        Matrix3,\n        Matrix4,\n        Plane,\n        Ray,\n        Transforms) {\n    \"use strict\";\n\n    var scratchCart4 = new Cartesian4();\n    /**\n     * A plane tangent to the provided ellipsoid at the provided origin.\n     * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n     * If origin is at the center of the ellipsoid, an exception will be thrown.\n     * @alias EllipsoidTangentPlane\n     * @constructor\n     *\n     * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n     *\n     * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n     */\n    var EllipsoidTangentPlane = function(origin, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin is required.');\n        }\n        //>>includeEnd('debug');\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(origin)) {\n            throw new DeveloperError('origin must not be at the center of the ellipsoid.');\n        }\n        //>>includeEnd('debug');\n\n        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n        this._ellipsoid = ellipsoid;\n        this._origin = origin;\n        this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));\n        this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));\n\n        var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));\n        this._plane = Plane.fromPointNormal(origin, normal);\n    };\n\n    defineProperties(EllipsoidTangentPlane.prototype, {\n        /**\n         * Gets the ellipsoid.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @type {Ellipsoid}\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        },\n\n        /**\n         * Gets the origin.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @type {Cartesian3}\n         */\n        origin : {\n            get : function() {\n                return this._origin;\n            }\n        },\n\n        /**\n         * Gets the plane which is tangent to the ellipsoid.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Plane}\n         */\n        plane : {\n            get : function() {\n                return this._plane;\n            }\n        },\n\n        /**\n         * Gets the local X-axis (east) of the tangent plane.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        xAxis : {\n            get : function() {\n                return this._xAxis;\n            }\n        },\n\n        /**\n         * Gets the local Y-axis (north) of the tangent plane.\n         * @memberof EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        yAxis : {\n            get : function() {\n                return this._yAxis;\n            }\n        },\n\n        /**\n         * Gets the local Z-axis (up) of the tangent plane.\n         * @member EllipsoidTangentPlane.prototype\n         * @readonly\n         * @type {Cartesian3}\n         */\n        zAxis : {\n            get : function() {\n                return this._plane.normal;\n            }\n        }\n    });\n\n    var tmp = new AxisAlignedBoundingBox();\n    /**\n     * Creates a new instance from the provided ellipsoid and the center\n     * point of the provided Cartesians.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid to use.\n     * @param {Cartesian3} cartesians The list of positions surrounding the center point.\n     */\n    EllipsoidTangentPlane.fromPoints = function(cartesians, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesians)) {\n            throw new DeveloperError('cartesians is required.');\n        }\n        //>>includeEnd('debug');\n\n        var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n        return new EllipsoidTangentPlane(box.center, ellipsoid);\n    };\n\n    var scratchProjectPointOntoPlaneRay = new Ray();\n    var scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n    /**\n     * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n     *\n     * @param {Cartesian3} cartesian The point to project.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n     */\n    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        //>>includeEnd('debug');\n\n        var ray = scratchProjectPointOntoPlaneRay;\n        ray.origin = cartesian;\n        Cartesian3.normalize(cartesian, ray.direction);\n\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        if (!defined(intersectionPoint)) {\n            Cartesian3.negate(ray.direction, ray.direction);\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        }\n\n        if (defined(intersectionPoint)) {\n            var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n            var x = Cartesian3.dot(this._xAxis, v);\n            var y = Cartesian3.dot(this._yAxis, v);\n\n            if (!defined(result)) {\n                return new Cartesian2(x, y);\n            }\n            result.x = x;\n            result.y = y;\n            return result;\n        }\n        return undefined;\n    };\n\n    /**\n     * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n     * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n     *\n     * @see EllipsoidTangentPlane.projectPointOntoPlane\n     *\n     * @param {Cartesian3[]} cartesians The array of points to project.\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesians)) {\n            throw new DeveloperError('cartesians is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var count = 0;\n        var length = cartesians.length;\n        for ( var i = 0; i < length; i++) {\n            var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n            if (defined(p)) {\n                result[count] = p;\n                count++;\n            }\n        }\n        result.length = count;\n        return result;\n    };\n\n    /**\n     * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n     *\n     * @param {Cartesian3} cartesian The point to project.\n     * @param {Cartesian2} [result] The object onto which to store the result.\n     * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function(cartesian, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesian)) {\n            throw new DeveloperError('cartesian is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = new Cartesian2();\n        }\n\n        var ray = scratchProjectPointOntoPlaneRay;\n        ray.origin = cartesian;\n        Cartesian3.clone(this._plane.normal, ray.direction);\n\n        var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        if (!defined(intersectionPoint)) {\n            Cartesian3.negate(ray.direction, ray.direction);\n            intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, scratchProjectPointOntoPlaneCartesian3);\n        }\n\n        var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);\n        var x = Cartesian3.dot(this._xAxis, v);\n        var y = Cartesian3.dot(this._yAxis, v);\n\n        result.x = x;\n        result.y = y;\n        return result;\n    };\n\n    /**\n     * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n     *\n     * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n     *\n     * @param {Cartesian3[]} cartesians The array of points to project.\n     * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n     * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesians)) {\n            throw new DeveloperError('cartesians is required.');\n        }\n        //>>includeEnd('debug');\n\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = cartesians.length;\n        result.length = length;\n        for (var i = 0; i < length; i++) {\n            result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n        }\n        return result;\n    };\n\n    var projectPointsOntoEllipsoidScratch = new Cartesian3();\n    /**\n     * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n     *\n     * @param {Cartesian2[]} cartesians The array of points to project.\n     * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n     * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n     */\n    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(cartesians, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(cartesians)) {\n            throw new DeveloperError('cartesians is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = cartesians.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        } else {\n            result.length = length;\n        }\n\n        var ellipsoid = this._ellipsoid;\n        var origin = this._origin;\n        var xAxis = this._xAxis;\n        var yAxis = this._yAxis;\n        var tmp = projectPointsOntoEllipsoidScratch;\n\n        for ( var i = 0; i < length; ++i) {\n            var position = cartesians[i];\n            Cartesian3.multiplyByScalar(xAxis, position.x, tmp);\n            if (!defined(result[i])) {\n                result[i] = new Cartesian3();\n            }\n            var point = Cartesian3.add(origin, tmp, result[i]);\n            Cartesian3.multiplyByScalar(yAxis, position.y, tmp);\n            Cartesian3.add(point, tmp, point);\n            ellipsoid.scaleToGeocentricSurface(point, point);\n        }\n\n        return result;\n    };\n\n    return EllipsoidTangentPlane;\n});\n",
    "\n/*global define*/\ndefine('Core/pointInsideTriangle',[\n        './barycentricCoordinates',\n        './Cartesian3'\n    ], function(\n        barycentricCoordinates,\n        Cartesian3) {\n    \"use strict\";\n\n    var coords = new Cartesian3();\n\n    /**\n     * Determines if a point is inside a triangle.\n     *\n     * @exports pointInsideTriangle\n     *\n     * @param {Cartesian2|Cartesian3} point The point to test.\n     * @param {Cartesian2|Cartesian3} p0 The first point of the triangle.\n     * @param {Cartesian2|Cartesian3} p1 The second point of the triangle.\n     * @param {Cartesian2|Cartesian3} p2 The third point of the triangle.\n     * @returns {Boolean} <code>true</code> if the point is inside the triangle; otherwise, <code>false</code>.\n     *\n     * @example\n     * // Returns true\n     * var p = new Cesium.Cartesian2(0.25, 0.25);\n     * var b = Cesium.pointInsideTriangle(p,\n     *   new Cesium.Cartesian2(0.0, 0.0),\n     *   new Cesium.Cartesian2(1.0, 0.0),\n     *   new Cesium.Cartesian2(0.0, 1.0));\n     */\n    var pointInsideTriangle = function(point, p0, p1, p2) {\n        barycentricCoordinates(point, p0, p1, p2, coords);\n        return (coords.x > 0.0) && (coords.y > 0.0) && (coords.z > 0);\n    };\n\n    return pointInsideTriangle;\n});\n",
    "\n/*global define*/\ndefine('Core/EllipsoidGeodesic',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './Ellipsoid',\n        './Math'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        CesiumMath) {\n    \"use strict\";\n\n    function setConstants(ellipsoidGeodesic) {\n        var uSquared = ellipsoidGeodesic._uSquared;\n        var a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n        var b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n        var f = (a - b) / a;\n\n        var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n        var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n        var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n        var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n        var sineU = cosineU * tanU;\n\n        var sigma = Math.atan2(tanU, cosineHeading);\n\n        var sineAlpha = cosineU * sineHeading;\n        var sineSquaredAlpha = sineAlpha * sineAlpha;\n\n        var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n        var cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n        var u2Over4 = uSquared / 4.0;\n        var u4Over16 = u2Over4 * u2Over4;\n        var u6Over64 = u4Over16 * u2Over4;\n        var u8Over256 = u4Over16 * u4Over16;\n\n        var a0 = (1.0 + u2Over4 - 3.0 * u4Over16 / 4.0 + 5.0 * u6Over64 / 4.0 - 175.0 * u8Over256 / 64.0);\n        var a1 = (1.0 - u2Over4 + 15.0 * u4Over16 / 8.0 - 35.0 * u6Over64 / 8.0);\n        var a2 = (1.0 - 3.0 * u2Over4 + 35.0 * u4Over16 / 4.0);\n        var a3 = (1.0 - 5.0 * u2Over4);\n\n        var distanceRatio = a0 * sigma - a1 * Math.sin(2.0 * sigma) * u2Over4 / 2.0 - a2 * Math.sin(4.0 * sigma) * u4Over16 / 16.0 -\n                            a3 * Math.sin(6.0 * sigma) * u6Over64 / 48.0 - Math.sin(8.0 * sigma) * 5.0 * u8Over256 / 512;\n\n        var constants = ellipsoidGeodesic._constants;\n\n        constants.a = a;\n        constants.b = b;\n        constants.f = f;\n        constants.cosineHeading = cosineHeading;\n        constants.sineHeading = sineHeading;\n        constants.tanU = tanU;\n        constants.cosineU = cosineU;\n        constants.sineU = sineU;\n        constants.sigma = sigma;\n        constants.sineAlpha = sineAlpha;\n        constants.sineSquaredAlpha = sineSquaredAlpha;\n        constants.cosineSquaredAlpha = cosineSquaredAlpha;\n        constants.cosineAlpha = cosineAlpha;\n        constants.u2Over4 = u2Over4;\n        constants.u4Over16 = u4Over16;\n        constants.u6Over64 = u6Over64;\n        constants.u8Over256 = u8Over256;\n        constants.a0 = a0;\n        constants.a1 = a1;\n        constants.a2 = a2;\n        constants.a3 = a3;\n        constants.distanceRatio = distanceRatio;\n    }\n\n    function computeC(f, cosineSquaredAlpha) {\n        return f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha)) / 16.0;\n    }\n\n    function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {\n        var C = computeC(f, cosineSquaredAlpha);\n\n        return (1.0 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint +\n                C * cosineSigma * (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)));\n    }\n\n    function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {\n        var eff = (major - minor) / major;\n        var l = secondLongitude - firstLongitude;\n\n        var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n        var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n        var cosineU1 = Math.cos(u1);\n        var sineU1 = Math.sin(u1);\n        var cosineU2 = Math.cos(u2);\n        var sineU2 = Math.sin(u2);\n\n        var cc = cosineU1 * cosineU2;\n        var cs = cosineU1 * sineU2;\n        var ss = sineU1 * sineU2;\n        var sc = sineU1 * cosineU2;\n\n        var lambda = l;\n        var lambdaDot = CesiumMath.TWO_PI;\n\n        var cosineLambda = Math.cos(lambda);\n        var sineLambda = Math.sin(lambda);\n\n        var sigma;\n        var cosineSigma;\n        var sineSigma;\n        var cosineSquaredAlpha;\n        var cosineTwiceSigmaMidpoint;\n\n        do {\n            cosineLambda = Math.cos(lambda);\n            sineLambda = Math.sin(lambda);\n\n            var temp = cs - sc * cosineLambda;\n            sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);\n            cosineSigma = ss + cc * cosineLambda;\n\n            sigma = Math.atan2(sineSigma, cosineSigma);\n\n            var sineAlpha;\n\n            if (sineSigma === 0.0) {\n                sineAlpha = 0.0;\n                cosineSquaredAlpha = 1.0;\n            } else {\n                sineAlpha = cc * sineLambda / sineSigma;\n                cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n            }\n\n            lambdaDot = lambda;\n\n            cosineTwiceSigmaMidpoint = cosineSigma - 2.0 * ss / cosineSquaredAlpha;\n\n            if (isNaN(cosineTwiceSigmaMidpoint)) {\n                cosineTwiceSigmaMidpoint = 0.0;\n            }\n\n            lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha,\n                                            sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n        } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n        var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);\n        var A = 1.0 + uSquared * (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0)) / 16384.0;\n        var B = uSquared * (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0)) / 1024.0;\n\n        var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n        var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma *\n                (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) - B * cosineTwiceSigmaMidpoint *\n                (4.0 * sineSigma * sineSigma - 3.0) * (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0) / 6.0) / 4.0);\n\n        var distance = minor * A * (sigma - deltaSigma);\n\n        var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\n        var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n        ellipsoidGeodesic._distance = distance;\n        ellipsoidGeodesic._startHeading = startHeading;\n        ellipsoidGeodesic._endHeading = endHeading;\n        ellipsoidGeodesic._uSquared = uSquared;\n    }\n\n    function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n        var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);\n        var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI) < 0.0125) {\n            throw new DeveloperError('geodesic position is not unique');\n        }\n        //>>includeEnd('debug');\n\n        vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius,\n                               start.longitude, start.latitude, end.longitude, end.latitude);\n\n        ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);\n        ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n        ellipsoidGeodesic._start.height = 0;\n        ellipsoidGeodesic._end.height = 0;\n\n        setConstants(ellipsoidGeodesic);\n    }\n\n    var scratchCart1 = new Cartesian3();\n    var scratchCart2 = new Cartesian3();\n    /**\n     * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n     *\n     * @alias EllipsoidGeodesic\n     * @constructor\n     *\n     * @param {Cartographic} [start] The initial planetodetic point on the path.\n     * @param {Cartographic} [end] The final planetodetic point on the path.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n     */\n    var EllipsoidGeodesic = function(start, end, ellipsoid) {\n        var e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n        this._ellipsoid = e;\n        this._start = new Cartographic();\n        this._end = new Cartographic();\n\n        this._constants = {};\n        this._startHeading = undefined;\n        this._endHeading = undefined;\n        this._distance = undefined;\n        this._uSquared = undefined;\n\n        if (defined(start) && defined(end)) {\n            computeProperties(this, start, end, e);\n        }\n    };\n\n    defineProperties(EllipsoidGeodesic.prototype, {\n        /**\n         * Gets the ellipsoid.\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Ellipsoid}\n         * @readonly\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            }\n        },\n\n        /**\n         * Gets the surface distance between the start and end point\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Number}\n         * @readonly\n         */\n        surfaceDistance : {\n            get : function() {\n                //>>includeStart('debug', pragmas.debug);\n                if (!defined(this._distance)) {\n                    throw new DeveloperError('set end positions before getting surfaceDistance');\n                }\n                //>>includeEnd('debug');\n\n                return this._distance;\n            }\n        },\n\n        /**\n         * Gets the initial planetodetic point on the path.\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Cartographic}\n         * @readonly\n         */\n        start : {\n            get : function() {\n                return this._start;\n            }\n        },\n\n        /**\n         * Gets the final planetodetic point on the path.\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Cartographic}\n         * @readonly\n         */\n        end : {\n            get : function() {\n                return this._end;\n            }\n        },\n\n        /**\n         * Gets the heading at the initial point.\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Number}\n         * @readonly\n         */\n        startHeading : {\n            get : function() {\n                //>>includeStart('debug', pragmas.debug);\n                if (!defined(this._distance)) {\n                    throw new DeveloperError('set end positions before getting startHeading');\n                }\n                //>>includeEnd('debug');\n\n                return this._startHeading;\n            }\n        },\n\n        /**\n         * Gets the heading at the final point.\n         * @memberof EllipsoidGeodesic.prototype\n         * @type {Number}\n         * @readonly\n         */\n        endHeading : {\n            get : function() {\n                //>>includeStart('debug', pragmas.debug);\n                if (!defined(this._distance)) {\n                    throw new DeveloperError('set end positions before getting endHeading');\n                }\n                //>>includeEnd('debug');\n\n                return this._endHeading;\n            }\n        }\n    });\n\n    /**\n     * Sets the start and end points of the geodesic\n     *\n     * @param {Cartographic} start The initial planetodetic point on the path.\n     * @param {Cartographic} end The final planetodetic point on the path.\n     */\n    EllipsoidGeodesic.prototype.setEndPoints = function(start, end) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(start)) {\n            throw new DeveloperError('start cartographic position is required');\n        }\n        if (!defined(end)) {\n            throw new DeveloperError('end cartgraphic position is required');\n        }\n        //>>includeEnd('debug');\n\n        computeProperties(this, start, end, this._ellipsoid);\n    };\n\n    /**\n     * Provides the location of a point at the indicated portion along the geodesic.\n     *\n     * @param {Number} fraction The portion of the distance between the initial and final points.\n     * @returns {Cartographic} The location of the point along the geodesic.\n     */\n    EllipsoidGeodesic.prototype.interpolateUsingFraction = function(fraction, result) {\n        return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);\n    };\n\n    /**\n     * Provides the location of a point at the indicated distance along the geodesic.\n     *\n     * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n     * @returns {Cartographic} The location of the point along the geodesic.\n     *\n     * @exception {DeveloperError} start and end must be set before calling funciton interpolateUsingSurfaceDistance\n     */\n    EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function(distance, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(this._distance)) {\n            throw new DeveloperError('start and end must be set before calling funciton interpolateUsingSurfaceDistance');\n        }\n        //>>includeEnd('debug');\n\n        var constants = this._constants;\n\n        var s = constants.distanceRatio + distance / constants.b;\n\n        var cosine2S = Math.cos(2.0 * s);\n        var cosine4S = Math.cos(4.0 * s);\n        var cosine6S = Math.cos(6.0 * s);\n        var sine2S = Math.sin(2.0 * s);\n        var sine4S = Math.sin(4.0 * s);\n        var sine6S = Math.sin(6.0 * s);\n        var sine8S = Math.sin(8.0 * s);\n\n        var s2 = s * s;\n        var s3 = s * s2;\n\n        var u8Over256 = constants.u8Over256;\n        var u2Over4 = constants.u2Over4;\n        var u6Over64 = constants.u6Over64;\n        var u4Over16 = constants.u4Over16;\n        var sigma = 2.0 * s3 * u8Over256 * cosine2S / 3.0 +\n            s * (1.0 - u2Over4 + 7.0 * u4Over16 / 4.0 - 15.0 * u6Over64 / 4.0 + 579.0 * u8Over256 / 64.0 -\n            (u4Over16 - 15.0 * u6Over64 / 4.0 + 187.0 * u8Over256 / 16.0) * cosine2S -\n            (5.0 * u6Over64 / 4.0 - 115.0 * u8Over256 / 16.0) * cosine4S -\n            29.0 * u8Over256 * cosine6S / 16.0) +\n            (u2Over4 / 2.0 - u4Over16 + 71.0 * u6Over64 / 32.0 - 85.0 * u8Over256 / 16.0) * sine2S +\n            (5.0 * u4Over16 / 16.0 - 5.0 * u6Over64 / 4.0 + 383.0 * u8Over256 / 96.0) * sine4S -\n            s2 * ((u6Over64 - 11.0 * u8Over256 / 2.0) * sine2S + 5.0 * u8Over256 * sine4S / 2.0) +\n            (29.0 * u6Over64 / 96.0 - 29.0 * u8Over256 / 16.0) * sine6S +\n            539.0 * u8Over256 * sine8S / 1536.0;\n\n        var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n        var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));\n\n        // Redefine in terms of relative argument of latitude.\n        sigma = sigma - constants.sigma;\n\n        var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n        var sineSigma = Math.sin(sigma);\n        var cosineSigma = Math.cos(sigma);\n\n        var cc = constants.cosineU * cosineSigma;\n        var ss = constants.sineU * sineSigma;\n\n        var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);\n\n        var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha,\n                                            sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);\n\n        if (defined(result)) {\n            result.longitude = this._start.longitude + l;\n            result.latitude = latitude;\n            result.height = 0.0;\n            return result;\n        }\n\n        return new Cartographic(this._start.longitude + l, latitude, 0.0);\n    };\n\n    return EllipsoidGeodesic;\n});\n",
    "\n/*global define*/\ndefine('Core/isArray',[\n        './defined'\n    ], function(\n        defined) {\n    \"use strict\";\n\n    /**\n     * Tests an object to see if it is an array.\n     * @exports isArray\n     *\n     * @param {Object} value The value to test.\n     * @returns {Boolean} true if the value is an array, false otherwise.\n     */\n    var isArray = Array.isArray;\n    if (!defined(isArray)) {\n        isArray = function(value) {\n            return Object.prototype.toString.call(value) === '[object Array]';\n        };\n    }\n\n    return isArray;\n});",
    "\n/*global define*/\ndefine('Core/PolylinePipeline',[\n        './Cartesian3',\n        './Cartographic',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './EllipsoidGeodesic',\n        './IntersectionTests',\n        './isArray',\n        './Math',\n        './Matrix4',\n        './Plane'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        EllipsoidGeodesic,\n        IntersectionTests,\n        isArray,\n        CesiumMath,\n        Matrix4,\n        Plane) {\n    \"use strict\";\n\n    /**\n     * @private\n     */\n    var PolylinePipeline = {};\n\n    PolylinePipeline.numberOfPoints = function(p0, p1, minDistance) {\n        var distance = Cartesian3.distance(p0, p1);\n        return Math.ceil(distance / minDistance);\n    };\n\n    var cartoScratch = new Cartographic();\n    PolylinePipeline.extractHeights = function(positions, ellipsoid) {\n        var length = positions.length;\n        var heights = new Array(length);\n        for (var i = 0; i < length; i++) {\n            var p = positions[i];\n            heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n        }\n        return heights;\n    };\n\n    var wrapLongitudeInversMatrix = new Matrix4();\n    var wrapLongitudeOrigin = new Cartesian3();\n    var wrapLongitudeXZNormal = new Cartesian3();\n    var wrapLongitudeXZPlane = new Plane(Cartesian3.ZERO, 0.0);\n    var wrapLongitudeYZNormal = new Cartesian3();\n    var wrapLongitudeYZPlane = new Plane(Cartesian3.ZERO, 0.0);\n    var wrapLongitudeIntersection = new Cartesian3();\n    var wrapLongitudeOffset = new Cartesian3();\n\n    var subdivideHeightsScratchArray = [];\n\n    function subdivideHeights(numPoints, h0, h1) {\n        var heights = subdivideHeightsScratchArray;\n        heights.length = numPoints;\n\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            var h = h0 + i*heightPerVertex;\n            heights[i] = h;\n        }\n\n        return heights;\n    }\n\n    var carto1 = new Cartographic();\n    var carto2 = new Cartographic();\n    var cartesian = new Cartesian3();\n    var scaleFirst = new Cartesian3();\n    var scaleLast = new Cartesian3();\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n\n    //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n    //Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n    //and this prevents duplication of end point.\n    function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\n        var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n        var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n        var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n        var start = ellipsoid.cartesianToCartographic(first, carto1);\n        var end = ellipsoid.cartesianToCartographic(last, carto2);\n        var heights = subdivideHeights(numPoints, h0, h1);\n\n        ellipsoidGeodesic.setEndPoints(start, end);\n        var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\n\n        var index = offset;\n        start.height = h0;\n        var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n        Cartesian3.pack(cart, array, index);\n        index += 3;\n\n        for (var i = 1; i < numPoints; i++) {\n            var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n            carto.height = heights[i];\n            cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n            Cartesian3.pack(cart, array, index);\n            index += 3;\n        }\n\n        return index;\n    }\n\n    /**\n     * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n     *\n     * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n     * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n     * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n     * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n     * The matrix is not verified to be in the proper form.\n     * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n     * <code>segments</code> property.\n     *\n     * @see PolygonPipeline.wrapLongitude\n     * @see Polyline\n     * @see PolylineCollection\n     *\n     * @example\n     * var polylines = new Cesium.PolylineCollection();\n     * var polyline = polylines.add(...);\n     * var positions = polyline.positions;\n     * var modelMatrix = polylines.modelMatrix;\n     * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n     */\n    PolylinePipeline.wrapLongitude = function(positions, modelMatrix) {\n        var cartesians = [];\n        var segments = [];\n\n        if (defined(positions) && positions.length > 0) {\n            modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n            var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\n\n            var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\n            var xzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal);\n            var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n            var yzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal);\n            var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n\n            var count = 1;\n            cartesians.push(Cartesian3.clone(positions[0]));\n            var prev = cartesians[0];\n\n            var length = positions.length;\n            for (var i = 1; i < length; ++i) {\n                var cur = positions[i];\n\n                // intersects the IDL if either endpoint is on the negative side of the yz-plane\n                if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\n                    // and intersects the xz-plane\n                    var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\n                    if (defined(intersection)) {\n                        // move point on the xz-plane slightly away from the plane\n                        var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\n                        if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n                            Cartesian3.negate(offset, offset);\n                        }\n\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        segments.push(count + 1);\n\n                        Cartesian3.negate(offset, offset);\n                        cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n                        count = 1;\n                    }\n                }\n\n                cartesians.push(Cartesian3.clone(positions[i]));\n                count++;\n\n                prev = cur;\n            }\n\n            segments.push(count);\n        }\n\n        return {\n            positions : cartesians,\n            lengths : segments\n        };\n    };\n\n    var removeDuplicatesEpsilon = CesiumMath.EPSILON7;\n\n    /**\n     * Removes adjacent duplicate positions in an array of positions.\n     *\n     * @param {Cartesian3[]} positions The array of positions.\n     * @returns {Cartesian3[]|undefined} A new array of positions with no adjacent duplicate positions or the input array if no duplicates were found.\n     *\n     * @example\n     * // Returns [(1.0, 1.0, 1.0), (2.0, 2.0, 2.0)]\n     * var positions = [\n     *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n     *     new Cesium.Cartesian3(1.0, 1.0, 1.0),\n     *     new Cesium.Cartesian3(2.0, 2.0, 2.0)];\n     * var nonDuplicatePositions = Cesium.PolylinePipeline.removeDuplicates(positions);\n     */\n    PolylinePipeline.removeDuplicates = function(positions) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        if (length < 2) {\n            return positions;\n        }\n\n        var i;\n        var v0;\n        var v1;\n\n        for (i = 1; i < length; ++i) {\n            v0 = positions[i - 1];\n            v1 = positions[i];\n            if (Cartesian3.equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n                break;\n            }\n        }\n\n        if (i === length) {\n            return positions;\n        }\n\n        var cleanedPositions = positions.slice(0, i);\n        for (; i < length; ++i) {\n            // v0 is set by either the previous loop, or the previous clean point.\n            v1 = positions[i];\n            if (!Cartesian3.equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {\n                cleanedPositions.push(Cartesian3.clone(v1));\n                v0 = v1;\n            }\n        }\n\n        return cleanedPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n     * @param {Cartesian3[]} positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateArc = function(options) {\n        if (!defined(options)) {\n            options = {};\n        }\n        var positions = options.positions;\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('options.positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var height = defaultValue(options.height, 0);\n\n        if (length < 1) {\n            return [];\n        } else if (length === 1) {\n            var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n            if (height !== 0) {\n                var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n            }\n\n            return [p.x, p.y, p.z];\n        }\n\n        var minDistance = options.minDistance;\n        if (!defined(minDistance)) {\n            var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n            minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        }\n\n        var numPoints = 0;\n        var i;\n\n        for (i = 0; i < length -1; i++) {\n            numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i+1], minDistance);\n        }\n\n        var arrayLength = (numPoints + 1) * 3;\n        var newPositions = new Array(arrayLength);\n        var offset = 0;\n        var hasHeightArray = isArray(height);\n\n        for (i = 0; i < length - 1; i++) {\n            var p0 = positions[i];\n            var p1 = positions[i + 1];\n\n            var h0 = hasHeightArray ? height[i] : height;\n            var h1 = hasHeightArray ? height[i + 1] : height;\n\n            offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\n        }\n\n        subdivideHeightsScratchArray.length = 0;\n\n        var lastPoint = positions[length - 1];\n        var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n        carto.height = hasHeightArray ? height[length - 1] : height;\n        var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n        Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n        return newPositions;\n    };\n\n    /**\n     * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n     * @param {Cartesian3[]} positions The array of type {Cartesian3} representing positions.\n     * @param {Number|Number[]} [height=0.0] A number or array of numbers representing the heights of each position.\n     * @param {Number} [granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n     *\n     * @example\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\n     *   -105.0, 40.0,\n     *   -100.0, 38.0,\n     *   -105.0, 35.0,\n     *   -100.0, 32.0\n     * ]);\n     * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n     *   positons: positions\n     * });\n     */\n    PolylinePipeline.generateCartesianArc = function(options) {\n        var numberArray = PolylinePipeline.generateArc(options);\n        var size = numberArray.length/3;\n        var newPositions = new Array(size);\n        for (var i = 0; i < size; i++) {\n            newPositions[i] = Cartesian3.unpack(numberArray, i*3);\n        }\n        return newPositions;\n    };\n\n    return PolylinePipeline;\n});\n",
    "\n/*global define*/\ndefine('Core/Queue',[],function() {\n    \"use strict\";\n\n    /**\n     * A queue that can enqueue items at the end, and dequeue items from the front.\n     *\n     * @alias Queue\n     * @constructor\n     */\n    var Queue = function() {\n        this._array = [];\n        this._offset = 0;\n\n        /**\n         * The length of the queue.\n         * @type {Number}\n         */\n        this.length = 0;\n    };\n\n    /**\n     * Enqueues the specified item.\n     *\n     * @param {Object} item The item to enqueue.\n     */\n    Queue.prototype.enqueue = function(item) {\n        this._array.push(item);\n        this.length++;\n    };\n\n    /**\n     * Dequeues an item.  Returns undefined if the queue is empty.\n     */\n    Queue.prototype.dequeue = function() {\n        if (this.length === 0) {\n            return undefined;\n        }\n\n        var array = this._array;\n        var offset = this._offset;\n        var item = array[offset];\n        array[offset] = undefined;\n\n        offset++;\n        if (offset > 10 && offset * 2 > array.length) {\n            //compact array\n            this._array = array.slice(offset);\n            offset = 0;\n        }\n\n        this._offset = offset;\n        this.length--;\n\n        return item;\n    };\n\n    /**\n     * Check whether this queue contains the specified item.\n     *\n     * @param {Object} item the item to search for.\n     */\n    Queue.prototype.contains = function(item) {\n        return this._array.indexOf(item) !== -1;\n    };\n\n    /**\n     * Remove all items from the queue.\n     */\n    Queue.prototype.clear = function() {\n        this._array.length = this._offset = this.length = 0;\n    };\n\n    /**\n     * Sort the items in the queue in-place.\n     *\n     * @param {Queue~Comparator} compareFunction A function that defines the sort order.\n     */\n    Queue.prototype.sort = function(compareFunction) {\n        if (this._offset > 0) {\n            //compact array\n            this._array = this._array.slice(this._offset);\n            this._offset = 0;\n        }\n\n        this._array.sort(compareFunction);\n    };\n\n    /**\n     * A function used to compare two items while sorting a queue.\n     * @callback Queue~Comparator\n     *\n     * @param {Object} a An item in the array.\n     * @param {Object} b An item in the array.\n     * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n     *          a positive value if <code>a</code> is greater than <code>b</code>, or\n     *          0 if <code>a</code> is equal to <code>b</code>.\n     *\n     * @example\n     * function compareNumbers(a, b) {\n     *     return a - b;\n     * }\n     */\n\n    return Queue;\n});",
    "\n/*global define*/\ndefine('Core/WindingOrder',[\n        '../Renderer/WebGLConstants',\n        './freezeObject'\n    ], function(\n        WebGLConstants,\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * Winding order defines the order of vertices for a triangle to be considered front-facing.\n     *\n     * @namespace\n     * @alias WindingOrder\n     */\n    var WindingOrder = {\n        /**\n         * Vertices are in clockwise order.\n         *\n         * @type {Number}\n         * @constant\n         */\n        CLOCKWISE : WebGLConstants.CW,\n\n        /**\n         * Vertices are in counter-clockwise order.\n         *\n         * @type {Number}\n         * @constant\n         */\n        COUNTER_CLOCKWISE : WebGLConstants.CCW,\n\n        /**\n         * @private\n         */\n        validate : function(windingOrder) {\n            return windingOrder === WindingOrder.CLOCKWISE ||\n                   windingOrder === WindingOrder.COUNTER_CLOCKWISE;\n        }\n    };\n\n    return freezeObject(WindingOrder);\n});",
    "\n/*global define*/\ndefine('Core/PolygonPipeline',[\n        './Cartesian2',\n        './Cartesian3',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './EllipsoidTangentPlane',\n        './Geometry',\n        './GeometryAttribute',\n        './Math',\n        './pointInsideTriangle',\n        './PolylinePipeline',\n        './PrimitiveType',\n        './Queue',\n        './WindingOrder'\n    ], function(\n        Cartesian2,\n        Cartesian3,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        EllipsoidTangentPlane,\n        Geometry,\n        GeometryAttribute,\n        CesiumMath,\n        pointInsideTriangle,\n        PolylinePipeline,\n        PrimitiveType,\n        Queue,\n        WindingOrder) {\n    \"use strict\";\n\n    var uScratch = new Cartesian2();\n    var vScratch = new Cartesian2();\n    function isTipConvex(p0, p1, p2) {\n        var u = Cartesian2.subtract(p1, p0, uScratch);\n        var v = Cartesian2.subtract(p2, p1, vScratch);\n\n        // Use the sign of the z component of the cross product\n        return ((u.x * v.y) - (u.y * v.x)) >= 0.0;\n    }\n\n    /**\n     * Returns the index of the vertex with the maximum X value.\n     *\n     * @param {Cartesian2[]} positions An array of the Cartesian points defining the polygon's vertices.\n     * @returns {Number} The index of the positions with the maximum X value.\n     *\n     * @private\n     */\n    function getRightmostPositionIndex(positions) {\n        var maximumX = positions[0].x;\n        var rightmostPositionIndex = 0;\n        for ( var i = 0; i < positions.length; i++) {\n            if (positions[i].x > maximumX) {\n                maximumX = positions[i].x;\n                rightmostPositionIndex = i;\n            }\n        }\n        return rightmostPositionIndex;\n    }\n\n    /**\n     * Returns the index of the ring that contains the rightmost vertex.\n     *\n     * @param {Cartesian2[]} rings An array of arrays of Cartesians. Each array contains the vertices defining a polygon.\n     * @returns {Number} The index of the ring containing the rightmost vertex.\n     *\n     * @private\n     */\n    function getRightmostRingIndex(rings) {\n        var rightmostX = rings[0][0].x;\n        var rightmostRingIndex = 0;\n        for ( var ring = 0; ring < rings.length; ring++) {\n            var maximumX = rings[ring][getRightmostPositionIndex(rings[ring])].x;\n            if (maximumX > rightmostX) {\n                rightmostX = maximumX;\n                rightmostRingIndex = ring;\n            }\n        }\n\n        return rightmostRingIndex;\n    }\n\n    /**\n     * Returns a list containing the reflex vertices for a given polygon.\n     *\n     * @param {Cartesian2[]} polygon An array of Cartesian elements defining the polygon.\n     * @returns {Cartesian2[]}\n     *\n     * @private\n     */\n    function getReflexVertices(polygon) {\n        var reflexVertices = [];\n        for ( var i = 0; i < polygon.length; i++) {\n            var p0 = polygon[((i - 1) + polygon.length) % polygon.length];\n            var p1 = polygon[i];\n            var p2 = polygon[(i + 1) % polygon.length];\n\n            if (!isTipConvex(p0, p1, p2)) {\n                reflexVertices.push(p1);\n            }\n        }\n        return reflexVertices;\n    }\n\n    /**\n     * Returns true if the given point is contained in the list of positions.\n     *\n     * @param {Cartesian2[]} positions A list of Cartesian elements defining a polygon.\n     * @param {Cartesian2} point The point to check.\n     * @returns {Number} The index of <code>point</code> in <code>positions</code> or -1 if it was not found.\n     *\n     * @private\n     */\n    function isVertex(positions, point) {\n        for ( var i = 0; i < positions.length; i++) {\n            if (Cartesian2.equals(point, positions[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Given a point inside a polygon, find the nearest point directly to the right that lies on one of the polygon's edges.\n     *\n     * @param {Cartesian2} point A point inside the polygon defined by <code>ring</code>.\n     * @param {Cartesian2[]} ring A list of Cartesian points defining a polygon.\n     * @param {Number[]} [edgeIndices]  An array containing the indices two endpoints of the edge containing the intersection.\n     * @returns {Cartesian2} The intersection point.\n     *\n     * @private\n     */\n    var distScratch = new Cartesian2();\n    function intersectPointWithRing(point, ring, edgeIndices) {\n        edgeIndices = defaultValue(edgeIndices, []);\n\n        var minDistance = Number.MAX_VALUE;\n        var rightmostVertexIndex = getRightmostPositionIndex(ring);\n        var intersection = new Cartesian2(ring[rightmostVertexIndex].x, point.y);\n        edgeIndices.push(rightmostVertexIndex);\n        edgeIndices.push((rightmostVertexIndex + 1) % ring.length);\n\n        var boundaryMinX = ring[0].x;\n        var boundaryMaxX = boundaryMinX;\n        for ( var i = 1; i < ring.length; ++i) {\n            if (ring[i].x < boundaryMinX) {\n                boundaryMinX = ring[i].x;\n            } else if (ring[i].x > boundaryMaxX) {\n                boundaryMaxX = ring[i].x;\n            }\n        }\n        boundaryMaxX += (boundaryMaxX - boundaryMinX);\n        var point2 = new Cartesian3(boundaryMaxX, point.y, 0.0);\n\n        // Find the nearest intersection.\n        for (i = 0; i < ring.length; i++) {\n            var v1 = ring[i];\n            var v2 = ring[(i + 1) % ring.length];\n\n            if (((v1.x >= point.x) || (v2.x >= point.x)) && (((v1.y >= point.y) && (v2.y <= point.y)) || ((v1.y <= point.y) && (v2.y >= point.y)))) {\n                var temp = ((v2.y - v1.y) * (point2.x - point.x)) - ((v2.x - v1.x) * (point2.y - point.y));\n                if (temp !== 0.0) {\n                    temp = 1.0 / temp;\n                    var ua = (((v2.x - v1.x) * (point.y - v1.y)) - ((v2.y - v1.y) * (point.x - v1.x))) * temp;\n                    var ub = (((point2.x - point.x) * (point.y - v1.y)) - ((point2.y - point.y) * (point.x - v1.x))) * temp;\n                    if ((ua >= 0.0) && (ua <= 1.0) && (ub >= 0.0) && (ub <= 1.0)) {\n                        var tempIntersection = new Cartesian2(point.x + ua * (point2.x - point.x), point.y + ua * (point2.y - point.y));\n                        var dist = Cartesian2.subtract(tempIntersection, point, distScratch);\n                        temp = Cartesian2.magnitudeSquared(dist);\n                        if (temp < minDistance) {\n                            intersection = tempIntersection;\n                            minDistance = temp;\n                            edgeIndices[0] = i;\n                            edgeIndices[1] = (i + 1) % ring.length;\n                        }\n                    }\n                }\n            }\n        }\n\n        return intersection;\n    }\n\n    /**\n     * Given an outer ring and multiple inner rings, determine the point on the outer ring that is visible\n     * to the rightmost vertex of the rightmost inner ring.\n     *\n     * @param {Cartesian2[]} outerRing An array of Cartesian points defining the outer boundary of the polygon.\n     * @param {Cartesian2[]} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.\n     * @returns {Number} The index of the vertex in <code>outerRing</code> that is mutually visible to the rightmost vertex in <code>inenrRing</code>.\n     *\n     * @private\n     */\n    var v1Scratch = new Cartesian2(1.0, 0.0);\n    var v2Scratch = new Cartesian2();\n    function getMutuallyVisibleVertexIndex(outerRing, innerRings) {\n        var innerRingIndex = getRightmostRingIndex(innerRings);\n        var innerRing = innerRings[innerRingIndex];\n        var innerRingVertexIndex = getRightmostPositionIndex(innerRing);\n        var innerRingVertex = innerRing[innerRingVertexIndex];\n        var edgeIndices = [];\n        var intersection = intersectPointWithRing(innerRingVertex, outerRing, edgeIndices);\n\n        var visibleVertex = isVertex(outerRing, intersection);\n        if (visibleVertex !== -1) {\n            return visibleVertex;\n        }\n\n        // Set P to be the edge endpoint closest to the inner ring vertex\n        var d1 = Cartesian2.magnitudeSquared(Cartesian2.subtract(outerRing[edgeIndices[0]], innerRingVertex, v1Scratch));\n        var d2 = Cartesian2.magnitudeSquared(Cartesian2.subtract(outerRing[edgeIndices[1]], innerRingVertex, v1Scratch));\n        var p = (d1 < d2) ? outerRing[edgeIndices[0]] : outerRing[edgeIndices[1]];\n\n        var reflexVertices = getReflexVertices(outerRing);\n        var reflexIndex = reflexVertices.indexOf(p);\n        if (reflexIndex !== -1) {\n            reflexVertices.splice(reflexIndex, 1); // Do not include p if it happens to be reflex.\n        }\n\n        var pointsInside = [];\n        for ( var i = 0; i < reflexVertices.length; i++) {\n            var vertex = reflexVertices[i];\n            if (pointInsideTriangle(vertex, innerRingVertex, intersection, p)) {\n                pointsInside.push(vertex);\n            }\n        }\n\n        // If all reflexive vertices are outside the triangle formed by points\n        // innerRingVertex, intersection and P, then P is the visible vertex.\n        // Otherwise, return the reflex vertex that minimizes the angle between <1,0> and <k, reflex>.\n        var minAngle = Number.MAX_VALUE;\n        if (pointsInside.length > 0) {\n            var v1 = Cartesian2.fromElements(1.0, 0.0, v1Scratch);\n            for (i = 0; i < pointsInside.length; i++) {\n                var v2 = Cartesian2.subtract(pointsInside[i], innerRingVertex, v2Scratch);\n                var denominator = Cartesian2.magnitude(v1) * Cartesian2.magnitudeSquared(v2);\n                if (denominator !== 0) {\n                    var angle = Math.abs(CesiumMath.acosClamped(Cartesian2.dot(v1, v2) / denominator));\n                    if (angle < minAngle) {\n                        minAngle = angle;\n                        p = pointsInside[i];\n                    }\n                }\n            }\n        }\n\n        return outerRing.indexOf(p);\n    }\n\n    /**\n     * Given a polygon defined by an outer ring with one or more inner rings (holes), return a single list of points representing\n     * a polygon with the rightmost hole added to it. The added hole is removed from <code>innerRings</code>.\n     *\n     * @param {Cartesian2[]} outerRing An array of Cartesian points defining the outer boundary of the polygon.\n     * @param {Cartesian2[]} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.\n     * @returns {Cartesian2[]} A single list of Cartesian points defining the polygon, including the eliminated inner ring.\n     *\n     * @private\n     */\n    function eliminateHole(outerRing, innerRings, ellipsoid) {\n        // Check that the holes are defined in the winding order opposite that of the outer ring.\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(outerRing);\n        for ( var i = 0; i < innerRings.length; i++) {\n            var ring = innerRings[i];\n\n            // Ensure each hole's first and last points are the same.\n            if (!Cartesian3.equals(ring[0], ring[ring.length - 1])) {\n                ring.push(ring[0]);\n            }\n\n            var innerWindingOrder = PolygonPipeline.computeWindingOrder2D(ring);\n            if (innerWindingOrder === windingOrder) {\n                ring.reverse();\n            }\n        }\n\n        // Project points onto a tangent plane to find the mutually visible vertex.\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n        var tangentOuterRing = tangentPlane.projectPointsOntoPlane(outerRing);\n        var tangentInnerRings = [];\n        for (i = 0; i < innerRings.length; i++) {\n            tangentInnerRings.push(tangentPlane.projectPointsOntoPlane(innerRings[i]));\n        }\n\n        var visibleVertexIndex = getMutuallyVisibleVertexIndex(tangentOuterRing, tangentInnerRings);\n        var innerRingIndex = getRightmostRingIndex(tangentInnerRings);\n        var innerRingVertexIndex = getRightmostPositionIndex(tangentInnerRings[innerRingIndex]);\n\n        var innerRing = innerRings[innerRingIndex];\n        var newPolygonVertices = [];\n\n        for (i = 0; i < outerRing.length; i++) {\n            newPolygonVertices.push(outerRing[i]);\n        }\n\n        var j;\n        var holeVerticesToAdd = [];\n\n        // If the rightmost inner vertex is not the starting and ending point of the ring,\n        // then some other point is duplicated in the inner ring and should be skipped once.\n        if (innerRingVertexIndex !== 0) {\n            for (j = 0; j <= innerRing.length; j++) {\n                var index = (j + innerRingVertexIndex) % innerRing.length;\n                if (index !== 0) {\n                    holeVerticesToAdd.push(innerRing[index]);\n                }\n            }\n        } else {\n            for (j = 0; j < innerRing.length; j++) {\n                holeVerticesToAdd.push(innerRing[(j + innerRingVertexIndex) % innerRing.length]);\n            }\n        }\n\n        var lastVisibleVertexIndex = newPolygonVertices.lastIndexOf(outerRing[visibleVertexIndex]);\n\n        holeVerticesToAdd.push(outerRing[lastVisibleVertexIndex]);\n\n        var front = newPolygonVertices.slice(0, lastVisibleVertexIndex + 1);\n        var back = newPolygonVertices.slice(lastVisibleVertexIndex + 1);\n        newPolygonVertices = front.concat(holeVerticesToAdd, back);\n\n        innerRings.splice(innerRingIndex, 1);\n\n        return newPolygonVertices;\n    }\n\n    function getRandomIndex(length) {\n        var random = CesiumMath.nextRandomNumber();\n        var i = Math.floor(random * length);\n        if (i === length) {\n            i--;\n        }\n        return i;\n    }\n\n    function indexedEdgeCrossZ(p0Index, p1Index, vertexIndex, array) {\n        var p0 = array[p0Index].position;\n        var p1 = array[p1Index].position;\n        var v = array[vertexIndex].position;\n\n        var vx = v.x;\n        var vy = v.y;\n\n        // (p0 - v).cross(p1 - v).z\n        var leftX = p0.x - vx;\n        var leftY = p0.y - vy;\n        var rightX = p1.x - vx;\n        var rightY = p1.y - vy;\n\n        return leftX * rightY - leftY * rightX;\n    }\n\n    function crossZ(p0, p1) {\n        // p0.cross(p1).z\n        return p0.x * p1.y - p0.y * p1.x;\n    }\n\n    /**\n     * Checks to make sure vertex is not superfluous.\n     *\n     * @param {Number} index Index of vertex.\n     * @param {Number} pArray Array of vertices.\n     *\n     * @exception {DeveloperError} Superfluous vertex found.\n     *\n     * @private\n     */\n    function validateVertex(index, pArray) {\n        var length = pArray.length;\n        var before = CesiumMath.mod(index - 1, length);\n        var after = CesiumMath.mod(index + 1, length);\n\n        // check if adjacent edges are parallel\n        if (indexedEdgeCrossZ(before, after, index, pArray) === 0.0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks whether cut parallel to side is internal.\n     *\n     *  e.g.\n     *\n     *  7_________6\n     *  |         |\n     *  | 4 ______|\n     *  |  |       5\n     *  |  |______2     Is cut from 1 to 6 internal? No.\n     *  | 3       |\n     *  |_________|\n     * 0           1\n     *\n     * Note that this function simply checks whether the cut is longer or shorter.\n     *\n     * An important valid cut:\n     *\n     * Polygon:\n     *\n     * 0 ___2__4\n     *  |  /\\  |\n     *  | /  \\ |   Is cut 0 to 2 or 2 to 4 internal? Yes.\n     *  |/    \\|\n     * 1       3\n     *\n     * This situation can occur and the only solution is a cut along a parallel\n     * side.\n     *\n     * This method is technically incomplete, however, for the following case:\n     *\n     *  7_________6\n     *  |         |\n     *  |         |______4\n     *  |          5     |    Now is 1 to 6 internal? Yes, but we'll never need it.\n     *  |         2______|\n     *  |         |      5\n     *  |_________|\n     * 0           1\n     *\n     * In this case, although the cut from 1 to 6 is valid, the side 1-2 is\n     * shorter and thus this cut will be called invalid. Assuming there are no\n     * superfluous vertices (a requirement for this method to work), however,\n     * we'll never need this cut because we can always find cut 2-5 as a substitute.\n     *\n     * @param {Cartesian2} side\n     * @param {Cartesian2} cut\n     * @returns {Boolean}\n     *\n     * @private\n     */\n    function isInternalToParallelSide(side, cut) {\n        return Cartesian2.magnitudeSquared(cut) < Cartesian2.magnitudeSquared(side);\n    }\n\n    var INTERNAL = -1;\n    var EXTERNAL = -2;\n\n    /**\n     * Determine whether the cut formed between the two vertices is internal\n     * to the angle formed by the sides connecting at the first vertex.\n     *\n     * @param {Number} a1i Index of first vertex.\n     * @param {Number} a2i Index of second vertex.\n     * @param {Array} pArray Array of <code>{ position, index }</code> objects representing the polygon.\n     * @returns {Number} If INTERNAL, the cut formed between the two vertices is internal to the angle at vertex 1.\n     * If EXTERNAL, then the cut formed between the two vertices is external to the angle at vertex 1. If the value\n     * is greater than or equal to zero, then the value is the index of an invalid vertex.\n     *\n     * @private\n     */\n    var s1Scratch = new Cartesian3();\n    var s2Scratch = new Cartesian3();\n    var cutScratch = new Cartesian3();\n    function internalCut(a1i, a2i, pArray) {\n        // Make sure vertex is valid\n        if (!validateVertex(a1i, pArray)) {\n            return a1i;\n        }\n\n        // Get the nodes from the array\n        var a1Position = pArray[a1i].position;\n        var a2Position = pArray[a2i].position;\n        var length = pArray.length;\n\n        // Define side and cut vectors\n        var before = CesiumMath.mod(a1i - 1, length);\n        if (!validateVertex(before, pArray)) {\n            return before;\n        }\n\n        var after = CesiumMath.mod(a1i + 1, length);\n        if (!validateVertex(after, pArray)) {\n            return after;\n        }\n\n        var s1 = Cartesian2.subtract(pArray[before].position, a1Position, s1Scratch);\n        var s2 = Cartesian2.subtract(pArray[after].position, a1Position, s2Scratch);\n        var cut = Cartesian2.subtract(a2Position, a1Position, cutScratch);\n\n        var leftEdgeCutZ = crossZ(s1, cut);\n        var rightEdgeCutZ = crossZ(s2, cut);\n\n        if (leftEdgeCutZ === 0.0) { // cut is parallel to (a1i - 1, a1i) edge\n            return isInternalToParallelSide(s1, cut) ? INTERNAL : EXTERNAL;\n        } else if (rightEdgeCutZ === 0.0) { // cut is parallel to (a1i + 1, a1i) edge\n            return isInternalToParallelSide(s2, cut) ? INTERNAL : EXTERNAL;\n        } else {\n            var z = crossZ(s1, s2);\n            if (z < 0.0) { // angle at a1i is less than 180 degrees\n                return leftEdgeCutZ < 0.0 && rightEdgeCutZ > 0.0 ? INTERNAL : EXTERNAL; // Cut is in-between sides\n            } else if (z > 0.0) { // angle at a1i is greater than 180 degrees\n                return leftEdgeCutZ > 0.0 && rightEdgeCutZ < 0.0 ? EXTERNAL : INTERNAL; // Cut is in-between sides\n            }\n        }\n    }\n\n    /**\n     * Determine whether number is between n1 and n2.\n     * Do not include number === n1 or number === n2.\n     * Do include n1 === n2 === number.\n     *\n     * @param {Number} number The number tested.\n     * @param {Number} n1 First bound.\n     * @param {Number} n2 Secound bound.\n     * @returns {Boolean} number is between n1 and n2.\n     *\n     * @private\n     */\n    function isBetween(number, n1, n2) {\n        return ((number > n1 || number > n2) && (number < n1 || number < n2)) || (n1 === n2 && n1 === number);\n    }\n\n    var sqrEpsilon = CesiumMath.EPSILON14;\n    var eScratch = new Cartesian2();\n\n    function linesIntersection(p0, d0, p1, d1) {\n        var e = Cartesian2.subtract(p1, p0, eScratch);\n        var cross = d0.x * d1.y - d0.y * d1.x;\n        var sqrCross = cross * cross;\n        var sqrLen0 = Cartesian2.magnitudeSquared(d0);\n        var sqrLen1 = Cartesian2.magnitudeSquared(d1);\n        if (sqrCross > sqrEpsilon * sqrLen0 * sqrLen1) {\n            // lines of the segments are not parallel\n            var s = (e.x * d1.y - e.y * d1.x) / cross;\n            return Cartesian2.add(p0, Cartesian2.multiplyByScalar(d0, s, eScratch), eScratch);\n        }\n\n        // lines of the segments are parallel (they cannot be the same line)\n        return undefined;\n    }\n\n    /**\n     * Determine whether this segment intersects any other polygon sides.\n     *\n     * @param {Cartesian2} a1 Position of first vertex.\n     * @param {Cartesian2} a2 Position of second vertex.\n     * @param {Array} pArray Array of <code>{ position, index }</code> objects representing polygon.\n     * @returns {Boolean} The segment between a1 and a2 intersect another polygon side.\n     *\n     * @private\n     */\n    var intersectionScratch = new Cartesian2();\n    var aDirectionScratch = new Cartesian2();\n    var bDirectionScratch = new Cartesian2();\n\n    function intersectsSide(a1, a2, pArray) {\n        var aDirection = Cartesian2.subtract(a2, a1, aDirectionScratch);\n\n        var length = pArray.length;\n        for (var i = 0; i < length; i++) {\n            var b1 = pArray[i].position;\n            var b2 = pArray[CesiumMath.mod(i + 1, length)].position;\n\n            // If there's a duplicate point, there's no intersection here.\n            if (Cartesian2.equals(a1, b1) || Cartesian2.equals(a2, b2) || Cartesian2.equals(a1, b2) || Cartesian2.equals(a2, b1)) {\n                continue;\n            }\n\n            var bDirection = Cartesian2.subtract(b2, b1, bDirectionScratch);\n            var intersection = linesIntersection(a1, aDirection, b1, bDirection);\n            if (!defined(intersection)) {\n                continue;\n            }\n\n            // If intersection is on an endpoint, count no intersection\n            if (Cartesian2.equals(intersection, a1) || Cartesian2.equals(intersection, a2) || Cartesian2.equals(intersection, b1) || Cartesian2.equals(intersection, b2)) {\n                continue;\n            }\n\n            // Is intersection point between segments?\n            var intX = intersection.x;\n            var intY = intersection.y;\n            var intersects = isBetween(intX, a1.x, a2.x) && isBetween(intY, a1.y, a2.y) && isBetween(intX, b1.x, b2.x) && isBetween(intY, b1.y, b2.y);\n\n            // If intersecting, the cut is not clean\n            if (intersects) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    var CLEAN_CUT = -1;\n    var INVALID_CUT = -2;\n\n    /**\n     * Determine whether a cut between two polygon vertices is clean.\n     *\n     * @param {Number} a1i Index of first vertex.\n     * @param {Number} a2i Index of second vertex.\n     * @param {Array} pArray Array of <code>{ position, index }</code> objects representing the polygon.\n     * @returns {Number} If CLEAN_CUT, a cut from the first vertex to the second is internal and does not cross any other sides.\n     * If INVALID_CUT, then the vertices were valid but a cut could not be made. If the value is greater than or equal to zero,\n     * then the value is the index of an invalid vertex.\n     *\n     * @private\n     */\n    function cleanCut(a1i, a2i, pArray) {\n        var internalCut12 = internalCut(a1i, a2i, pArray);\n        if (internalCut12 >= 0) {\n            return internalCut12;\n        }\n\n        var internalCut21 = internalCut(a2i, a1i, pArray);\n        if (internalCut21 >= 0) {\n            return internalCut21;\n        }\n\n        if (internalCut12 === INTERNAL && internalCut21 === INTERNAL &&\n                !intersectsSide(pArray[a1i].position, pArray[a2i].position, pArray) &&\n                !Cartesian2.equals(pArray[a1i].position, pArray[a2i].position)) {\n            return CLEAN_CUT;\n        }\n\n        return INVALID_CUT;\n    }\n\n    function triangleInLine(pArray) {\n        // Get two sides. If they're parallel, so is the last.\n        return indexedEdgeCrossZ(1, 2, 0, pArray) === 0.0;\n    }\n\n    /**\n     * This recursive algorithm takes a polygon, randomly selects two vertices\n     * which form a clean cut through the polygon, and divides the polygon\n     * then continues to \"chop\" the two resulting polygons.\n     *\n     * @param {Array} nodeArray Array of <code>{ position, index }</code> objects representing polygon\n     * @returns {Number[]} Index array representing triangles that fill the polygon\n     *\n     * @exception {DeveloperError} Invalid polygon: must have at least three vertices.\n     *\n     * @private\n     */\n    function randomChop(nodeArray) {\n        // Determine & verify number of vertices\n        var numVertices = nodeArray.length;\n\n        // Is it already a triangle?\n        if (numVertices === 3) {\n            // Only return triangle if it has area (not a line)\n            if (!triangleInLine(nodeArray)) {\n                return [nodeArray[0].index, nodeArray[1].index, nodeArray[2].index];\n            }\n\n            // If it's a line, we don't need it.\n            return [];\n        } else if (nodeArray.length < 3) {\n            throw new DeveloperError('Invalid polygon: must have at least three vertices.');\n        }\n\n        // Search for clean cut\n        var tries = 0;\n        var maxTries = nodeArray.length * 10;\n\n        var cutResult = INVALID_CUT;\n        var index1;\n        var index2;\n\n        while (cutResult < CLEAN_CUT && tries++ < maxTries) {\n            // Generate random indices\n            index1 = getRandomIndex(nodeArray.length);\n            index2 = index1 + 1;\n            while (Math.abs(index1 - index2) < 2 || Math.abs(index1 - index2) > nodeArray.length - 2) {\n                index2 = getRandomIndex(nodeArray.length);\n            }\n\n            // Make sure index2 is bigger\n            if (index1 > index2) {\n                var index = index1;\n                index1 = index2;\n                index2 = index;\n            }\n\n            cutResult = cleanCut(index1, index2, nodeArray);\n        }\n\n        if (cutResult === CLEAN_CUT) {\n            // Divide polygon\n            var nodeArray2 = nodeArray.splice(index1, (index2 - index1 + 1), nodeArray[index1], nodeArray[index2]);\n\n            // Chop up resulting polygons\n            return randomChop(nodeArray).concat(randomChop(nodeArray2));\n        } else if (cutResult >= 0) {\n            // Eliminate superfluous vertex and start over\n            nodeArray.splice(cutResult, 1);\n            return randomChop(nodeArray);\n        }\n\n        // No clean cut could be found\n        return [];\n    }\n\n    var scaleToGeodeticHeightN = new Cartesian3();\n    var scaleToGeodeticHeightP = new Cartesian3();\n\n    /**\n     * @private\n     */\n    var PolygonPipeline = {};\n\n    /**\n     * Cleans up a simple polygon by removing duplicate adjacent positions and making\n     * the first position not equal the last position.\n     *\n     * @exception {DeveloperError} At least three positions are required.\n     */\n    PolygonPipeline.removeDuplicates = function(positions) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('positions is required.');\n        }\n        //>>includeEnd('debug');\n\n        var cleanedPositions = PolylinePipeline.removeDuplicates(positions);\n        if (Cartesian3.equals(cleanedPositions[0], cleanedPositions[cleanedPositions.length - 1])) {\n            return cleanedPositions.slice(1);\n        }\n        return cleanedPositions;\n    };\n\n    /**\n     * @exception {DeveloperError} At least three positions are required.\n     */\n    PolygonPipeline.computeArea2D = function(positions) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (positions.length < 3) {\n            throw new DeveloperError('At least three positions are required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        var area = 0.0;\n\n        for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n            var v0 = positions[i0];\n            var v1 = positions[i1];\n\n            area += (v0.x * v1.y) - (v1.x * v0.y);\n        }\n\n        return area * 0.5;\n    };\n\n    /**\n     * @returns {WindingOrder} The winding order.\n     *\n     * @exception {DeveloperError} At least three positions are required.\n     */\n    PolygonPipeline.computeWindingOrder2D = function(positions) {\n        var area = PolygonPipeline.computeArea2D(positions);\n        return (area > 0.0) ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n    };\n\n    /**\n     * Triangulate a polygon.\n     *\n     * @param {Cartesian2[]} positions - Cartesian2 array containing the vertices of the polygon\n     * @returns {Number[]} - Index array representing triangles that fill the polygon\n     *\n     * @exception {DeveloperError} At least three positions are required.\n     */\n    PolygonPipeline.triangulate = function(positions) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(positions)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (positions.length < 3) {\n            throw new DeveloperError('At least three positions are required.');\n        }\n        //>>includeEnd('debug');\n\n        var length = positions.length;\n        // Keep track of indices for later\n        var nodeArray = [];\n        for ( var i = 0; i < length; ++i) {\n            nodeArray[i] = {\n                position : positions[i],\n                index : i\n            };\n        }\n\n        // Recursive chop\n        return randomChop(nodeArray);\n    };\n\n    var subdivisionV0Scratch = new Cartesian3();\n    var subdivisionV1Scratch = new Cartesian3();\n    var subdivisionV2Scratch = new Cartesian3();\n    var subdivisionS0Scratch = new Cartesian3();\n    var subdivisionS1Scratch = new Cartesian3();\n    var subdivisionS2Scratch = new Cartesian3();\n    var subdivisionMidScratch = new Cartesian3();\n\n    /**\n     * Subdivides positions and raises points to the surface of the ellipsoid.\n     *\n     * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n     * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n     * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n     * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     *\n     * @exception {DeveloperError} At least three indices are required.\n     * @exception {DeveloperError} The number of indices must be divisable by three.\n     * @exception {DeveloperError} Granularity must be greater than zero.\n     */\n    PolygonPipeline.computeSubdivision = function(ellipsoid, positions, indices, granularity) {\n        granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(ellipsoid)) {\n            throw new DeveloperError('ellipsoid is required.');\n        }\n        if (!defined(positions)) {\n            throw new DeveloperError('positions is required.');\n        }\n        if (!defined(indices)) {\n            throw new DeveloperError('indices is required.');\n        }\n        if (indices.length < 3) {\n            throw new DeveloperError('At least three indices are required.');\n        }\n        if (indices.length % 3 !== 0) {\n            throw new DeveloperError('The number of indices must be divisable by three.');\n        }\n        if (granularity <= 0.0) {\n            throw new DeveloperError('granularity must be greater than zero.');\n        }\n        //>>includeEnd('debug');\n\n        // triangles that need (or might need) to be subdivided.\n        var triangles = indices.slice(0);\n\n        // New positions due to edge splits are appended to the positions list.\n        var i;\n        var length = positions.length;\n        var subdividedPositions = new Array(length * 3);\n        var q = 0;\n        for (i = 0; i < length; i++) {\n            var item = positions[i];\n            subdividedPositions[q++] = item.x;\n            subdividedPositions[q++] = item.y;\n            subdividedPositions[q++] = item.z;\n        }\n\n        var subdividedIndices = [];\n\n        // Used to make sure shared edges are not split more than once.\n        var edges = {};\n\n        var radius = ellipsoid.maximumRadius;\n        var minDistance = CesiumMath.chordLength(granularity, radius);\n        var minDistanceSqrd = minDistance * minDistance;\n\n        while (triangles.length > 0) {\n            var i2 = triangles.pop();\n            var i1 = triangles.pop();\n            var i0 = triangles.pop();\n\n            var v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);\n            var v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);\n            var v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);\n\n            var s0 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v0, subdivisionS0Scratch), radius, subdivisionS0Scratch);\n            var s1 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v1, subdivisionS1Scratch), radius, subdivisionS1Scratch);\n            var s2 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v2, subdivisionS2Scratch), radius, subdivisionS2Scratch);\n\n            var g0 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s0, s1, subdivisionMidScratch));\n            var g1 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s1, s2, subdivisionMidScratch));\n            var g2 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s2, s0, subdivisionMidScratch));\n\n            var max = Math.max(g0, g1, g2);\n            var edge;\n            var mid;\n\n            // if the max length squared of a triangle edge is greater than the chord length of squared\n            // of the granularity, subdivide the triangle\n            if (max > minDistanceSqrd) {\n                if (g0 === max) {\n                    edge = Math.min(i0, i1) + ' ' + Math.max(i0, i1);\n\n                    i = edges[edge];\n                    if (!defined(i)) {\n                        mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n                        Cartesian3.multiplyByScalar(mid, 0.5, mid);\n                        subdividedPositions.push(mid.x, mid.y, mid.z);\n                        i = subdividedPositions.length / 3 - 1;\n                        edges[edge] = i;\n                    }\n\n                    triangles.push(i0, i, i2);\n                    triangles.push(i, i1, i2);\n                } else if (g1 === max) {\n                    edge = Math.min(i1, i2) + ' ' + Math.max(i1, i2);\n\n                    i = edges[edge];\n                    if (!defined(i)) {\n                        mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n                        Cartesian3.multiplyByScalar(mid, 0.5, mid);\n                        subdividedPositions.push(mid.x, mid.y, mid.z);\n                        i = subdividedPositions.length / 3 - 1;\n                        edges[edge] = i;\n                    }\n\n                    triangles.push(i1, i, i0);\n                    triangles.push(i, i2, i0);\n                } else if (g2 === max) {\n                    edge = Math.min(i2, i0) + ' ' + Math.max(i2, i0);\n\n                    i = edges[edge];\n                    if (!defined(i)) {\n                        mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n                        Cartesian3.multiplyByScalar(mid, 0.5, mid);\n                        subdividedPositions.push(mid.x, mid.y, mid.z);\n                        i = subdividedPositions.length / 3 - 1;\n                        edges[edge] = i;\n                    }\n\n                    triangles.push(i2, i, i1);\n                    triangles.push(i, i0, i1);\n                }\n            } else {\n                subdividedIndices.push(i0);\n                subdividedIndices.push(i1);\n                subdividedIndices.push(i2);\n            }\n        }\n\n        return new Geometry({\n            attributes : {\n                position : new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.DOUBLE,\n                    componentsPerAttribute : 3,\n                    values : subdividedPositions\n                })\n            },\n            indices : subdividedIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n    };\n\n    /**\n     * Scales each position of a geometry's position attribute to a height, in place.\n     *\n     * @param {Geometry} geometry The geometry whose positions are to be scaled.\n     * @param {Number} [height=0.0] The desired height to add to the positions of the geometry.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n     * @param {Boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n     * @returns {Geometry} The same geometry whose positions where scaled.\n     */\n    PolygonPipeline.scaleToGeodeticHeight = function(geometry, height, ellipsoid, scaleToSurface) {\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n        var n = scaleToGeodeticHeightN;\n        var p = scaleToGeodeticHeightP;\n\n        height = defaultValue(height, 0.0);\n        scaleToSurface = defaultValue(scaleToSurface, true);\n\n        if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {\n            var positions = geometry.attributes.position.values;\n            var length = positions.length;\n\n            for ( var i = 0; i < length; i += 3) {\n                Cartesian3.fromArray(positions, i, p);\n\n                if (scaleToSurface) {\n                    p = ellipsoid.scaleToGeodeticSurface(p, p);\n                }\n\n                n = ellipsoid.geodeticSurfaceNormal(p, n);\n\n                Cartesian3.multiplyByScalar(n, height, n);\n                Cartesian3.add(p, n, p);\n\n                positions[i] = p.x;\n                positions[i + 1] = p.y;\n                positions[i + 2] = p.z;\n            }\n        }\n\n        return geometry;\n    };\n\n    /**\n     * Given a polygon defined by an outer ring with one or more inner rings (holes), return a single list of points representing\n     * a polygon defined by the outer ring with the inner holes removed.\n     *\n     * @param {Cartesian2[]} outerRing An array of Cartesian points defining the outer boundary of the polygon.\n     * @param {Cartesian2[]} innerRings An array of arrays of Cartesian points, where each array represents a hole in the polygon.\n     * @returns {Cartesian2[]} A single list of Cartesian points defining the polygon, including the eliminated inner ring.\n     *\n     * @exception {DeveloperError} <code>outerRing</code> must not be empty.\n     *\n     * @example\n     * // Simplifying a polygon with multiple holes.\n     * outerRing = Cesium.PolygonPipeline.eliminateHoles(outerRing, innerRings);\n     * polygon.positions = outerRing;\n     */\n    PolygonPipeline.eliminateHoles = function(outerRing, innerRings, ellipsoid) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(outerRing)) {\n            throw new DeveloperError('outerRing is required.');\n        }\n        if (outerRing.length === 0) {\n            throw new DeveloperError('outerRing must not be empty.');\n        }\n        if (!defined(innerRings)) {\n            throw new DeveloperError('innerRings is required.');\n        }\n        //>>includeEnd('debug');\n\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n        var innerRingsCopy = [];\n        for ( var i = 0; i < innerRings.length; i++) {\n            var innerRing = [];\n            for ( var j = 0; j < innerRings[i].length; j++) {\n                innerRing.push(Cartesian3.clone(innerRings[i][j]));\n            }\n            innerRingsCopy.push(innerRing);\n        }\n\n        var newPolygonVertices = outerRing;\n        while (innerRingsCopy.length > 0) {\n            newPolygonVertices = eliminateHole(newPolygonVertices, innerRingsCopy, ellipsoid);\n        }\n        return newPolygonVertices;\n    };\n\n    return PolygonPipeline;\n});\n",
    "\n/*global define*/\ndefine('Core/RectangleGeometryLibrary',[\n        './Cartesian3',\n        './Cartographic',\n        './defined',\n        './DeveloperError',\n        './GeographicProjection',\n        './Math',\n        './Matrix2',\n        './Rectangle'\n    ], function(\n        Cartesian3,\n        Cartographic,\n        defined,\n        DeveloperError,\n        GeographicProjection,\n        CesiumMath,\n        Matrix2,\n        Rectangle) {\n    \"use strict\";\n\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var sqrt = Math.sqrt;\n\n    /**\n     * @private\n     */\n    var RectangleGeometryLibrary = {};\n\n    /**\n     * @private\n     */\n    RectangleGeometryLibrary.computePosition = function(options, row, col, position, st) {\n        var radiiSquared = options.ellipsoid.radiiSquared;\n        var nwCorner = options.nwCorner;\n        var rectangle = options.rectangle;\n\n        var stLatitude = nwCorner.latitude - options.granYCos * row + col * options.granXSin;\n        var cosLatitude = cos(stLatitude);\n        var nZ = sin(stLatitude);\n        var kZ = radiiSquared.z * nZ;\n\n        var stLongitude = nwCorner.longitude + row * options.granYSin + col * options.granXCos;\n        var nX = cosLatitude * cos(stLongitude);\n        var nY = cosLatitude * sin(stLongitude);\n\n        var kX = radiiSquared.x * nX;\n        var kY = radiiSquared.y * nY;\n\n        var gamma = sqrt((kX * nX) + (kY * nY) + (kZ * nZ));\n\n        position.x = kX / gamma;\n        position.y = kY / gamma;\n        position.z = kZ / gamma;\n\n        if (defined(options.vertexFormat) && options.vertexFormat.st) {\n            st.x = (stLongitude - rectangle.west) * options.lonScalar - 0.5;\n            st.y = (stLatitude - rectangle.south) * options.latScalar - 0.5;\n\n            Matrix2.multiplyByVector(options.textureMatrix, st, st);\n\n            st.x += 0.5;\n            st.y += 0.5;\n        }\n    };\n\n    var rotationMatrixScratch = new Matrix2();\n    var nwCartesian = new Cartesian3();\n    var centerScratch = new Cartographic();\n    var centerCartesian = new Cartesian3();\n    var proj = new GeographicProjection();\n    /**\n     * @private\n     */\n    RectangleGeometryLibrary.computeOptions = function(geometry, rectangle, nwCorner) {\n        var granularity = geometry._granularity;\n        var ellipsoid = geometry._ellipsoid;\n        var surfaceHeight = geometry._surfaceHeight;\n        var rotation = geometry._rotation;\n        var extrudedHeight = geometry._extrudedHeight;\n        var east = rectangle.east;\n        var west = rectangle.west;\n        var north = rectangle.north;\n        var south = rectangle.south;\n\n        var width;\n        var height;\n        var granularityX;\n        var granularityY;\n        var dx;\n        var dy = north - south;\n        if (west > east) {\n            dx = (CesiumMath.TWO_PI - west + east);\n            width = Math.ceil(dx / granularity) + 1;\n            height = Math.ceil(dy / granularity) + 1;\n            granularityX = dx / (width - 1);\n            granularityY = dy / (height - 1);\n        } else {\n            dx = east - west;\n            width = Math.ceil(dx / granularity) + 1;\n            height = Math.ceil(dy / granularity) + 1;\n            granularityX = dx / (width - 1);\n            granularityY = dy / (height - 1);\n        }\n\n        nwCorner = Rectangle.northwest(rectangle, nwCorner);\n        var center = Rectangle.center(rectangle, centerScratch);\n\n        var granYCos = granularityY;\n        var granXCos = granularityX;\n        var granYSin = 0.0;\n        var granXSin = 0.0;\n\n        if (defined(rotation)) { // rotation doesn't work when center is on/near IDL\n            var cosRotation = Math.cos(rotation);\n            granYCos *= cosRotation;\n            granXCos *= cosRotation;\n\n            var sinRotation = Math.sin(rotation);\n            granYSin = granularityY * sinRotation;\n            granXSin = granularityX * sinRotation;\n\n            nwCartesian = proj.project(nwCorner, nwCartesian);\n            centerCartesian = proj.project(center, centerCartesian);\n\n            nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);\n            var rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);\n            nwCartesian = Matrix2.multiplyByVector(rotationMatrix, nwCartesian, nwCartesian);\n            nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);\n            nwCorner = proj.unproject(nwCartesian, nwCorner);\n\n            var latitude = nwCorner.latitude;\n            var latitude0 = latitude + (width - 1) * granXSin;\n            var latitude1 = latitude - granYCos * (height - 1);\n            var latitude2 = latitude - granYCos * (height - 1) + (width - 1) * granXSin;\n\n            north = Math.max(latitude, latitude0, latitude1, latitude2);\n            south = Math.min(latitude, latitude0, latitude1, latitude2);\n\n            var longitude = nwCorner.longitude;\n            var longitude0 = longitude + (width - 1) * granXCos;\n            var longitude1 = longitude + (height - 1) * granYSin;\n            var longitude2 = longitude + (height - 1) * granYSin + (width - 1) * granXCos;\n\n            east = Math.max(longitude, longitude0, longitude1, longitude2);\n            west = Math.min(longitude, longitude0, longitude1, longitude2);\n\n            if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO ||\n                    south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {\n                throw new DeveloperError('Rotated extent is invalid.');\n            }\n\n            rectangle.north = north;\n            rectangle.south = south;\n            rectangle.east = east;\n            rectangle.west = west;\n        }\n\n         return {\n            granYCos : granYCos,\n            granYSin : granYSin,\n            granXCos : granXCos,\n            granXSin : granXSin,\n            ellipsoid : ellipsoid,\n            width : width,\n            height : height,\n            surfaceHeight : surfaceHeight,\n            extrudedHeight : extrudedHeight,\n            nwCorner: nwCorner,\n            rectangle: rectangle\n        };\n    };\n\n    return RectangleGeometryLibrary;\n});",
    "\n/*global define*/\ndefine('Core/VertexFormat',[\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './freezeObject'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        freezeObject) {\n    \"use strict\";\n\n    /**\n     * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided\n     * to a {@link Geometry} to request that certain properties be computed, e.g., just position,\n     * position and normal, etc.\n     *\n     * @param {Object} [options] An object with boolean properties corresponding to VertexFormat properties as shown in the code example.\n     *\n     * @alias VertexFormat\n     * @constructor\n     *\n     * @example\n     * // Create a vertex format with position and 2D texture coordinate attributes.\n     * var format = new Cesium.VertexFormat({\n     *   position : true,\n     *   st : true\n     * });\n     *\n     * @see Geometry#attributes\n     * @see Packable\n     */\n    var VertexFormat = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        /**\n         * When <code>true</code>, the vertex has a 3D position attribute.\n         * <p>\n         * 64-bit floating-point (for precision).  3 components per attribute.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.position = defaultValue(options.position, false);\n\n        /**\n         * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.normal = defaultValue(options.normal, false);\n\n        /**\n         * When <code>true</code>, the vertex has a 2D texture coordinate attribute.\n         * <p>\n         * 32-bit floating-point.  2 components per attribute\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.st = defaultValue(options.st, false);\n\n        /**\n         * When <code>true</code>, the vertex has a binormal attribute (normalized), which is used for tangent-space effects like bump mapping.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.binormal = defaultValue(options.binormal, false);\n\n        /**\n         * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n         * <p>\n         * 32-bit floating-point.  3 components per attribute.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.tangent = defaultValue(options.tangent, false);\n\n        /**\n         * When <code>true</code>, the vertex has an RGB color attribute.\n         * <p>\n         * 8-bit unsigned byte.  3 components per attribute.\n         * </p>\n         *\n         * @type Boolean\n         *\n         * @default false\n         */\n        this.color = defaultValue(options.color, false);\n    };\n\n    /**\n     * An immutable vertex format with only a position attribute.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     */\n    VertexFormat.POSITION_ONLY = freezeObject(new VertexFormat({\n        position : true\n    }));\n\n    /**\n     * An immutable vertex format with position and normal attributes.\n     * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#normal\n     */\n    VertexFormat.POSITION_AND_NORMAL = freezeObject(new VertexFormat({\n        position : true,\n        normal : true\n    }));\n\n    /**\n     * An immutable vertex format with position, normal, and st attributes.\n     * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}\n     * is <code>TEXTURED/code>.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#normal\n     * @see VertexFormat#st\n     */\n    VertexFormat.POSITION_NORMAL_AND_ST = freezeObject(new VertexFormat({\n        position : true,\n        normal : true,\n        st : true\n    }));\n\n    /**\n     * An immutable vertex format with position and st attributes.\n     * This is compatible with {@link EllipsoidSurfaceAppearance}.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#st\n     */\n    VertexFormat.POSITION_AND_ST = freezeObject(new VertexFormat({\n        position : true,\n        st : true\n    }));\n\n    /**\n     * An immutable vertex format with position and color attributes.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#color\n     */\n    VertexFormat.POSITION_AND_COLOR = freezeObject(new VertexFormat({\n        position : true,\n        color : true\n    }));\n\n    /**\n     * An immutable vertex format with well-known attributes: position, normal, st, binormal, and tangent.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#normal\n     * @see VertexFormat#st\n     * @see VertexFormat#binormal\n     * @see VertexFormat#tangent\n     */\n    VertexFormat.ALL = freezeObject(new VertexFormat({\n        position : true,\n        normal : true,\n        st : true,\n        binormal : true,\n        tangent  : true\n    }));\n\n    /**\n     * An immutable vertex format with position, normal, and st attributes.\n     * This is compatible with most appearances and materials; however\n     * normal and st attributes are not always required.  When this is\n     * known in advance, another <code>VertexFormat</code> should be used.\n     *\n     * @type {VertexFormat}\n     * @constant\n     *\n     * @see VertexFormat#position\n     * @see VertexFormat#normal\n     */\n    VertexFormat.DEFAULT = VertexFormat.POSITION_NORMAL_AND_ST;\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    VertexFormat.packedLength = 6;\n\n    /**\n     * Stores the provided instance into the provided array.\n     * @function\n     *\n     * @param {VertexFormat} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    VertexFormat.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value.position ? 1.0 : 0.0;\n        array[startingIndex++] = value.normal ? 1.0 : 0.0;\n        array[startingIndex++] = value.st ? 1.0 : 0.0;\n        array[startingIndex++] = value.binormal ? 1.0 : 0.0;\n        array[startingIndex++] = value.tangent ? 1.0 : 0.0;\n        array[startingIndex++] = value.color ? 1.0 : 0.0;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {VertexFormat} [result] The object into which to store the result.\n     * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided.\n     */\n    VertexFormat.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        if (!defined(result)) {\n            result = new VertexFormat();\n        }\n\n        result.position = array[startingIndex++] === 1.0;\n        result.normal   = array[startingIndex++] === 1.0;\n        result.st       = array[startingIndex++] === 1.0;\n        result.binormal = array[startingIndex++] === 1.0;\n        result.tangent  = array[startingIndex++] === 1.0;\n        result.color    = array[startingIndex++] === 1.0;\n        return result;\n    };\n\n    /**\n     * Duplicates a VertexFormat instance.\n     *\n     * @param {VertexFormat} cartesian The vertex format to duplicate.\n     * @param {VertexFormat} [result] The object onto which to store the result.\n     * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)\n     */\n    VertexFormat.clone = function(vertexFormat, result) {\n        if (!defined(vertexFormat)) {\n            return undefined;\n        }\n        if (!defined(result)) {\n            result = new VertexFormat();\n        }\n\n        result.position = vertexFormat.position;\n        result.normal = vertexFormat.normal;\n        result.st = vertexFormat.st;\n        result.binormal = vertexFormat.binormal;\n        result.tangent = vertexFormat.tangent;\n        result.color = vertexFormat.color;\n        return result;\n    };\n\n    return VertexFormat;\n});",
    "\n/*global define*/\ndefine('Core/RectangleGeometry',[\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartographic',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryInstance',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './Matrix2',\n        './Matrix3',\n        './PolygonPipeline',\n        './PrimitiveType',\n        './Quaternion',\n        './Rectangle',\n        './RectangleGeometryLibrary',\n        './VertexFormat'\n    ], function(\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Cartographic,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryInstance,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        Matrix2,\n        Matrix3,\n        PolygonPipeline,\n        PrimitiveType,\n        Quaternion,\n        Rectangle,\n        RectangleGeometryLibrary,\n        VertexFormat) {\n    \"use strict\";\n\n    var positionScratch = new Cartesian3();\n    var normalScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var binormalScratch = new Cartesian3();\n    var rectangleScratch = new Rectangle();\n    var stScratch = new Cartesian2();\n    var bottomBoundingSphere = new BoundingSphere();\n    var topBoundingSphere = new BoundingSphere();\n\n    function createAttributes(vertexFormat, attributes) {\n        var geo = new Geometry({\n            attributes : new GeometryAttributes(),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        geo.attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : attributes.positions\n        });\n        if (vertexFormat.normal) {\n            geo.attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.normals\n            });\n        }\n        if (vertexFormat.tangent) {\n            geo.attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.tangents\n            });\n        }\n        if (vertexFormat.binormal) {\n            geo.attributes.binormal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attributes.binormals\n            });\n        }\n        return geo;\n    }\n\n    function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var binormals = (vertexFormat.binormal) ? new Float32Array(length) : undefined;\n\n        var attrIndex = 0;\n        var binormal = binormalScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        for (var i = 0; i < length; i += 3) {\n            var p = Cartesian3.fromArray(positions, i, positionScratch);\n            var attrIndex1 = attrIndex + 1;\n            var attrIndex2 = attrIndex + 2;\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {\n                normal = ellipsoid.geodeticSurfaceNormal(p, normal);\n                if (vertexFormat.tangent || vertexFormat.binormal) {\n                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                    Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);\n                    Cartesian3.normalize(tangent, tangent);\n\n                    if (vertexFormat.binormal) {\n                        Cartesian3.normalize(Cartesian3.cross(normal, tangent, binormal), binormal);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[attrIndex] = normal.x;\n                    normals[attrIndex1] = normal.y;\n                    normals[attrIndex2] = normal.z;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[attrIndex] = tangent.x;\n                    tangents[attrIndex1] = tangent.y;\n                    tangents[attrIndex2] = tangent.z;\n                }\n                if (vertexFormat.binormal) {\n                    binormals[attrIndex] = binormal.x;\n                    binormals[attrIndex1] = binormal.y;\n                    binormals[attrIndex2] = binormal.z;\n                }\n            }\n            attrIndex += 3;\n        }\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            binormals : binormals\n        });\n    }\n\n    var v1Scratch = new Cartesian3();\n    var v2Scratch = new Cartesian3();\n    function calculateAttributesWall(positions, vertexFormat, ellipsoid) {\n        var length = positions.length;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(length) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(length) : undefined;\n        var binormals = (vertexFormat.binormal) ? new Float32Array(length) : undefined;\n\n        var normalIndex = 0;\n        var tangentIndex = 0;\n        var binormalIndex = 0;\n        var recomputeNormal = true;\n\n        var binormal = binormalScratch;\n        var tangent = tangentScratch;\n        var normal = normalScratch;\n        for (var i = 0; i < length; i += 6) {\n            var p = Cartesian3.fromArray(positions, i, positionScratch);\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {\n                var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);\n                if (recomputeNormal) {\n                    var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);\n                    Cartesian3.subtract(p1, p, p1);\n                    Cartesian3.subtract(p2, p, p2);\n                    normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) { // if we've reached a corner\n                    recomputeNormal = true;\n                }\n\n                if (vertexFormat.tangent || vertexFormat.binormal) {\n                    binormal = ellipsoid.geodeticSurfaceNormal(p, binormal);\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(binormal, normal, tangent), tangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.binormal) {\n                    binormals[binormalIndex++] = binormal.x;\n                    binormals[binormalIndex++] = binormal.y;\n                    binormals[binormalIndex++] = binormal.z;\n                    binormals[binormalIndex++] = binormal.x;\n                    binormals[binormalIndex++] = binormal.y;\n                    binormals[binormalIndex++] = binormal.z;\n                }\n            }\n        }\n\n        return createAttributes(vertexFormat, {\n            positions : positions,\n            normals : normals,\n            tangents : tangents,\n            binormals : binormals\n        });\n    }\n\n    function constructRectangle(options) {\n        var vertexFormat = options.vertexFormat;\n        var ellipsoid = options.ellipsoid;\n        var size = options.size;\n        var height = options.height;\n        var width = options.width;\n\n        var positions = (vertexFormat.position) ? new Float64Array(size * 3) : undefined;\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n\n        var posIndex = 0;\n        var stIndex = 0;\n\n        var position = positionScratch;\n        var st = stScratch;\n\n        var minX = Number.MAX_VALUE;\n        var minY = Number.MAX_VALUE;\n        var maxX = Number.MIN_VALUE;\n        var maxY = Number.MIN_VALUE;\n\n        for (var row = 0; row < height; ++row) {\n            for (var col = 0; col < width; ++col) {\n                RectangleGeometryLibrary.computePosition(options, row, col, position, st);\n\n                positions[posIndex++] = position.x;\n                positions[posIndex++] = position.y;\n                positions[posIndex++] = position.z;\n\n                if (vertexFormat.st) {\n                    textureCoordinates[stIndex++] = st.x;\n                    textureCoordinates[stIndex++] = st.y;\n\n                    minX = Math.min(minX, st.x);\n                    minY = Math.min(minY, st.y);\n                    maxX = Math.max(maxX, st.x);\n                    maxY = Math.max(maxY, st.y);\n                }\n            }\n        }\n\n        if (vertexFormat.st && (minX < 0.0 || minY < 0.0 || maxX > 1.0 || maxY > 1.0)) {\n            for (var k = 0; k < textureCoordinates.length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);\n            }\n        }\n\n        var geo = calculateAttributes(positions, vertexFormat, ellipsoid, options.tangentRotationMatrix);\n\n        var indicesSize = 6 * (width - 1) * (height - 1);\n        var indices = IndexDatatype.createTypedArray(size, indicesSize);\n        var index = 0;\n        var indicesIndex = 0;\n        for (var i = 0; i < height - 1; ++i) {\n            for (var j = 0; j < width - 1; ++j) {\n                var upperLeft = index;\n                var lowerLeft = upperLeft + width;\n                var lowerRight = lowerLeft + 1;\n                var upperRight = upperLeft + 1;\n                indices[indicesIndex++] = upperLeft;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = upperRight;\n                indices[indicesIndex++] = lowerLeft;\n                indices[indicesIndex++] = lowerRight;\n                ++index;\n            }\n            ++index;\n        }\n\n        geo.indices = indices;\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return geo;\n    }\n\n    function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {\n        wallPositions[posIndex++] = topPositions[i];\n        wallPositions[posIndex++] = topPositions[i + 1];\n        wallPositions[posIndex++] = topPositions[i + 2];\n        wallPositions[posIndex++] = bottomPositions[i];\n        wallPositions[posIndex++] = bottomPositions[i + 1];\n        wallPositions[posIndex++] = bottomPositions[i + 2];\n        return wallPositions;\n    }\n\n    function addWallTextureCoordinates(wallTextures, stIndex, i, st) {\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex++] = st[i + 1];\n        wallTextures[stIndex++] = st[i];\n        wallTextures[stIndex++] = st[i + 1];\n        return wallTextures;\n    }\n\n    function constructExtrudedRectangle(options) {\n        var vertexFormat = options.vertexFormat;\n        var surfaceHeight = options.surfaceHeight;\n        var extrudedHeight = options.extrudedHeight;\n        var minHeight = Math.min(extrudedHeight, surfaceHeight);\n        var maxHeight = Math.max(extrudedHeight, surfaceHeight);\n\n        var height = options.height;\n        var width = options.width;\n        var ellipsoid = options.ellipsoid;\n        var i;\n\n        var topBottomGeo = constructRectangle(options);\n        if (CesiumMath.equalsEpsilon(minHeight, maxHeight, CesiumMath.EPSILON10)) {\n            return topBottomGeo;\n        }\n        topBottomGeo = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo, maxHeight, ellipsoid, false);\n        var topPositions = new Float64Array(topBottomGeo.attributes.position.values);\n        var length = topPositions.length;\n        var newLength = length*2;\n        var positions = new Float64Array(newLength);\n        positions.set(topPositions);\n        topBottomGeo = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo, minHeight, ellipsoid);\n        var bottomPositions = topBottomGeo.attributes.position.values;\n        positions.set(bottomPositions, length);\n        topBottomGeo.attributes.position.values = positions;\n\n        var normals = (vertexFormat.normal) ? new Float32Array(newLength) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(newLength) : undefined;\n        var binormals = (vertexFormat.binormal) ? new Float32Array(newLength) : undefined;\n        var textures = (vertexFormat.st) ? new Float32Array(newLength/3*2) : undefined;\n        var topSt;\n        if (vertexFormat.normal) {\n            var topNormals = topBottomGeo.attributes.normal.values;\n            normals.set(topNormals);\n            for (i = 0; i < length; i ++) {\n                topNormals[i] = -topNormals[i];\n            }\n            normals.set(topNormals, length);\n            topBottomGeo.attributes.normal.values = normals;\n        }\n        if (vertexFormat.tangent) {\n            var topTangents = topBottomGeo.attributes.tangent.values;\n            tangents.set(topTangents);\n            for (i = 0; i < length; i ++) {\n                topTangents[i] = -topTangents[i];\n            }\n            tangents.set(topTangents, length);\n            topBottomGeo.attributes.tangent.values = tangents;\n        }\n        if (vertexFormat.binormal) {\n            var topBinormals = topBottomGeo.attributes.binormal.values;\n            binormals.set(topBinormals);\n            binormals.set(topBinormals, length);\n            topBottomGeo.attributes.binormal.values = binormals;\n        }\n        if (vertexFormat.st) {\n            topSt = topBottomGeo.attributes.st.values;\n            textures.set(topSt);\n            textures.set(topSt, length/3*2);\n            topBottomGeo.attributes.st.values = textures;\n        }\n\n        var indices = topBottomGeo.indices;\n        var indicesLength = indices.length;\n        var posLength = length / 3;\n        var newIndices = IndexDatatype.createTypedArray(newLength/3, indicesLength*2);\n        newIndices.set(indices);\n        for (i = 0; i < indicesLength; i += 3) {\n            newIndices[i + indicesLength] = indices[i + 2] + posLength;\n            newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;\n            newIndices[i + 2 + indicesLength] = indices[i] + posLength;\n        }\n        topBottomGeo.indices = newIndices;\n\n        var perimeterPositions = 2 * width + 2 * height - 4;\n        var wallCount = (perimeterPositions + 4) * 2;\n\n        var wallPositions = new Float64Array(wallCount * 3);\n        var wallTextures = (vertexFormat.st) ? new Float32Array(wallCount * 2) : undefined;\n\n        var posIndex = 0;\n        var stIndex = 0;\n        var area = width * height;\n        for (i = 0; i < area; i+=width) {\n            wallPositions = addWallPositions(wallPositions, posIndex, i*3, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i*2, topSt);\n                stIndex += 4;\n            }\n        }\n\n        for (i = area-width; i < area; i++) {\n            wallPositions = addWallPositions(wallPositions, posIndex, i*3, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i*2, topSt);\n                stIndex += 4;\n            }\n        }\n\n        for (i = area-1; i > 0; i-=width) {\n            wallPositions = addWallPositions(wallPositions, posIndex, i*3, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i*2, topSt);\n                stIndex += 4;\n            }\n        }\n\n        for (i = width-1; i >= 0; i--) {\n            wallPositions = addWallPositions(wallPositions, posIndex, i*3, topPositions, bottomPositions);\n            posIndex += 6;\n            if (vertexFormat.st) {\n                wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i*2, topSt);\n                stIndex += 4;\n            }\n        }\n\n        var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);\n\n        if (vertexFormat.st) {\n            geo.attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : wallTextures\n            });\n        }\n\n        var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);\n\n        var upperLeft;\n        var lowerLeft;\n        var lowerRight;\n        var upperRight;\n        length = wallPositions.length / 3;\n        var index = 0;\n        for (i = 0; i < length - 1; i+=2) {\n            upperLeft = i;\n            upperRight = (upperLeft + 2) % length;\n            var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);\n            var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);\n            if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            lowerLeft = (upperLeft + 1) % length;\n            lowerRight = (lowerLeft + 2) % length;\n            wallIndices[index++] = upperLeft;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = upperRight;\n            wallIndices[index++] = lowerLeft;\n            wallIndices[index++] = lowerRight;\n        }\n\n        geo.indices = wallIndices;\n\n        geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : geo\n            })\n        ]);\n\n        return geo[0];\n    }\n\n    /**\n     * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias RectangleGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0.0] The height from the surface of the ellipsoid.\n     * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Number} [options.extrudedHeight] Height of extruded surface.\n     *\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].\n     * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].\n     * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.\n     *\n     * @see RectangleGeometry#createGeometry\n     *\n     * @demo {@link http://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}\n     *\n     * @example\n     * // 1. create an rectangle\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     *\n     * // 2. create an extruded rectangle without a top\n     * var rectangle = new Cesium.RectangleGeometry({\n     *   ellipsoid : Cesium.Ellipsoid.WGS84,\n     *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),\n     *   height : 10000.0,\n     *   extrudedHieght: 300000,\n     *   closeTop: false\n     * });\n     * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);\n     */\n    var RectangleGeometry = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var rectangle = options.rectangle;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var surfaceHeight = defaultValue(options.height, 0.0);\n        var rotation = defaultValue(options.rotation, 0.0);\n        var stRotation = defaultValue(options.stRotation, 0.0);\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var extrudedHeight = options.extrudedHeight;\n        var extrude = defined(extrudedHeight);\n        var closeTop = defaultValue(options.closeTop, true);\n        var closeBottom = defaultValue(options.closeBottom, true);\n\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(rectangle)) {\n            throw new DeveloperError('rectangle is required.');\n        }\n        Rectangle.validate(rectangle);\n        if (rectangle.north < rectangle.south) {\n            throw new DeveloperError('options.rectangle.north must be greater than options.rectangle.south');\n        }\n        //>>includeEnd('debug');\n\n        this._rectangle = rectangle;\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._surfaceHeight = surfaceHeight;\n        this._rotation = rotation;\n        this._stRotation = stRotation;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._extrudedHeight = defaultValue(extrudedHeight, 0.0);\n        this._extrude = extrude;\n        this._closeTop = closeTop;\n        this._closeBottom = closeBottom;\n        this._workerName = 'createRectangleGeometry';\n    };\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 8;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {RectangleGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     */\n    RectangleGeometry.pack = function(value, array, startingIndex) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value)) {\n            throw new DeveloperError('value is required');\n        }\n\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Rectangle.pack(value._rectangle, array, startingIndex);\n        startingIndex += Rectangle.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._surfaceHeight;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._extrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n        array[startingIndex]   = value._closeBottom ? 1.0 : 0.0;\n    };\n\n    var scratchRectangle = new Rectangle();\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        rectangle : scratchRectangle,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined,\n        height : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        extrudedHeight : undefined,\n        closeTop : undefined,\n        closeBottom : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {RectangleGeometry} [result] The object into which to store the result.\n     * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.\n     */\n    RectangleGeometry.unpack = function(array, startingIndex, result) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(array)) {\n            throw new DeveloperError('array is required');\n        }\n        //>>includeEnd('debug');\n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);\n        startingIndex += Rectangle.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex++];\n        var surfaceHeight = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var extrude = array[startingIndex++] === 1.0;\n        var closeTop = array[startingIndex++] === 1.0;\n        var closeBottom = array[startingIndex] === 1.0;\n\n        if (!defined(result)) {\n            scratchOptions.granularity = granularity;\n            scratchOptions.height = surfaceHeight;\n            scratchOptions.rotation = rotation;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.extrudedHeight = extrude ? extrudedHeight : undefined;\n            scratchOptions.closeTop = closeTop;\n            scratchOptions.closeBottom = closeBottom;\n            return new RectangleGeometry(scratchOptions);\n        }\n\n        result._rectangle = Rectangle.clone(rectangle, result._rectangle);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n        result._surfaceHeight = surfaceHeight;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._extrudedHeight = extrude ? extrudedHeight : undefined;\n        result._extrude = extrude;\n        result._closeTop = closeTop;\n        result._closeBottom = closeBottom;\n\n        return result;\n    };\n\n    var textureMatrixScratch = new Matrix2();\n    var tangentRotationMatrixScratch = new Matrix3();\n    var nwScratch = new Cartographic();\n    var quaternionScratch = new Quaternion();\n    var centerScratch = new Cartographic();\n    /**\n     * Computes the geometric representation of an rectangle, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.\n     * @returns {Geometry} The computed vertices and indices.\n     *\n     * @exception {DeveloperError} Rotated rectangle is invalid.\n     */\n    RectangleGeometry.createGeometry = function(rectangleGeometry) {\n        var rectangle = Rectangle.clone(rectangleGeometry._rectangle, rectangleScratch);\n        var ellipsoid = rectangleGeometry._ellipsoid;\n        var surfaceHeight = rectangleGeometry._surfaceHeight;\n        var extrude = rectangleGeometry._extrude;\n        var extrudedHeight = rectangleGeometry._extrudedHeight;\n        var stRotation = rectangleGeometry._stRotation;\n        var vertexFormat = rectangleGeometry._vertexFormat;\n\n        var options = RectangleGeometryLibrary.computeOptions(rectangleGeometry, rectangle, nwScratch);\n\n        var textureMatrix = textureMatrixScratch;\n        var tangentRotationMatrix = tangentRotationMatrixScratch;\n        if (defined(stRotation)) {\n            // negate angle for a counter-clockwise rotation\n            Matrix2.fromRotation(-stRotation, textureMatrix);\n            var center = Rectangle.center(rectangle, centerScratch);\n            var axis = ellipsoid.cartographicToCartesian(center, v1Scratch);\n            Cartesian3.normalize(axis, axis);\n            Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);\n            Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);\n        } else {\n            Matrix2.clone(Matrix2.IDENTITY, textureMatrix);\n            Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n        }\n\n        options.lonScalar = 1.0 / rectangle.width;\n        options.latScalar = 1.0 / rectangle.height;\n        options.vertexFormat = vertexFormat;\n        options.textureMatrix = textureMatrix;\n        options.tangentRotationMatrix = tangentRotationMatrix;\n        options.size = options.width * options.height;\n\n        var geometry;\n        var boundingSphere;\n        rectangle = rectangleGeometry._rectangle;\n        if (extrude) {\n            geometry = constructExtrudedRectangle(options);\n            var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);\n            var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);\n            boundingSphere = BoundingSphere.union(topBS, bottomBS);\n        } else {\n            geometry = constructRectangle(options);\n            geometry = PolygonPipeline.scaleToGeodeticHeight(geometry, surfaceHeight, ellipsoid, false);\n            boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);\n        }\n\n        if (!vertexFormat.position) {\n            delete geometry.attributes.position;\n        }\n\n        return new Geometry({\n            attributes : new GeometryAttributes(geometry.attributes),\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\n\n    /**\n     * @private\n     */\n    RectangleGeometry.createShadowVolume = function(rectangleGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = rectangleGeometry._granularity;\n        var ellipsoid = rectangleGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        // TODO: stRotation\n        return new RectangleGeometry({\n            rectangle : rectangleGeometry._rectangle,\n            rotation : rectangleGeometry._rotation,\n            ellipsoid : ellipsoid,\n            stRotation : rectangleGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : maxHeight,\n            height : minHeight,\n            closeTop : true,\n            closeBottom : true,\n            vertexFormat : VertexFormat.POSITION_ONLY\n        });\n    };\n\n    return RectangleGeometry;\n});\n",
    "\n/*global define*/\ndefine('Workers/createRectangleGeometry',[\n        '../Core/defined',\n        '../Core/Ellipsoid',\n        '../Core/Rectangle',\n        '../Core/RectangleGeometry'\n    ], function(\n        defined,\n        Ellipsoid,\n        Rectangle,\n        RectangleGeometry) {\n    \"use strict\";\n\n    function createRectangleGeometry(rectangleGeometry, offset) {\n        if (defined(offset)) {\n            rectangleGeometry = RectangleGeometry.unpack(rectangleGeometry, offset);\n        }\n        rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);\n        rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);\n        return RectangleGeometry.createGeometry(rectangleGeometry);\n    }\n\n    return createRectangleGeometry;\n});\n"
  ]
}